"use strict";
// Copyright Datastax, Inc
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.p = exports.isNonEmpty = exports.EqualityProof = void 0;
const utils_1 = require("../lib/utils");
const EqualityProof = () => { };
exports.EqualityProof = EqualityProof;
const isNonEmpty = (xs) => {
    return xs.length !== 0;
};
exports.isNonEmpty = isNonEmpty;
exports.p = {
    includes(xs, x) {
        return xs.includes(x);
    },
    mkStrEnumParser: (name, xs, required) => (x, field) => {
        if ((required && (0, utils_1.isNullish)(x)) || (typeof x !== 'string' && !(0, utils_1.isNullish)(x))) {
            throw new TypeError(`Expected ${field} to be of string enum ${name}, but got ${typeof x}`);
        }
        if (!(0, utils_1.isNullish)(x) && !exports.p.includes(xs, x)) {
            throw new TypeError(`Expected ${field} to be of string enum ${name}${required ? '' : '(or null/undefined)'} (one of ${xs.join(', ')}), but got '${x}'`);
        }
        return x ?? undefined;
    },
    parse: (expected, parser = x => x) => (x, field) => {
        if (expected.at(-1) === '!' && (0, utils_1.isNullish)(x)) {
            throw new TypeError(`Expected ${field} to be of type ${expected} (non-null), but got null or undefined`);
        }
        else if ((0, utils_1.isNullish)(x)) {
            return undefined;
        }
        if (typeof x !== expected.slice(0, -1)) {
            throw new TypeError(`Expected ${field} to be of type ${expected} (or nullish), but got ${typeof x}`);
        }
        return parser(x, field);
    },
};
