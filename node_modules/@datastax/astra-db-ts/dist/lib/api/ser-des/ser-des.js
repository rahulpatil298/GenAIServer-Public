"use strict";
// Copyright Datastax, Inc
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.SerDes = void 0;
const utils_1 = require("../../../lib/utils");
const codecs_1 = require("../../../lib/api/ser-des/codecs");
const ctx_1 = require("../../../lib/api/ser-des/ctx");
class SerDes {
    constructor(_cfg) {
        Object.defineProperty(this, "_cfg", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _cfg
        });
        Object.defineProperty(this, "_codecs", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_customState", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "_camelSnakeCache", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._codecs = (0, codecs_1.initCodecs)(_cfg.codecs ?? []);
        if (this._cfg.snakeCaseInterop) {
            this._camelSnakeCache = {};
        }
    }
    serializeRecord(obj) {
        if (obj === null || obj === undefined) {
            return [obj, false];
        }
        const ctx = this.adaptSerCtx(this._mkCtx(obj, { mutatingInPlace: this._cfg.mutateInPlace === true }));
        return [serializeRecord('', { ['']: ctx.rootObj }, ctx, (0, utils_1.toArray)(this._cfg.serialize))[''], this.bigNumsPresent(ctx)];
    }
    deserializeRecord(obj, raw, parsingId = false) {
        if (obj === null || obj === undefined) {
            return obj;
        }
        const ctx = this.adaptDesCtx(this._mkCtx(obj, { rawDataApiResp: raw, keys: [], parsingInsertedId: parsingId }));
        return deserializeRecord('', { ['']: ctx.rootObj }, ctx, (0, utils_1.toArray)(this._cfg.deserialize))[''];
    }
    static _mergeConfig(...cfg) {
        return cfg.reduce((acc, cfg) => ({
            serialize: [...(0, utils_1.toArray)(cfg?.serialize ?? []), ...(0, utils_1.toArray)(acc.serialize ?? [])],
            deserialize: [...(0, utils_1.toArray)(cfg?.deserialize ?? []), ...(0, utils_1.toArray)(acc.deserialize ?? [])],
            mutateInPlace: !!(cfg?.mutateInPlace ?? acc.mutateInPlace),
            snakeCaseInterop: !!(cfg?.snakeCaseInterop ?? acc.snakeCaseInterop),
            codecs: [...acc.codecs ?? [], ...cfg?.codecs ?? []],
        }), {});
    }
    _mkCtx(obj, ctx) {
        return {
            done: ctx_1.ctxDone,
            recurse: ctx_1.ctxRecurse,
            continue: ctx_1.ctxContinue,
            codecs: this._codecs,
            customState: this._customState,
            camelSnakeCache: this._camelSnakeCache,
            rootObj: obj,
            path: [],
            ...ctx,
        };
    }
}
exports.SerDes = SerDes;
function serializeRecord(key, obj, ctx, fns) {
    const stop = applySerdesFns(fns, key, obj, ctx);
    if (!stop && ctx.path.length < 250 && typeof obj[key] === 'object' && obj[key] !== null) {
        obj[key] = serializeRecordHelper(obj[key], ctx, fns);
    }
    return obj;
}
function serializeRecordHelper(obj, ctx, fns) {
    obj = (!ctx.mutatingInPlace)
        ? (Array.isArray(obj) ? [...obj] : { ...obj })
        : obj;
    const path = ctx.path;
    path.push('<temp>');
    for (let keys = Object.keys(obj), i = keys.length; i--;) {
        let key = keys[i];
        path[path.length - 1] = key;
        serializeRecord(key, obj, ctx, fns);
        if (ctx.camelSnakeCache) {
            const oldKey = key;
            key = (0, utils_1.camelToSnakeCase)(key, ctx.camelSnakeCache);
            if (key !== oldKey) {
                obj[key] = obj[oldKey];
                delete obj[oldKey];
            }
        }
    }
    path.pop();
    return obj;
}
function deserializeRecord(key, obj, ctx, fns) {
    const value = obj[key];
    ctx.keys = (typeof value === 'object' && value !== null)
        ? Object.keys(value)
        : [];
    const stop = applySerdesFns(fns, key, obj, ctx);
    if (!stop && ctx.path.length < 250) {
        if (obj[key] === value) {
            deserializeRecordHelper(ctx.keys, value, ctx, fns);
        }
        else {
            deserializeRecordHelper(Object.keys(obj[key]), obj[key], ctx, fns);
        }
    }
    return obj;
}
function deserializeRecordHelper(keys, obj, ctx, fns) {
    const path = ctx.path;
    path.push('<temp>');
    for (let i = keys.length; i--;) {
        let key = keys[i];
        path[path.length - 1] = key;
        if (ctx.camelSnakeCache) {
            const oldKey = key;
            key = (0, utils_1.snakeToCamelCase)(key, ctx.camelSnakeCache);
            if (key !== oldKey) {
                obj[key] = obj[oldKey];
                delete obj[oldKey];
                path[path.length - 1] = key;
            }
        }
        deserializeRecord(key, obj, ctx, fns);
    }
    path.pop();
}
function applySerdesFns(fns, key, obj, ctx) {
    let stop;
    for (let f = 0; f < fns.length && !stop; f++) {
        const res = fns[f](key, obj[key], ctx);
        stop = res?.[0] === ctx_1.DONE;
        if (res.length === 2) {
            obj[key] = res[1];
        }
    }
    return !!stop;
}
