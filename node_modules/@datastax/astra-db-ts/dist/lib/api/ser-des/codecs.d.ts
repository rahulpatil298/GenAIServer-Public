import { SerDesFn } from '../../../lib';
import { BaseSerCtx } from '../../../lib/api/ser-des/ctx';
/**
 * @public
 */
export type NameCodec<Fns extends CodecSerDesFns> = {
    serialize?: Fns['serialize'];
    deserialize: Fns['deserialize'];
} & {
    codecType: 'name';
    name: string;
};
/**
 * @public
 */
export type PathCodec<Fns extends CodecSerDesFns> = {
    serialize?: Fns['serialize'];
    deserialize: Fns['deserialize'];
} & {
    codecType: 'path';
    path: string[];
};
/**
 * @public
 */
export type TypeCodec<Fns extends CodecSerDesFns> = Pick<Fns, 'deserialize'> & {
    codecType: 'type';
    type: string;
};
/**
 * @public
 */
export type CustomGuardCodec<Fns extends CodecSerDesFns> = Fns & {
    codecType: 'type';
    type: string;
    serializeGuard: (value: unknown, ctx: BaseSerCtx<Fns>) => boolean;
};
/**
 * @public
 */
export type ClassGuardCodec<Fns extends CodecSerDesFns> = Fns & {
    codecType: 'type';
    type: string;
    serializeClass: new (...args: any[]) => any;
};
/**
 * @public
 */
export interface Codecs<Fns extends CodecSerDesFns> {
    name: Record<string, NameCodec<Fns>>;
    path: PathCodec<Fns>[];
    type: Record<string, TypeCodec<Fns>>;
    classGuard: ClassGuardCodec<Fns>[];
    customGuard: CustomGuardCodec<Fns>[];
}
/**
 * @public
 */
export type CodecSerDesFns = Record<'serialize' | 'deserialize', (...args: any[]) => ReturnType<SerDesFn<any>>>;
/**
 * @public
 */
export interface CodecHolder<Fns extends CodecSerDesFns> {
    get: NameCodec<Fns> | PathCodec<Fns> | TypeCodec<Fns> | CustomGuardCodec<Fns> | ClassGuardCodec<Fns>;
}
/**
 * @internal
 */
export declare const initCodecs: <Fns extends CodecSerDesFns>(chs: CodecHolder<Fns>[]) => Codecs<Fns>;
