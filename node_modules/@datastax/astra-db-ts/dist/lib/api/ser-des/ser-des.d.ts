import { SomeDoc } from '../../../documents';
import type { nullish, OneOrMany, RawDataAPIResponse } from '../../../lib';
import { CodecHolder, Codecs, CodecSerDesFns } from '../../../lib/api/ser-des/codecs';
import { BaseDesCtx, BaseSerCtx } from '../../../lib/api/ser-des/ctx';
/**
 * @public
 */
export type SerDesFn<Ctx> = (key: string, value: any, ctx: Ctx) => readonly [0 | 1 | 2, any?, string?] | 'Return ctx.done(val?), ctx.recurse(val?), ctx.continue(), or void';
/**
 * @public
 */
export interface BaseSerDesConfig<Codec extends CodecHolder<Fns>, Fns extends CodecSerDesFns, SerCtx extends BaseSerCtx<Fns>, DesCtx extends BaseDesCtx<Fns>> {
    serialize?: OneOrMany<SerDesFn<SerCtx>>;
    deserialize?: OneOrMany<SerDesFn<DesCtx>>;
    mutateInPlace?: boolean;
    snakeCaseInterop?: boolean;
    codecs?: Codec[];
}
/**
 * @internal
 */
export declare abstract class SerDes<Fns extends CodecSerDesFns = any, SerCtx extends BaseSerCtx<Fns> = any, DesCtx extends BaseDesCtx<Fns> = any> {
    protected readonly _cfg: BaseSerDesConfig<any, Fns, SerCtx, DesCtx>;
    protected readonly _codecs: Codecs<Fns>;
    protected readonly _customState: Record<string, any>;
    protected readonly _camelSnakeCache?: Record<string, any>;
    protected constructor(_cfg: BaseSerDesConfig<any, Fns, SerCtx, DesCtx>);
    serializeRecord<S extends SomeDoc | nullish>(obj: S): [S, boolean];
    deserializeRecord<S extends SomeDoc | nullish>(obj: SomeDoc | nullish, raw: RawDataAPIResponse, parsingId?: boolean): S;
    protected abstract adaptSerCtx(ctx: BaseSerCtx<Fns>): SerCtx;
    protected abstract adaptDesCtx(ctx: BaseDesCtx<Fns>): DesCtx;
    protected abstract bigNumsPresent(ctx: SerCtx): boolean;
    protected static _mergeConfig<Codec extends CodecHolder<Fns>, Fns extends CodecSerDesFns, SerCtx extends BaseSerCtx<Fns>, DesCtx extends BaseDesCtx<Fns>>(...cfg: (BaseSerDesConfig<Codec, Fns, SerCtx, DesCtx> | undefined)[]): BaseSerDesConfig<Codec, Fns, SerCtx, DesCtx>;
    private _mkCtx;
}
