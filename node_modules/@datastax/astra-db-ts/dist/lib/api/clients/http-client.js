"use strict";
// Copyright Datastax, Inc
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpClient = void 0;
exports.buildUserAgent = buildUserAgent;
const constants_1 = require("../../../lib/api/constants");
const logger_1 = require("../../../lib/logging/logger");
const timeouts_1 = require("../../../lib/api/timeouts");
class HttpClient {
    constructor(options, headerProviders, mkTimeoutError) {
        Object.defineProperty(this, "baseUrl", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "emitter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "logger", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "fetchCtx", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "baseHeaders", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "headerProviders", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "tm", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.baseUrl = options.baseUrl;
        this.emitter = options.emitter;
        this.logger = new logger_1.Logger(options.logging, options.emitter, console);
        this.fetchCtx = options.fetchCtx;
        if (options.baseApiPath) {
            this.baseUrl += '/' + options.baseApiPath;
        }
        this.baseHeaders = { ...options.additionalHeaders };
        this.baseHeaders['User-Agent'] = options.userAgent;
        this.baseHeaders['Content-Type'] = 'application/json';
        this.baseHeaders['Feature-Flag-tables'] = 'true';
        this.headerProviders = headerProviders;
        this.tm = new timeouts_1.Timeouts(mkTimeoutError, options.timeoutDefaults);
    }
    async _request(info) {
        if (this.fetchCtx.closed.ref) {
            throw new Error('Can\'t make requests on a closed client');
        }
        const [msRemaining, mkTimeoutError] = info.timeoutManager.advance(info);
        if (msRemaining <= 0) {
            throw mkTimeoutError();
        }
        const params = info.params ?? {};
        const url = (Object.keys(params).length > 0)
            ? `${info.url}?${new URLSearchParams(params).toString()}`
            : info.url;
        const reqHeaders = { ...this.baseHeaders };
        for (const provider of this.headerProviders) {
            const maybePromise = provider();
            const newHeaders = ('then' in maybePromise)
                ? await maybePromise
                : maybePromise;
            Object.assign(reqHeaders, newHeaders);
        }
        return await this.fetchCtx.ctx.fetch({
            url: url,
            body: info.data,
            method: info.method,
            headers: reqHeaders,
            forceHttp1: info.forceHttp1,
            timeout: msRemaining,
            mkTimeoutError,
        });
    }
}
exports.HttpClient = HttpClient;
function buildUserAgent(caller) {
    const callers = ((!caller)
        ? [] :
        Array.isArray(caller[0])
            ? caller
            : [caller]);
    const callerString = callers.map((c) => {
        return c[1] ? `${c[0]}/${c[1]}` : c[0];
    }).join(' ');
    return `${callerString} ${constants_1.CLIENT_USER_AGENT}`.trim();
}
