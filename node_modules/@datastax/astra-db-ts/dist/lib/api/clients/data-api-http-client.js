"use strict";
// Copyright Datastax, Inc
// SPDX-License-Identifier: Apache-2.0
// noinspection ExceptionCaughtLocallyJS
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _DataAPIHttpClient_props;
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataAPIHttpClient = exports.EmissionStrategy = void 0;
const logger_1 = require("../../../lib/logging/logger");
const lib_1 = require("../../../lib");
const documents_1 = require("../../../documents");
const http_client_1 = require("../../../lib/api/clients/http-client");
const constants_1 = require("../../../lib/api/constants");
const utils_1 = require("../../../lib/utils");
const errors_1 = require("../../../documents/errors");
const timeouts_1 = require("../../../lib/api/timeouts");
exports.EmissionStrategy = {
    Normal: (logger) => ({
        emitCommandStarted: logger.commandStarted,
        emitCommandFailed: logger.commandFailed,
        emitCommandSucceeded: logger.commandSucceeded,
        emitCommandWarnings: logger.commandWarnings,
    }),
    Admin: (logger) => ({
        emitCommandStarted(info, opts) {
            logger.adminCommandStarted?.(adaptInfo4Devops(info, opts.methodName), true, null); // TODO
        },
        emitCommandFailed(info, error, started, opts) {
            logger.adminCommandFailed?.(adaptInfo4Devops(info, opts.methodName), true, error, started);
        },
        emitCommandSucceeded(info, resp, started, opts) {
            logger.adminCommandSucceeded?.(adaptInfo4Devops(info, opts.methodName), true, resp, started);
        },
        emitCommandWarnings(info, warnings, opts) {
            logger.adminCommandWarnings?.(adaptInfo4Devops(info, opts.methodName), true, warnings);
        },
    }),
};
const adaptInfo4Devops = (info, methodName) => ({
    method: 'POST',
    data: info.command,
    path: info.url,
    methodName,
});
class DataAPIHttpClient extends http_client_1.HttpClient {
    constructor(props) {
        super(props, [mkAuthHeaderProvider(props.tokenProvider), () => props.embeddingHeaders.getHeaders()], documents_1.DataAPITimeoutError.mk);
        Object.defineProperty(this, "collection", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "keyspace", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "emissionStrategy", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "bigNumHack", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        _DataAPIHttpClient_props.set(this, void 0);
        this.keyspace = props.keyspace;
        __classPrivateFieldSet(this, _DataAPIHttpClient_props, props, "f");
        this.emissionStrategy = props.emissionStrategy(this.logger);
    }
    forTableSlashCollectionOrWhateverWeWouldCallTheUnionOfTheseTypes(keyspace, collection, opts, bigNumHack) {
        const clone = new DataAPIHttpClient({
            ...__classPrivateFieldGet(this, _DataAPIHttpClient_props, "f"),
            embeddingHeaders: documents_1.EmbeddingHeadersProvider.parseHeaders(opts?.embeddingApiKey),
            logging: logger_1.Logger.advanceConfig(__classPrivateFieldGet(this, _DataAPIHttpClient_props, "f").logging, opts?.logging),
            emissionStrategy: exports.EmissionStrategy.Normal,
            keyspace: { ref: keyspace },
        });
        clone.collection = collection;
        clone.bigNumHack = bigNumHack;
        clone.tm = new timeouts_1.Timeouts(documents_1.DataAPITimeoutError.mk, { ...this.tm.baseTimeouts, ...opts?.timeoutDefaults });
        return clone;
    }
    forDbAdmin(opts) {
        const clone = new DataAPIHttpClient({
            ...__classPrivateFieldGet(this, _DataAPIHttpClient_props, "f"),
            tokenProvider: lib_1.TokenProvider.mergeTokens(opts?.adminToken, __classPrivateFieldGet(this, _DataAPIHttpClient_props, "f").tokenProvider),
            logging: logger_1.Logger.advanceConfig(__classPrivateFieldGet(this, _DataAPIHttpClient_props, "f").logging, opts?.logging),
            baseUrl: opts?.endpointUrl ?? __classPrivateFieldGet(this, _DataAPIHttpClient_props, "f").baseUrl,
            baseApiPath: opts?.endpointUrl ? '' : __classPrivateFieldGet(this, _DataAPIHttpClient_props, "f").baseApiPath,
            additionalHeaders: { ...__classPrivateFieldGet(this, _DataAPIHttpClient_props, "f").additionalHeaders, ...opts?.additionalHeaders },
            emissionStrategy: exports.EmissionStrategy.Admin,
        });
        clone.collection = undefined;
        clone.tm = new timeouts_1.Timeouts(documents_1.DataAPITimeoutError.mk, { ...this.tm.baseTimeouts, ...opts?.timeoutDefaults });
        return clone;
    }
    async executeCommand(command, options) {
        let started = 0;
        const info = {
            url: this.baseUrl,
            collection: options.collection,
            keyspace: options.keyspace,
            command: command,
            timeoutManager: options.timeoutManager,
            bigNumsPresent: options.bigNumsPresent,
        };
        try {
            info.collection || (info.collection = this.collection);
            if (info.keyspace !== null) {
                info.keyspace || (info.keyspace = this.keyspace?.ref);
                if ((0, utils_1.isNullish)(info.keyspace)) {
                    throw new Error('Db is missing a required keyspace; be sure to set one w/ client.db(..., { keyspace }), or db.useKeyspace()');
                }
            }
            const keyspacePath = info.keyspace ? `/${info.keyspace}` : '';
            const collectionPath = info.collection ? `/${info.collection}` : '';
            info.url += keyspacePath + collectionPath;
            started = performance.now();
            this.emissionStrategy.emitCommandStarted?.(info, options);
            const serialized = (info.bigNumsPresent)
                ? this.bigNumHack?.parser.stringify(info.command)
                : JSON.stringify(info.command);
            const resp = await this._request({
                url: info.url,
                data: serialized,
                timeoutManager: info.timeoutManager,
                method: constants_1.HttpMethods.Post,
            });
            if (resp.status >= 400 && resp.status !== 401) {
                throw new documents_1.DataAPIHttpError(resp);
            }
            const data = (resp.body)
                ? (this.bigNumHack?.parseWithBigNumbers(resp.body))
                    ? this.bigNumHack?.parser.parse(resp.body)
                    : JSON.parse(resp.body)
                : {};
            const warnings = data?.status?.warnings ?? [];
            if (warnings.length) {
                this.emissionStrategy.emitCommandWarnings?.(info, warnings, options);
            }
            delete data?.status?.warnings;
            if (data.errors && data.errors.length > 0) {
                throw (0, errors_1.mkRespErrorFromResponse)(documents_1.DataAPIResponseError, info.command, data, warnings);
            }
            const respData = {
                data: data.data,
                status: data.status,
                errors: data.errors,
            };
            this.emissionStrategy.emitCommandSucceeded?.(info, respData, started, options);
            return respData;
        }
        catch (e) {
            this.emissionStrategy.emitCommandFailed?.(info, e, started, options);
            throw e;
        }
    }
}
exports.DataAPIHttpClient = DataAPIHttpClient;
_DataAPIHttpClient_props = new WeakMap();
const mkAuthHeaderProvider = (tp) => (tp)
    ? () => {
        const token = tp.getToken();
        return (token instanceof Promise)
            ? token.then(mkAuthHeader)
            : mkAuthHeader(token);
    } : () => ({});
const mkAuthHeader = (token) => (token)
    ? { [constants_1.DEFAULT_DATA_API_AUTH_HEADER]: token }
    : {};
