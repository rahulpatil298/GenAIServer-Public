/**
 * @internal
 */
export type Equal<X, Y> = (<T>() => T extends X ? 1 : 2) extends (<T>() => T extends Y ? 1 : 2) ? true : false;
/**
 * @internal
 */
export declare const EqualityProof: <X, Y, _ extends Equal<X, Y>>() => void;
/**
 * @internal
 */
export type Parser<A, R = A> = (input: R, field: string) => A;
/**
 * @internal
 */
export declare const isNonEmpty: <A>(xs: A[]) => xs is [A, ...A[]];
type TypeOfAble = `${'string' | 'number' | 'boolean' | 'object' | 'function'}${'!' | '?'}`;
type TypeOf<Str extends string> = (Str extends `${infer T}${'!' | '?'}` ? LitTypeOf<T> : never);
type LitTypeOf<T extends string> = T extends 'string' ? string : T extends 'object' ? Record<string, unknown> : T extends 'number' ? number : T extends 'boolean' ? boolean : T extends 'function' ? (...args: any[]) => any : never;
type ParseRes<T extends string, X> = T extends `${string}?` ? X | undefined : X;
/**
 * @internal
 */
export declare const p: {
    includes<X>(xs: readonly X[], x: unknown): x is X;
    mkStrEnumParser: <X, const R extends boolean>(name: string, xs: readonly X[], required: R) => (x: unknown, field: string) => X | (R extends false ? undefined : never);
    parse: <U extends TypeOfAble, X = TypeOf<U>>(expected: U, parser?: Parser<X, TypeOf<U>>) => <Cast = ParseRes<U, X>>(x: unknown, field: string) => Cast;
};
export {};
