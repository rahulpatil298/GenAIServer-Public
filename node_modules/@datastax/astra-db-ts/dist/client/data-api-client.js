"use strict";
// Copyright Datastax, Inc
// SPDX-License-Identifier: Apache-2.0
// noinspection JSDeprecatedSymbols
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _DataAPIClient_options, _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataAPIClient = exports.DataAPIClientEventEmitterBase = void 0;
const version_1 = require("../version");
const lib_1 = require("../lib");
const http_client_1 = require("../lib/api/clients/http-client");
const db_1 = require("../db");
const administration_1 = require("../administration");
const utils_1 = require("../lib/utils");
const validation_1 = require("../lib/validation");
const caller_1 = require("../client/parsers/caller");
const logger_1 = require("../lib/logging/logger");
const environment_1 = require("../client/parsers/environment");
const http_opts_1 = require("../client/parsers/http-opts");
const spawn_admin_1 = require("../client/parsers/spawn-admin");
const spawn_db_1 = require("../client/parsers/spawn-db");
const constants_1 = require("../lib/constants");
const timeouts_1 = require("../lib/api/timeouts");
exports.DataAPIClientEventEmitterBase = (() => {
    try {
        return require('events').EventEmitter;
    }
    catch (_) {
        throw new Error(`\`${version_1.LIB_NAME}\` requires the \`events\` module to be available for usage. Please provide a polyfill (e.g. the \`events\` package) or use a compatible environment.`);
    }
})();
class DataAPIClient extends exports.DataAPIClientEventEmitterBase {
    constructor(tokenOrOptions, maybeOptions) {
        super();
        _DataAPIClient_options.set(this, void 0);
                Object.defineProperty(this, _a, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        const tokenPassed = (typeof tokenOrOptions === 'string' || tokenOrOptions instanceof lib_1.TokenProvider || arguments.length > 1);
        const token = (tokenPassed)
            ? tokenOrOptions
            : undefined;
        const rawOptions = (tokenPassed)
            ? maybeOptions
            : tokenOrOptions;
        const options = parseClientOpts(rawOptions, 'options.');
        const logging = logger_1.Logger.advanceConfig(undefined, options?.logging);
        __classPrivateFieldSet(this, _DataAPIClient_options, {
            environment: options?.environment ?? 'astra',
            fetchCtx: buildFetchCtx(options || undefined),
            dbOptions: {
                ...options?.dbOptions,
                token: lib_1.TokenProvider.mergeTokens(options?.dbOptions?.token, token),
                timeoutDefaults: timeouts_1.Timeouts.merge(timeouts_1.Timeouts.Default, options?.timeoutDefaults),
                logging,
            },
            adminOptions: {
                ...options?.adminOptions,
                adminToken: lib_1.TokenProvider.mergeTokens(options?.adminOptions?.adminToken, token),
                timeoutDefaults: timeouts_1.Timeouts.merge(timeouts_1.Timeouts.Default, options?.timeoutDefaults),
                logging,
            },
            emitter: this,
            userAgent: (0, http_client_1.buildUserAgent)(options?.caller),
        }, "f");
        if (Symbol.asyncDispose) {
            this[Symbol.asyncDispose] = () => this.close();
        }
        Object.defineProperty(this, constants_1.$CustomInspect, {
            value: () => `DataAPIClient(env="${__classPrivateFieldGet(this, _DataAPIClient_options, "f").environment}")`,
        });
    }
        db(endpoint, options) {
        return new db_1.Db(__classPrivateFieldGet(this, _DataAPIClient_options, "f"), endpoint, options);
    }
        admin(options) {
        if (__classPrivateFieldGet(this, _DataAPIClient_options, "f").environment !== 'astra') {
            throw new db_1.InvalidEnvironmentError('admin', __classPrivateFieldGet(this, _DataAPIClient_options, "f").environment, ['astra'], 'AstraAdmin is only available for Astra databases');
        }
        return new administration_1.AstraAdmin(__classPrivateFieldGet(this, _DataAPIClient_options, "f"), options);
    }
        async close() {
        await __classPrivateFieldGet(this, _DataAPIClient_options, "f").fetchCtx.ctx.close?.();
        __classPrivateFieldGet(this, _DataAPIClient_options, "f").fetchCtx.closed.ref = true;
    }
}
exports.DataAPIClient = DataAPIClient;
_DataAPIClient_options = new WeakMap(), _a = Symbol.asyncDispose;
const buildFetchCtx = (options) => {
    const clientType = (options?.httpOptions)
        ? options.httpOptions?.client ?? 'default'
        : undefined;
    const ctx = (clientType === 'fetch')
        ? new lib_1.FetchNative() :
        (clientType === 'custom')
            ? options.httpOptions.fetcher
            : tryLoadFetchH2(clientType, options);
    return {
        ctx: ctx,
        closed: { ref: false },
    };
};
const tryLoadFetchH2 = (clientType, options) => {
    try {
        const httpOptions = options?.httpOptions;
        const preferHttp2 = httpOptions?.preferHttp2 ?? true;
        return new lib_1.FetchH2(httpOptions, preferHttp2);
    }
    catch (e) {
        if ((0, utils_1.isNullish)(clientType)) {
            return new lib_1.FetchNative();
        }
        else {
            throw e;
        }
    }
};
const parseClientOpts = (raw, field) => {
    const opts = validation_1.p.parse('object?')(raw, field);
    if (!opts) {
        return undefined;
    }
    return {
        logging: logger_1.Logger.parseConfig(opts.logging, `${field}.logging`),
        environment: (0, environment_1.parseEnvironment)(opts.environment, `${field}.environment`),
        dbOptions: (0, spawn_db_1.parseDbSpawnOpts)(opts.dbOptions, `${field}.dbOptions`),
        adminOptions: (0, spawn_admin_1.parseAdminSpawnOpts)(opts.adminOptions, `${field}.adminOptions`),
        caller: (0, caller_1.parseCaller)(opts.caller, `${field}.caller`),
        httpOptions: (0, http_opts_1.parseHttpOpts)(opts.httpOptions, `${field}.httpOptions`),
        timeoutDefaults: timeouts_1.Timeouts.parseConfig(opts.timeoutDefaults, `${field}.timeoutDefaults`),
    };
};
