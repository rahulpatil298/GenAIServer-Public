"use strict";
// Copyright Datastax, Inc
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseCaller = void 0;
const utils_1 = require("../../lib/utils");
const parseCaller = (caller, field) => {
    if ((0, utils_1.isNullish)(caller)) {
        return undefined;
    }
    if (!Array.isArray(caller)) {
        throw new TypeError(`Expected ${field}.caller to be an array, or undefined/null`);
    }
    const isCallerArr = Array.isArray(caller[0]);
    const callers = (isCallerArr)
        ? caller
        : [caller];
    const mkIdxMsg = (isCallerArr)
        ? (i) => `[${i}]`
        : () => '';
    return callers.map((c, i) => {
        if (!Array.isArray(c)) {
            throw new TypeError(`Expected ${field}.caller${mkIdxMsg(i)} to be a tuple [name: string, version?: string]`);
        }
        if (c.length < 1 || 2 < c.length) {
            throw new TypeError(`Expected ${field}.caller${mkIdxMsg(i)} to be of format [name: string, version?: string]`);
        }
        const [name, version] = c;
        if (typeof name !== 'string') {
            throw new Error(`Expected ${field}.caller${mkIdxMsg(i)}[0] to be a string name (got ${typeof name})`);
        }
        if ((0, utils_1.isNullish)(version) || typeof version !== 'string') {
            throw new Error(`Expected ${field}.caller${mkIdxMsg(i)}[1] to be a string (or undefined) version (got ${typeof version})`);
        }
        return [name, version || undefined];
    });
};
exports.parseCaller = parseCaller;
