// Copyright DataStax, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import BigNumber from 'bignumber.js';
import type TypedEmitter from 'typed-emitter';
import type TypedEventEmitter from 'typed-emitter';

/**
 * @public
 */
export declare const $DeserializeForCollection: unique symbol;

/**
 * @public
 */
export declare const $DeserializeForTable: unique symbol;

declare const $ERROR: unique symbol;

/**
 * @public
 */
export declare const $SerializeForCollection: unique symbol;

/**
 * @public
 */
export declare const $SerializeForTable: unique symbol;

/**
 * An operation to add columns to the table.
 *
 * @public
 */
export declare interface AddColumnOperation {
    /**
     * The columns to add to the table, of the same format as in `createTable`
     */
    columns: CreateTableColumnDefinitions;
}

/**
 * An operation to enable vectorize (auto-embedding-generation) on existing vector columns on the table.
 *
 * @public
 */
export declare interface AddVectorizeOperation<Schema extends SomeRow> {
    /**
     * The options for vectorize-ing each column.
     */
    columns: Partial<Record<keyof Schema, VectorizeServiceOptions>>;
}

/**
 * Common base class for all admin command events.
 *
 * @public
 */
export declare abstract class AdminCommandEvent extends DataAPIClientEvent {
    /**
     * The path for the request, not including the Base URL.
     */
    readonly path: string;
    /**
     * The HTTP method for the request.
     */
    readonly method: 'GET' | 'POST' | 'DELETE';
    /**
     * The request body, if any.
     */
    readonly reqBody?: Record<string, any>;
    /**
     * The query parameters, if any.
     */
    readonly params?: Record<string, any>;
    /**
     * Whether the command is long-running or not, i.e. requires polling.
     */
    readonly longRunning: boolean;
    /**
     * The method which invoked the request
     */
    readonly methodName: string;
    /* Excluded from this release type: __constructor */
    /* Excluded from this release type: _desc */
}

/**
 * The events emitted by the {@link DataAPIClient}. These events are emitted at various stages of the
 * admin command's lifecycle. Intended for use for monitoring and logging purposes.
 *
 * @public
 */
export declare type AdminCommandEventMap = {
    /**
     * Emitted when an admin command is started, before the initial HTTP request is made.
     */
    adminCommandStarted: (event: AdminCommandStartedEvent) => void;
    /**
     * Emitted when a command is polling in a long-running operation (i.e. create database).
     */
    adminCommandPolling: (event: AdminCommandPollingEvent) => void;
    /**
     * Emitted when an admin command has succeeded, after any necessary polling.
     */
    adminCommandSucceeded: (event: AdminCommandSucceededEvent) => void;
    /**
     * Emitted when an admin command has errored.
     */
    adminCommandFailed: (event: AdminCommandFailedEvent) => void;
    /**
     * Emitted when an admin command has warnings.
     */
    adminCommandWarnings: (event: AdminCommandWarningsEvent) => void;
};

/**
 * Event emitted when an admin command has errored.
 *
 * See {@link AdminCommandEvent} for more information about all the common properties available on this event.
 *
 * @public
 */
export declare class AdminCommandFailedEvent extends AdminCommandEvent {
    /**
     * The duration of the command, in milliseconds.
     */
    readonly duration: number;
    /**
     * The error that occurred.
     *
     * Typically, some {@link DevOpsAPIError}, commonly a {@link DevOpsAPIResponseError} or sometimes a
     * {@link DevOpsUnexpectedStateError}
     */
    readonly error: Error;
    /* Excluded from this release type: __constructor */
    /**
     * Formats the warnings into a human-readable string.
     */
    formatted(): string;
}

/**
 * Event emitted when a command is polling in a long-running operation (i.e. create database).
 *
 * Emits every time the command polls.
 *
 * See {@link AdminCommandEvent} for more information about all the common properties available on this event.
 *
 * @public
 */
export declare class AdminCommandPollingEvent extends AdminCommandEvent {
    /**
     * The elapsed time since the command was started, in milliseconds.
     */
    readonly elapsed: number;
    /**
     * The polling interval, in milliseconds.
     */
    readonly interval: number;
    /**
     * The number of times polled so far
     */
    readonly pollCount: number;
    /* Excluded from this release type: __constructor */
    /**
     * Formats the warnings into a human-readable string.
     */
    formatted(): string;
}

/**
 * Event emitted when an admin command is started. This is emitted before the initial HTTP request is made.
 *
 * See {@link AdminCommandEvent} for more information about all the common properties available on this event.
 *
 * @public
 */
export declare class AdminCommandStartedEvent extends AdminCommandEvent {
    /**
     * The timeout for the request, in milliseconds.
     */
    readonly timeout: Partial<TimeoutDescriptor>;
    /* Excluded from this release type: __constructor */
    /**
     * Formats the warnings into a human-readable string.
     */
    formatted(): string;
}

/**
 * Event emitted when an admin command has succeeded, after any necessary polling.
 *
 * See {@link AdminCommandEvent} for more information about all the common properties available on this event.
 *
 * @public
 */
export declare class AdminCommandSucceededEvent extends AdminCommandEvent {
    /**
     * The duration of the command, in milliseconds.
     */
    readonly duration: number;
    /**
     * The response body of the command, if any.
     */
    readonly resBody?: Record<string, any>;
    /* Excluded from this release type: __constructor */
    /**
     * Formats the warnings into a human-readable string.
     */
    formatted(): string;
}

/**
 * Event emitted when the Data API returned a warning for an admin command.
 *
 * See {@link AdminCommandEvent} for more information about all the common properties available on this event.
 *
 * @public
 */
export declare class AdminCommandWarningsEvent extends AdminCommandEvent {
    /**
     * The warnings that occurred.
     */
    readonly warnings: DataAPIErrorDescriptor[];
    /* Excluded from this release type: __constructor */
    /**
     * Formats the warnings into a human-readable string.
     */
    formatted(): string;
}

/**
 * The options available spawning a new {@link AstraAdmin} instance.
 *
 * **Note that this is only available when using Astra as the underlying database.**
 *
 * If any of these options are not provided, the client will use the default options provided by the {@link DataAPIClient}.
 *
 * @public
 */
export declare interface AdminOptions {
    /**
     * The configuration for logging events emitted by the {@link DataAPIClient}.
     *
     * This can be set at any level of the major class hierarchy, and will be inherited by all child classes.
     *
     * See {@link DataAPILoggingConfig} for *much* more information on configuration, outputs, and inheritance.
     */
    logging?: DataAPILoggingConfig;
    /**
     * The access token for the DevOps API, typically of the format `'AstraCS:...'`.
     *
     * If never provided, this will default to the token provided when creating the {@link DataAPIClient}.
     *
     * May be useful for if you want to use a stronger token for the DevOps API than the Data API.
     *
     * @example
     * ```typescript
     * const client = new DataAPIClient('weak-token');
     *
     * // Using 'weak-token' as the token
     * const db = client.db();
     *
     * // Using 'strong-token' instead of 'weak-token'
     * const admin = client.admin({ adminToken: 'strong-token' });
     * ```
     */
    adminToken?: string | TokenProvider | null;
    /**
     * The base URL for the devops API, which is typically always going to be the following:
     * ```
     * https://api.astra.datastax.com/v2
     * ```
     */
    endpointUrl?: string;
    /**
     * Additional headers to include in the HTTP requests to the DevOps API.
     *
     * @remarks
     * There are more than likely more official/structured ways to set any desired headers, such as through
     * {@link TokenProvider}s or {@link EmbeddingHeadersProvider}s. This is more of a last-resort option, such
     * as for enabling feature-flags or other non-standard headers.
     */
    additionalHeaders?: Record<string, string>;
    /**
     * The Astra environment to use when interacting with the DevOps API.
     *
     * In the case of {@link AstraDbAdmin}, if a database endpoint is provided, and its environment does NOT match
     * this value (if it is set), it will throw an error.
     *
     * In the case of {@link DataAPIDbAdmin}, it will simply ignore this value.
     */
    astraEnv?: 'dev' | 'prod' | 'test';
    /**
     * ##### Overview
     *
     * The default timeout options for any operation on this admin instance.
     *
     * See {@link TimeoutDescriptor} for much more information about timeouts.
     *
     * @example
     * ```ts
     * // The request timeout for all operations is set to 1000ms.
     * const client = new DataAPIClient('...', {
     *   timeoutDefaults: { requestTimeoutMs: 1000 },
     * });
     *
     * // The request timeout for all operations borne from this Db is set to 2000ms.
     * const db = client.db('...', {
     *   timeoutDefaults: { requestTimeoutMs: 2000 },
     * });
     * ```
     *
     * ##### Inheritance
     *
     * The timeout options are inherited by all child classes, and can be overridden at any level, including the individual method level.
     *
     * Individual-method-level overrides can vary in behavior depending on the method; again, see {@link TimeoutDescriptor}.
     *
     * ##### Defaults
     *
     * The default timeout options are as follows:
     * - `requestTimeoutMs`: 10000
     * - `generalMethodTimeoutMs`: 30000
     * - `collectionAdminTimeoutMs`: 60000
     * - `tableAdminTimeoutMs`: 30000
     * - `databaseAdminTimeoutMs`: 600000
     * - `keyspaceAdminTimeoutMs`: 30000
     *
     * @see TimeoutDescriptor
     */
    timeoutDefaults?: Partial<TimeoutDescriptor>;
}

/**
 * The possible alterations that may be performed on the table. Only one out of the four may be used at a time.
 *
 * @public
 */
export declare interface AlterTableOperations<Schema extends SomeRow> {
    add?: AddColumnOperation;
    drop?: DropColumnOperation<Schema>;
    addVectorize?: AddVectorizeOperation<Schema>;
    dropVectorize?: DropVectorizeOperation<Schema>;
}

/**
 * Options for altering a table.
 *
 * @public
 */
export declare interface AlterTableOptions<Schema extends SomeRow> extends WithTimeout<'tableAdminTimeoutMs'> {
    /**
     * The operations to perform on the table. Must pick just one of `add`, `drop`, `addVectorize`, or `dropVectorize`.
     */
    operation: AlterTableOperations<Schema>;
}

/**
 * An administrative class for managing Astra databases, including creating, listing, and deleting databases.
 *
 * **Shouldn't be instantiated directly; use {@link DataAPIClient.admin} to obtain an instance of this class.**
 *
 * To perform admin tasks on a per-database basis, see the {@link AstraDbAdmin} class.
 *
 * @example
 * ```typescript
 * const client = new DataAPIClient('token');
 *
 * // Create an admin instance with the default token
 * const admin1 = client.admin();
 *
 * // Create an admin instance with a custom token
 * const admin2 = client.admin({ adminToken: 'stronger-token' });
 *
 * const dbs = await admin1.listDatabases();
 * console.log(dbs);
 * ```
 *
 * @see DataAPIClient.admin
 * @see AstraDbAdmin
 *
 * @public
 */
export declare class AstraAdmin {
    #private;
    /* Excluded from this release type: __constructor */
    /**
     * Spawns a new {@link Db} instance using a direct endpoint and given options.
     *
     * This endpoint should include the protocol and the hostname, but not the path. It's typically in the form of
     * `https://<db_id>-<region>.apps.astra.datastax.com`, but it can be used with DSE or any other Data-API-compatible
     * endpoint.
     *
     * The given options will override any default options set when creating the {@link DataAPIClient} through
     * a deep merge (i.e. unset properties in the options object will just default to the default options).
     *
     * @example
     * ```typescript
     * const admin = new DataAPIClient('token').admin();
     *
     * const db1 = admin.db('https://<db_id>-<region>.apps.astra.datastax.com');
     *
     * const db2 = admin.db('https://<db_id>-<region>.apps.astra.datastax.com', {
     *   keyspace: 'my-keyspace',
     *   useHttp2: false,
     * });
     * ```
     *
     * @remarks
     * Note that this does not perform any IO or validation on if the endpoint is valid or not. It's up to the user to
     * ensure that the endpoint is correct. If you want to create an actual database, see {@link AstraAdmin.createDatabase}
     * instead.
     *
     * @param endpoint - The direct endpoint to use.
     * @param options - Any options to override the default options set when creating the {@link DataAPIClient}.
     *
     * @returns A new {@link Db} instance.
     */
    db(endpoint: string, options?: DbOptions): Db;
    /**
     * Spawns a new {@link Db} instance using a direct endpoint and given options.
     *
     * This overload is purely for user convenience, but it **only supports using Astra as the underlying database**. For
     * DSE or any other Data-API-compatible endpoint, use the other overload instead.
     *
     * The given options will override any default options set when creating the {@link DataAPIClient} through
     * a deep merge (i.e. unset properties in the options object will just default to the default options).
     *
     * @example
     * ```typescript
     * const admin = new DataAPIClient('token').admin();
     *
     * const db1 = admin.db('a6a1d8d6-31bc-4af8-be57-377566f345bf', 'us-east1');
     *
     * const db2 = admin.db('a6a1d8d6-31bc-4af8-be57-377566f345bf', 'us-east1', {
     *   keyspace: 'my-keyspace',
     *   useHttp2: false,
     * });
     * ```
     *
     * @remarks
     * Note that this does not perform any IO or validation on if the endpoint is valid or not. It's up to the user to
     * ensure that the endpoint is correct. If you want to create an actual database, see {@link AstraAdmin.createDatabase}
     * instead.
     *
     * @param id - The database ID to use.
     * @param region - The region to use.
     * @param options - Any options to override the default options set when creating the {@link DataAPIClient}.
     *
     * @returns A new {@link Db} instance.
     */
    db(id: string, region: string, options?: DbOptions): Db;
    /**
     * Spawns a new {@link AstraDbAdmin} instance for a database using a direct endpoint and given options.
     *
     * This endpoint should include the protocol and the hostname, but not the path. It's typically in the form of
     * `https://<db_id>-<region>.apps.astra.datastax.com`, but it can be used with DSE or any other Data-API-compatible
     * endpoint.
     *
     * The given options are for the underlying implicitly-created {@link Db} instance, not the {@link AstraDbAdmin} instance.
     * The db admin will use the same options as this {@link AstraAdmin} instance.
     *
     * The given options will override any default options set when creating the {@link DataAPIClient} through
     * a deep merge (i.e. unset properties in the options object will just default to the default options).
     *
     * @example
     * ```typescript
     * const admin = new DataAPIClient('token').admin();
     *
     * const dbAdmin1 = admin.dbAdmin('https://<db_id>-<region>...');
     *
     * const dbAdmin2 = admin.dbAdmin('https://<db_id>-<region>...', {
     *   keyspace: 'my-keyspace',
     *   useHttp2: false,
     * });
     * ```
     *
     * @remarks
     * Note that this does not perform any IO or validation on if the endpoint is valid or not. It's up to the user to
     * ensure that the endpoint is correct. If you want to create an actual database, see {@link AstraAdmin.createDatabase}
     * instead.
     *
     * @param endpoint - The direct endpoint to use.
     * @param options - Any options to override the default options set when creating the {@link DataAPIClient}.
     *
     * @returns A new {@link Db} instance.
     */
    dbAdmin(endpoint: string, options?: DbOptions): AstraDbAdmin;
    /**
     * Spawns a new {@link Db} instance using a direct endpoint and given options.
     *
     * This overload is purely for user convenience, but it **only supports using Astra as the underlying database**. For
     * DSE or any other Data-API-compatible endpoint, use the other overload instead.
     *
     * The given options are for the underlying implicitly-created {@link Db} instance, not the {@link AstraDbAdmin} instance.
     * The db admin will use the same options as this {@link AstraAdmin} instance.
     *
     * The given options will override any default options set when creating the {@link DataAPIClient} through
     * a deep merge (i.e. unset properties in the options object will just default to the default options).
     *
     * @example
     * ```typescript
     * const admin = new DataAPIClient('token').admin();
     *
     * const dbAdmin1 = admin.dbAdmin('a6a1d8d6-...-377566f345bf', 'us-east1');
     *
     * const dbAdmin2 = admin.dbAdmin('a6a1d8d6-...-377566f345bf', 'us-east1', {
     *   keyspace: 'my-keyspace',
     *   useHttp2: false,
     * });
     * ```
     *
     * @remarks
     * Note that this does not perform any IO or validation on if the endpoint is valid or not. It's up to the user to
     * ensure that the endpoint is correct. If you want to create an actual database, see {@link AstraAdmin.createDatabase}
     * instead.
     *
     * @param id - The database ID to use.
     * @param region - The region to use.
     * @param options - Any options to override the default options set when creating the {@link DataAPIClient}.
     *
     * @returns A new {@link Db} instance.
     */
    dbAdmin(id: string, region: string, options?: DbOptions): AstraDbAdmin;
    /**
     * Fetches the complete information about the database, such as the database name, IDs, region, status, actions, and
     * other metadata.
     *
     * @example
     * ```typescript
     * const info = await admin.info('<db_id>');
     * console.log(info.info.name, info.creationTime);
     * ```
     *
     * @returns A promise that resolves to the complete database information.
     */
    dbInfo(id: string, options?: WithTimeout<'databaseAdminTimeoutMs'>): Promise<AstraDbAdminInfo>;
    /**
     * Lists all databases in the current org/account, matching the optionally provided filter.
     *
     * Note that this method is paginated, but the page size is high enough that most users won't need to worry about it.
     * However, you can use the `limit` and `skip` options to control the number of results returned and the starting point
     * for the results, as needed.
     *
     * You can also filter by the database status using the `include` option, and by the database provider using the
     * `provider` option.
     *
     * See {@link ListAstraDatabasesOptions} for complete information about the options available for this operation.
     *
     * @example
     * ```typescript
     * const admin = new DataAPIClient('AstraCS:...').admin();
     *
     * const activeDbs = await admin.listDatabases({ include: 'ACTIVE' });
     *
     * for (const db of activeDbs) {
     *   console.log(`Database ${db.name} is active`);
     * }
     * ```
     *
     * @param options - The options to filter the databases by.
     * @returns A list of the complete information for all the databases matching the given filter.
     */
    listDatabases(options?: ListAstraDatabasesOptions): Promise<AstraDbAdminInfo[]>;
    /**
     * Creates a new database with the given configuration.
     *
     * **NB. this is a long-running operation. See {@link AstraAdminBlockingOptions} about such blocking operations.** The
     * default polling interval is 10 seconds. Expect it to take roughly 2 min to complete.
     *
     * Note that **the `name` field is non-unique** and thus creating a database, even with the same options, is **not
     * idempotent**.
     *
     * You may also provide options for the implicit {@link Db} instance that will be created with the database, which
     * will override any default options set when creating the {@link DataAPIClient} through a deep merge (i.e. unset
     * properties in the options object will just default to the default options).
     *
     * See {@link CreateAstraDatabaseOptions} for complete information about the options available for this operation.
     *
     * @example
     * ```typescript
     * const newDbAdmin1 = await admin.createDatabase({
     *   name: 'my_database_1',
     *   cloudProvider: 'GCP',
     *   region: 'us-east1',
     * });
     *
     * // Prints '[]' as there are no collections in the database yet
     * console.log(newDbAdmin1.db().listCollections());
     *
     * const newDbAdmin2 = await admin.createDatabase({
     *   name: 'my_database_2',
     *   cloudProvider: 'GCP',
     *   region: 'us-east1',
     *   keyspace: 'my_keyspace',
     * }, {
     *   blocking: false,
     *   dbOptions: {
     *     useHttp2: false,
     *     token: '<weaker-token>',
     *   },
     * });
     *
     * // Can't do much else as the database is still initializing
     * console.log(newDbAdmin2.db().id);
     * ```
     *
     * @remarks
     * Note that if you choose not to block, the returned {@link AstraDbAdmin} object will not be very useful until the
     * operation completes, which is up to the caller to determine.
     *
     * @param config - The configuration for the new database.
     * @param options - The options for the blocking behavior of the operation.
     *
     * @returns The AstraDbAdmin instance for the newly created database.
     */
    createDatabase(config: AstraDatabaseConfig, options?: CreateAstraDatabaseOptions): Promise<AstraDbAdmin>;
    /**
     * Terminates a database by ID or by a given {@link Db} instance.
     *
     * **NB. this is a long-running operation. See {@link AstraAdminBlockingOptions} about such blocking operations.** The
     * default polling interval is 10 seconds. Expect it to take roughly 6-7 min to complete.
     *
     * The database info will still be accessible by ID, or by using the {@link AstraAdmin.listDatabases} method with the filter
     * set to `'ALL'` or `'TERMINATED'`. However, all of its data will very much be lost.
     *
     * @example
     * ```typescript
     * const db = client.db('https://<db_id>-<region>.apps.astra.datastax.com');
     * await admin.dropDatabase(db);
     *
     * // Or just
     * await admin.dropDatabase('a6a1d8d6-31bc-4af8-be57-377566f345bf');
     * ```
     *
     * @param db - The database to drop, either by ID or by instance.
     * @param options - The options for the blocking behavior of the operation.
     *
     * @returns A promise that resolves when the operation completes.
     *
     * @remarks Use with caution. Wear a harness. Don't say I didn't warn you.
     */
    dropDatabase(db: Db | string, options?: DropAstraDatabaseOptions): Promise<void>;
    get _httpClient(): DevOpsAPIHttpClient;
}

/**
 * The options representing the blocking behavior of many admin operations.
 *
 * Said operations are typically require polling to determine completion. They may or may not be
 * extremely long-running, depending on the operation, but they are not instantaneous.
 *
 * The default behavior is to block until the operation is complete, with a `pollInterval` determined on a
 * method-by-method basis, but able to be overridden.
 *
 * Otherwise, it can be made "non-blocking" by setting `blocking` to `false`, where it's up to the caller
 * to determine when the operation is complete.
 *
 * @example
 * ```typescript
 * // Will block by default until the operation is complete.
 * const dbAdmin1 = await admin.createDatabase({...});
 *
 * // Will not block until the operation is complete.
 * // Still returned an AstraDbAdmin object, but it's not very useful
 * // until the operation completes.
 * const dbAdmin2 = await admin.createDatabase({...}, {
 *   blocking: false,
 * });
 *
 * // Blocks with a custom poll interval (per 5s).
 * const dbAdmin3 = await admin.createDatabase({...}, {
 *   blocking: true,
 *   pollInterval: 5000,
 * });
 * ```
 *
 * @remarks
 * By "blocking", we mean that the operation will not return until the operation is complete, which is
 * determined by polling the operation at a regular interval. "Non-blocking" means that the operation
 * makes the initial request, but then returns immediately, leaving it up to the caller to determine
 * when the operation is complete.
 *
 * If it's chosen not to block, keep in mind that the objects that the operation returns may not be
 * fully usable, or even usable at all, until the operation is complete. createDatabase, for example,
 * returns an AstraDbAdmin object, but there's no initialized database for it to work on until the
 * database is fully created.
 *
 * @field blocking - Whether to block the operation until it is complete.
 * @field pollInterval - The interval at which to poll the operation for completion.
 *
 * @public
 */
export declare type AstraAdminBlockingOptions = AstraPollBlockingOptions | AstraNoBlockingOptions;

/**
 * Represents the common options for creating a keyspace through the `astra-db-ts` client.
 *
 * See {@link AstraAdminBlockingOptions} for more options about blocking behavior.
 *
 * If `updateDbKeyspace` is set to true, the underlying `Db` instance used to create the `DbAdmin` will have its
 * current working keyspace set to the newly created keyspace immediately (even if the keyspace isn't technically
 * yet created).
 *
 * @example
 * ```typescript
 * // If using non-astra, this may be a common idiom:
 * const client = new DataAPIClient({ environment: 'dse' });
 * const db = client.db('<endpoint>', { token: '<token>' });
 *
 * // Will internally call `db.useKeyspace('new_keyspace')`
 * await db.admin().createKeyspace('new_keyspace', {
 *   updateDbKeyspace: true,
 * });
 *
 * // Creates collections in keyspace `new_keyspace` by default now
 * const coll = db.createCollection('my_coll');
 * ```
 *
 * @see DbAdmin.createKeyspace
 *
 * @public
 */
export declare type AstraCreateKeyspaceOptions = AstraAdminBlockingOptions & WithTimeout<'keyspaceAdminTimeoutMs'> & {
    updateDbKeyspace?: boolean;
};

/**
 * Represents the options for creating a database.
 *
 * @field name - Name of the database--user friendly identifier
 * @field cloudProvider - Cloud provider where the database lives
 * @field region - Cloud region where the database is located
 *
 * @public
 */
export declare interface AstraDatabaseConfig {
    /**
     * Name of the database (user-friendly identifier)
     */
    name: string;
    /**
     * Cloud provider where the database lives
     */
    cloudProvider?: AstraDbCloudProvider;
    /**
     * The cloud region where the database is located.
     */
    region: string;
    /**
     * The default keyspace to use for the database.
     */
    keyspace?: string;
}

/**
 * An administrative class for managing Astra databases, including creating, listing, and deleting keyspaces.
 *
 * **Shouldn't be instantiated directly; use {@link Db.admin} or {@link AstraDbAdmin.dbAdmin} to obtain an instance of this class.**
 *
 * To manage databases as a whole, see {@link AstraAdmin}.
 *
 * @example
 * ```typescript
 * const client = new DataAPIClient('*TOKEN*');
 *
 * // Create an admin instance through a Db
 * const db = client.db('*ENDPOINT*');
 * const dbAdmin1 = db.admin();
 * const dbAdmin2 = db.admin({ adminToken: 'stronger-token' });
 *
 * // Create an admin instance through an AstraAdmin
 * const admin = client.admin();
 * const dbAdmin3 = admin.dbAdmin('*ENDPOINT*');
 * const dbAdmin4 = admin.dbAdmin('*DB_ID*', '*REGION*');
 *
 * const keyspaces = await admin1.listKeyspaces();
 * console.log(keyspaces);
 *
 * const dbInfo = await admin1.info();
 * console.log(dbInfo);
 * ```
 *
 * @see Db.admin
 * @see AstraDbAdmin.dbAdmin
 *
 * @public
 */
export declare class AstraDbAdmin extends DbAdmin {
    #private;
    /* Excluded from this release type: __constructor */
    /**
     * Gets the ID of the Astra DB instance this object is managing.
     *
     * @returns The ID of the Astra DB instance.
     */
    get id(): string;
    /**
     * Gets the underlying `Db` object. The options for the db were set when the `AstraDbAdmin` instance, or whatever
     * spawned it, was created.
     *
     * @example
     * ```typescript
     * const dbAdmin = client.admin().dbAdmin('<endpoint>', {
     *   keyspace: 'my-keyspace',
     *   useHttp2: false,
     * });
     *
     * const db = dbAdmin.db();
     * console.log(db.id);
     * ```
     *
     * @returns The underlying `Db` object.
     */
    db(): Db;
    /**
     * Returns detailed information about the availability and usage of the vectorize embedding providers available on the
     * current database (may vary based on cloud provider & region).
     *
     * @example
     * ```typescript
     * const { embeddingProviders } = await dbAdmin.findEmbeddingProviders();
     *
     * // ['text-embedding-3-small', 'text-embedding-3-large', 'text-embedding-ada-002']
     * console.log(embeddingProviders['openai'].models.map(m => m.name));
     * ```
     *
     * @param options - The options for the timeout of the operation.
     *
     * @returns The available embedding providers.
     */
    findEmbeddingProviders(options?: WithTimeout<'databaseAdminTimeoutMs'>): Promise<FindEmbeddingProvidersResult>;
    /**
     * Fetches the complete information about the database, such as the database name, IDs, region, status, actions, and
     * other metadata.
     *
     * The method issues a request to the DevOps API each time it is invoked, without caching mechanisms;
     * this ensures up-to-date information for usages such as real-time collections validation by the application.
     *
     * @example
     * ```typescript
     * const info = await dbAdmin.info();
     * console.log(info.info.name, info.creationTime);
     * ```
     *
     * @returns A promise that resolves to the complete database information.
     */
    info(options?: WithTimeout<'databaseAdminTimeoutMs'>): Promise<AstraDbAdminInfo>;
    /**
     * Lists the keyspaces in the database.
     *
     * The first element in the returned array is the default keyspace of the database, and the rest are additional
     * keyspaces in no particular order.
     *
     * @example
     * ```typescript
     * const keyspaces = await dbAdmin.listKeyspaces();
     *
     * // ['default_keyspace', 'my_other_keyspace']
     * console.log(keyspaces);
     * ```
     *
     * @returns A promise that resolves to list of all the keyspaces in the database.
     */
    listKeyspaces(options?: WithTimeout<'keyspaceAdminTimeoutMs'>): Promise<string[]>;
    /**
     * Creates a new, additional, keyspace for this database.
     *
     * **NB. this is a "long-running" operation. See {@link AstraAdminBlockingOptions} about such blocking operations.** The
     * default polling interval is 1 second. Expect it to take roughly 8-10 seconds to complete.
     *
     * @example
     * ```typescript
     * await dbAdmin.createKeyspace('my_other_keyspace1');
     *
     * // ['default_keyspace', 'my_other_keyspace1']
     * console.log(await dbAdmin.listKeyspaces());
     *
     * await dbAdmin.createKeyspace('my_other_keyspace2', {
     *   blocking: false,
     * });
     *
     * // Will not include 'my_other_keyspace2' until the operation completes
     * console.log(await dbAdmin.listKeyspaces());
     * ```
     *
     * @remarks
     * Note that if you choose not to block, the created keyspace will not be able to be used until the
     * operation completes, which is up to the caller to determine.
     *
     * @param keyspace - The name of the new keyspace.
     * @param options - The options for the blocking behavior of the operation.
     *
     * @returns A promise that resolves when the operation completes.
     */
    createKeyspace(keyspace: string, options?: AstraCreateKeyspaceOptions): Promise<void>;
    /**
     * Drops a keyspace from this database.
     *
     * **NB. this is a "long-running" operation. See {@link AstraAdminBlockingOptions} about such blocking operations.** The
     * default polling interval is 1 second. Expect it to take roughly 8-10 seconds to complete.
     *
     * @example
     * ```typescript
     * await dbAdmin.dropKeyspace('my_other_keyspace1');
     *
     * // ['default_keyspace', 'my_other_keyspace2']
     * console.log(await dbAdmin.listKeyspaces());
     *
     * await dbAdmin.dropKeyspace('my_other_keyspace2', {
     *   blocking: false,
     * });
     *
     * // Will still include 'my_other_keyspace2' until the operation completes
     * // ['default_keyspace', 'my_other_keyspace2']
     * console.log(await dbAdmin.listKeyspaces());
     * ```
     *
     * @remarks
     * Note that if you choose not to block, the keyspace will still be able to be used until the operation
     * completes, which is up to the caller to determine.
     *
     * @param keyspace - The name of the keyspace to drop.
     * @param options - The options for the blocking behavior of the operation.
     *
     * @returns A promise that resolves when the operation completes.
     */
    dropKeyspace(keyspace: string, options?: AstraDropKeyspaceOptions): Promise<void>;
    /**
     * Drops the database.
     *
     * **NB. this is a long-running operation. See {@link AstraAdminBlockingOptions} about such blocking operations.** The
     * default polling interval is 10 seconds. Expect it to take roughly 6-7 min to complete.
     *
     * The database info will still be accessible by ID, or by using the {@link AstraAdmin.listDatabases} method with the filter
     * set to `'ALL'` or `'TERMINATED'`. However, all of its data will very much be lost.
     *
     * @example
     * ```typescript
     * const db = client.db('https://<db_id>-<region>.apps.astra.datastax.com');
     * await db.admin().drop();
     * ```
     *
     * @param options - The options for the blocking behavior of the operation.
     *
     * @returns A promise that resolves when the operation completes.
     *
     * @remarks Use with caution. Use a surge protector. Don't say I didn't warn you.
     */
    drop(options?: AstraDropKeyspaceOptions): Promise<void>;
    get _httpClient(): DevOpsAPIHttpClient;
}

/**
 * The database information returned from {@link AstraDbAdmin.info} & {@link AstraAdmin.dbInfo}.
 *
 * @public
 */
export declare interface AstraDbAdminInfo extends BaseAstraDbInfo {
    /**
     * When the database was created.
     */
    createdAt: Date;
    /**
     * When the database was last used.
     */
    lastUsed: Date;
    /**
     * The regions info for the database.
     */
    regions: AstraDbRegionInfo[];
    /**
     * The organization ID that owns the database.
     */
    orgId: string;
    /**
     * The ID of the owner of the database.
     */
    ownerId: string;
}

/**
 * Represents the available cloud providers that Astra offers.
 *
 * @public
 */
export declare type AstraDbCloudProvider = 'AWS' | 'GCP' | 'AZURE';

/**
 * Represents all possible cloud providers that you can filter by.
 *
 * @public
 */
export declare type AstraDbCloudProviderFilter = AstraDbCloudProvider | 'ALL';

/**
 * The database information returned from {@link Db.info}.
 *
 * @public
 */
export declare interface AstraDbInfo extends BaseAstraDbInfo {
    region: string;
    apiEndpoint: string;
}

/**
 * Information about a region where an Astra database is hosted.
 *
 * @public
 */
export declare interface AstraDbRegionInfo {
    /**
     * The name of the region.
     */
    name: string;
    /**
     * The API endpoint for the region.
     */
    apiEndpoint: string;
    /**
     * When the region was created.
     */
    createdAt: Date;
}

/**
 * Represents all possible statuses of a database.
 *
 * @public
 */
export declare type AstraDbStatus = 'ACTIVE' | 'ERROR' | 'DECOMMISSIONING' | 'DEGRADED' | 'HIBERNATED' | 'HIBERNATING' | 'INITIALIZING' | 'MAINTENANCE' | 'PARKED' | 'PARKING' | 'PENDING' | 'PREPARED' | 'PREPARING' | 'RESIZING' | 'RESUMING' | 'TERMINATED' | 'TERMINATING' | 'UNKNOWN' | 'UNPARKING' | 'SYNCHRONIZING';

/**
 * Represents all possible statuses of a database that you can filter by.
 *
 * @public
 */
export declare type AstraDbStatusFilter = AstraDbStatus | 'ALL' | 'NONTERMINATED';

/**
 * @public
 */
export declare type AstraDropKeyspaceOptions = AstraAdminBlockingOptions & WithTimeout<'keyspaceAdminTimeoutMs'>;

/**
 * The options representing the blocking behavior of many admin operations.
 *
 * @field blocking - False to not block until the operation is complete.
 *
 * @see AstraAdminBlockingOptions
 *
 * @public
 */
export declare interface AstraNoBlockingOptions {
    /**
     * False to not block until the operation is complete.
     */
    blocking: false;
}

/**
 * The options representing the blocking behavior of many admin operations.
 *
 * @field blocking - True or omitted to block until the operation is complete.
 * @field pollInterval - The interval (in MS) at which to poll the operation for completion.
 *
 * @see AstraAdminBlockingOptions
 *
 * @public
 */
export declare interface AstraPollBlockingOptions {
    /**
     * True or omitted to block until the operation is complete.
     */
    blocking?: true;
    /**
     * The interval (in MS) at which to poll the operation for completion.
     *
     * The default is determined on a method-by-method basis.
     */
    pollInterval?: number;
}

/**
 * An embedding headers provider which translates AWS access keys into the appropriate authentication headers for
 * AWS-based embedding providers (bedrock).
 *
 * Sets the headers `x-embedding-access-id` and `x-embedding-secret-id`.
 *
 * @example
 * ```typescript
 * const provider = new AWSEmbeddingHeadersProvider('access-key-id', 'secret-access-key');
 * const collections = await db.collections('my_coll', { embeddingApiKey: provider });
 * ```
 *
 * @see EmbeddingHeadersProvider
 *
 * @public
 */
export declare class AWSEmbeddingHeadersProvider extends EmbeddingHeadersProvider {
    #private;
    /**
     * Constructs an instead of the {@link TokenProvider}.
     *
     * @param accessKeyId - The access key ID part of the AWS access keys
     * @param secretAccessKey - The secret access key part of the AWS access keys
     */
    constructor(accessKeyId: string, secretAccessKey: string);
    /**
     * Returns the appropriate embedding auth headers.
     *
     * @returns the appropriate embedding auth headers.
     */
    getHeaders(): Record<string, string>;
}

/**
 * Represents the base information about a database, which is common in both {@link AstraDbAdminInfo} and {@link AstraDbInfo}.
 *
 * @public
 */
export declare interface BaseAstraDbInfo {
    /**
     * The ID of the database.
     */
    id: string;
    /**
     * The user-given name of the database.
     */
    name: string;
    /**
     * The databases's keyspaces; the list may be empty.
     */
    keyspaces: string[];
    /**
     * The current status of the daatbase.
     */
    status: AstraDbStatus;
    /**
     * The cloud provided where the database is hosted.
     */
    cloudProvider: AstraDbCloudProvider;
    /**
     * The Astra environment in which the database is running.
     */
    environment: 'dev' | 'test' | 'prod';
    /**
     * The raw response from the DevOps API for the database information.
     */
    raw: Record<string, any>;
}

/**
 * @public
 */
export declare interface BaseDesCtx<Fns extends CodecSerDesFns> extends BaseSerDesCtx<Fns> {
    rawDataApiResp: RawDataAPIResponse;
    parsingInsertedId: boolean;
    keys: string[] | null;
}

/**
 * @public
 */
export declare interface BaseSerCtx<Fns extends CodecSerDesFns> extends BaseSerDesCtx<Fns> {
    mutatingInPlace: boolean;
}

/**
 * @public
 */
export declare interface BaseSerDesConfig<Codec extends CodecHolder<Fns>, Fns extends CodecSerDesFns, SerCtx extends BaseSerCtx<Fns>, DesCtx extends BaseDesCtx<Fns>> {
    serialize?: OneOrMany<SerDesFn<SerCtx>>;
    deserialize?: OneOrMany<SerDesFn<DesCtx>>;
    mutateInPlace?: boolean;
    snakeCaseInterop?: boolean;
    codecs?: Codec[];
}

/**
 * @public
 */
export declare interface BaseSerDesCtx<Fns extends CodecSerDesFns> {
    rootObj: SomeDoc;
    path: string[];
    done<T>(obj?: T): readonly [0, T?];
    recurse<T>(obj?: T): readonly [1, T?];
    continue(): readonly [2];
    codecs: Codecs<Fns>;
    customState: Record<string, any>;
    camelSnakeCache?: Record<string, string>;
}

/* Excluded from this release type: BigNumberHack */

/**
 * A shorthand function for `new DataAPIBlob(blob)`
 *
 * @public
 */
export declare const blob: (blob: DataAPIBlobLike) => DataAPIBlob;

/**
 * The caller information to send with requests, of the form `[name, version?]`, or an array of such.
 *
 * **Intended generally for integrations or frameworks that wrap the client.**
 *
 * Used to identify the client making requests to the server.
 *
 * It will be sent in the headers of the request as such:
 * ```
 * User-Agent: ...<name>/<version> astra-db-ts/<version>
 * ```
 *
 * If no caller information is provided, the client will simply be identified as `astra-db-ts/<version>`.
 *
 * **NB. If providing an array of callers, they should be ordered from most important to least important.**
 *
 * @public
 */
export declare type Caller = readonly [name: string, version?: string];

/**
 * @public
 */
export declare type ClassGuardCodec<Fns extends CodecSerDesFns> = Fns & {
    codecType: 'type';
    type: string;
    serializeClass: new (...args: any[]) => any;
};

declare type ClientKind = 'admin' | 'normal';

/**
 * @public
 */
export declare interface CodecHolder<Fns extends CodecSerDesFns> {
    get: NameCodec<Fns> | PathCodec<Fns> | TypeCodec<Fns> | CustomGuardCodec<Fns> | ClassGuardCodec<Fns>;
}

/**
 * @public
 */
export declare interface Codecs<Fns extends CodecSerDesFns> {
    name: Record<string, NameCodec<Fns>>;
    path: PathCodec<Fns>[];
    type: Record<string, TypeCodec<Fns>>;
    classGuard: ClassGuardCodec<Fns>[];
    customGuard: CustomGuardCodec<Fns>[];
}

/**
 * @public
 */
export declare type CodecSerDesFns = Record<'serialize' | 'deserialize', (...args: any[]) => ReturnType<SerDesFn<any>>>;

/**
 * @public
 */
export declare type CollCodec<_Class extends CollCodecClass> = EmptyObj;

/**
 * @public
 */
export declare interface CollCodecClass {
    new (...args: any[]): {
        [$SerializeForCollection]: (ctx: CollSerCtx) => ReturnType<SerDesFn<any>>;
    };
    [$DeserializeForCollection]: CollCodecSerDesFns['deserialize'];
}

/**
 * @public
 */
export declare class CollCodecs implements CodecHolder<CollCodecSerDesFns> {
    /* Excluded from this release type: get */
    /* Excluded from this release type: __constructor */
    static Defaults: {
        $date: CollCodecs;
        $vector: CollCodecs;
        $uuid: CollCodecs;
        $objectId: CollCodecs;
    };
    static Overrides: {
        USE_DATA_API_TIMESTAMPS_OVER_DATES: CollCodecs;
    };
    static forPath(path: string[], clazz: CollCodecClass): CollCodecs;
    static forPath(path: string[], opts: CollCodecSerDesFns): CollCodecs;
    static forName(name: string, clazz: CollCodecClass): CollCodecs;
    static forName(name: string, opts: CollCodecSerDesFns): CollCodecs;
    static forType(type: string, clazz: CollCodecClass): CollCodecs;
    static forType(type: string, opts: CollCodecSerDesFns & {
        serializeGuard: (value: unknown, ctx: TableSerCtx) => boolean;
    }): CollCodecs;
    static forType(type: string, opts: CollCodecSerDesFns & {
        serializeClass: new (...args: any[]) => any;
    }): CollCodecs;
    static forType(type: string, opts: CollCodecSerDesFns & {
        deserializeOnly: true;
    }): CollCodecs;
}

/**
 * @public
 */
export declare interface CollCodecSerDesFns {
    serialize: SerDesFn<CollSerCtx>;
    deserialize: SerDesFn<CollDesCtx>;
}

/**
 * @public
 */
export declare type CollDesCtx = BaseDesCtx<CollCodecSerDesFns>;

/**
 * #### Overview
 *
 * Represents the interface to a collection in a Data-API-enabled database.
 *
 * **This shouldn't be directly instantiated, but rather created via {@link Db.createCollection} or {@link Db.collection}**.
 *
 * #### Typing & Types
 *
 * Collections are inherently untyped, but you can provide your own client-side compile-time schema for type inference
 * and early-bug-catching purposes.
 *
 * A `Collection` is typed as `Collection<Schema extends SomeDoc = SomeDoc>`, where:
 * - `Schema` is the user-intended type of the documents in the collection.
 * - `SomeDoc` is set to `Record<string, any>`, representing any valid JSON object.
 *
 * Certain datatypes may be represented as TypeScript classes (some native, some provided by `astra-db-ts`), however.
 *
 * For example:
 * - `$date` is represented by a native JS `Date`
 * - `$uuid` is represented by a `UUID` class provided by `astra-db-ts`
 * - `$vector` is represented by a `DataAPIVector` class provided by `astra-db-ts`
 *
 * You may also provide your own datatypes by providing some custom serialization logic as well (see later section).
 *
 * @example
 * ```ts
 * interface User {
 *   _id: string,
 *   dob: Date,
 *   friends?: Record<string, UUID>, // UUID is also `astra-db-ts` provided
 *   vector: DataAPIVector,
 * }
 *
 * await db.collection<User>('users').insertOne({
 *   _id: '123',
 *   dob: new Date(),
 *   vector: new DataAPIVector([1, 2, 3]), // This can also be passed as a number[]
 * });
 * ```
 *
 * ###### Typing the `_id`
 *
 * The `_id` field of the document may be any valid JSON scalar (including {@link Date}s, {@link UUID}s, and {@link ObjectId}s)
 *
 * See {@link CollectionDefaultIdOptions} for more info on setting default `_id`s
 *
 * @example
 * ```ts
 * interface User {
 *   _id: UUID,
 *   name: string,
 * }
 *
 * const coll = await db.createCollection<User>('users', {
 *   defaultId: { type: 'uuid' },
 * });
 *
 * const resp = await coll.insertOne({ name: 'Alice' });
 * console.log(resp.insertedId.version) // 4
 * ```
 *
 * ###### Big numbers
 *
 * By default, big numbers (`bigint`s and {@link BigNumber}s from `bignumber.js`) are disabled, and will error when attempted to be serialized, and will lose precision when deserialized.
 *
 * See {@link CollectionSerDesConfig.enableBigNumbers} for more information on enabling big numbers in collections.
 *
 * ###### Custom datatypes
 *
 * You can plug in your own custom datatypes, as well as enable many other features by providing some custom serialization/deserialization logic through the `serdes` option in {@link CollectionOptions}, {@link DbOptions}, and/or {@link DataAPIClientOptions.dbOptions}.
 *
 * Note however that this is currently not entirely stable, and should be used with caution.
 *
 * See the official DataStax documentation for more info.
 *
 * ###### Disclaimer
 *
 * **Collections are inherently untyped**
 *
 * **It is on the user to ensure that the TS type of the `Collection` corresponds with the actual CQL table schema, in its TS-deserialized form. Incorrect or dynamic tying could lead to surprising behaviours and easily-preventable errors.**
 *
 * **There is no runtime type validation or enforcement of the schema.**
 *
 * @see SomeDoc
 * @see Db.createCollection
 * @see Db.collection
 * @see CollectionDefaultIdOptions
 * @see CollectionSerDesConfig
 * @see CollectionOptions
 *
 * @public
 */
export declare class Collection<WSchema extends SomeDoc = SomeDoc, RSchema extends WithId<SomeDoc> = FoundDoc<WSchema>> {
    #private;
    /**
     * The name of the collection. Unique per keyspace.
     */
    readonly name: string;
    /**
     * The keyspace that the collection resides in.
     */
    readonly keyspace: string;
    /* Excluded from this release type: __constructor */
    /**
     * ##### Overview
     *
     * Atomically inserts a single document into the collection.
     *
     * @example
     * ```ts
     * import { UUID, ObjectId, ... } from '@datastax/astra-db-ts';
     *
     * // Insert a document with a specific ID
     * await collection.insertOne({ _id: '1', name: 'John Doe' });
     * await collection.insertOne({ _id: new ObjectID(), name: 'Jane Doe' });
     * await collection.insertOne({ _id: UUID.v7(), name: 'Dane Joe' });
     *
     * // Insert a document with a vector (if enabled on the collection)
     * await collection.insertOne({ _id: 1, name: 'Jane Doe', $vector: [.12, .52, .32] });
     *
     * // or if vectorize (auto-embedding-generation) is enabled
     * await collection.insertOne({ _id: 1, name: 'Jane Doe', $vectorize: "Hey there!" });
     * ```
     *
     * ##### The `_id` field
     *
     * If the document does not contain an `_id` field, the server will generate an id for the document. The type of the id may be specified in {@link CollectionDefinition.defaultId} at collection creation, otherwise it'll just be a raw UUID string. This generation does not mutate the document.
     *
     * If an `_id` is provided which corresponds to a document that already exists in the collection, a {@link DataAPIResponseError} is raised, and the insertion fails.
     *
     * If you prefer to upsert instead, see {@link Collection.replaceOne}.
     *
     * @example
     * ```typescript
     * // Insert a document with an autogenerated ID
     * await collection.insertOne({ name: 'Jane Doe' });
     *
     * // Use the inserted ID (generated or not)
     * const resp = await collection.insertOne({ name: 'Lemmy' });
     * console.log(resp.insertedId);
     *
     * // Or if the collection has a default ID
     * const collection = db.createCollection('users', {
     *   defaultId: { type: 'uuid' },
     * });
     *
     * const resp = await collection.insertOne({ name: 'Lemmy' });
     * console.log(resp.insertedId.version); // 4
     * ```
     *
     * @param document - The document to insert.
     * @param options - The options for this operation.
     *
     * @returns The ID of the inserted document.
     */
    insertOne(document: MaybeId<WSchema>, options?: WithTimeout<'generalMethodTimeoutMs'>): Promise<CollectionInsertOneResult<RSchema>>;
    /**
     * ##### Overview
     *
     * Inserts many documents into the collection.
     *
     * @example
     * ```ts
     * await collection.insertMany([
     *   { _id: '1', name: 'John Doe' },
     *   { name: 'Jane Doe' },
     * ]);
     * ```
     *
     * ##### Chunking
     *
     * **NOTE: This function paginates the insertion of documents in chunks to avoid running into insertion limits.** This means multiple requests may be made to the server.
     *
     * This operation is **not necessarily atomic**. Depending on the amount of inserted documents, and if it's ordered or not, it can keep running (in a blocking manner) for a macroscopic amount of time. In that case, new documents that are inserted from another concurrent process/application may be inserted during the execution of this method call, and if there are duplicate keys, it's not easy to predict which application will win the race.
     *
     * By default, it inserts documents in chunks of 50 at a time. You can fine-tune the parameter through the `chunkSize` option. Note that increasing chunk size won't necessarily increase performance depending on document size. Instead, increasing concurrency may help.
     *
     * You can set the `concurrency` option to control how many network requests are made in parallel on unordered insertions. Defaults to `8`.
     *
     * @example
     * ```ts
     * const docs = Array.from({ length: 100 }, (_, i) => ({ _id: i }));
     * await collection.insertMany(docs, { batchSize: 100 });
     * ```
     *
     * ##### Ordered insertion
     *
     * You may set the `ordered` option to `true` to stop the operation after the first error; otherwise all documents may be parallelized and processed in arbitrary order, improving, perhaps vastly, performance.
     *
     * Setting the `ordered` operation disables any parallelization so insertions truly are stopped after the very first error.
     *
     * @example
     * ```ts
     * // will throw an InsertManyError after the 2nd doc is inserted with a duplicate key
     * // the 3rd doc will never attempt to be inserted
     * await collection.insertMany([
     *   { _id: '1', name: 'John Doe' },
     *   { _id: '1', name: 'John Doe' },
     *   { _id: '2', name: 'Jane Doe' },
     * ], {
     *   ordered: true,
     * });
     * ```
     *
     * ##### The `_id` field
     *
     * If any document does not contain an `_id` field, the server will generate an id for the document. The type of the id may be specified in {@link CollectionDefinition.defaultId} at creation, otherwise it'll just be a UUID string. This generation will not mutate the documents.
     *
     * If any `_id` is provided which corresponds to a document that already exists in the collection, an {@link CollectionInsertManyError} is raised, and the insertion (partially) fails.
     *
     * If you prefer to upsert instead, see {@link Collection.replaceOne}.
     *
     * @example
     * ```typescript
     * // Insert documents with autogenerated IDs
     * await collection.insertMany([
     *   { name: 'John Doe' },
     *   { name: 'Jane Doe' },
     * ]);
     *
     * // Use the inserted IDs (generated or not)
     * const resp = await collection.insertMany([
     *   { name: 'Lemmy' },
     *   { name: 'Kilmister' },
     * ]);
     * console.log(resp.insertedIds);
     *
     * // Or if the collection has a default ID
     * const collection = db.createCollection('users', {
     *   defaultId: { type: 'objectId' },
     * });
     *
     * const resp = await collection.insertMany([
     *   { name: 'Lynyrd' },
     *   { name: 'Skynyrd' },
     * ]);
     *
     * console.log(resp.insertedIds[0].getTimestamp());
     * ```
     *
     * ##### `InsertManyError`
     *
     * If any 2XX insertion error occurs, the operation will throw an {@link CollectionInsertManyError} containing the partial result.
     *
     * If a thrown exception is not due to an insertion error, e.g. a `5xx` error or network error, the operation will throw the underlying error.
     *
     * In case of an unordered request, if the error was a simple insertion error, the {@link CollectionInsertManyError} will be thrown after every document has been attempted to be inserted. If it was a `5xx` or similar, the error will be thrown immediately.
     *
     * @param documents - The documents to insert.
     * @param options - The options for this operation.
     *
     * @returns The IDs of the inserted documents (and the count)
     *
     * @throws CollectionInsertManyError - If the operation fails.
     */
    insertMany(documents: readonly MaybeId<WSchema>[], options?: CollectionInsertManyOptions): Promise<CollectionInsertManyResult<RSchema>>;
    /**
     * ##### Overview
     *
     * Atomically updates a single document in the collection.
     *
     * @example
     * ```ts
     * await collection.insertOne({ _id: '1', name: 'John Doe' });
     * await collection.updateOne({ _id: '1' }, { $set: { name: 'Jane Doe' } });
     * ```
     *
     * ##### Upserting
     *
     * If `upsert` is set to true, it will insert the document reconstructed from the filter & the update filter if no match is found.
     *
     * @example
     * ```ts
     * const resp = await collection.updateOne(
     *   { _id: 42 },
     *   { $set: { age: 27 }, $setOnInsert: { name: 'Kasabian' } },
     *   { upsert: true },
     * );
     *
     * if (resp.upsertedCount) {
     *   console.log(resp.upsertedId); // 42
     * }
     * ```
     *
     * ##### Filtering
     *
     * The filter can contain a variety of operators & combinators to select the document. See {@link CollectionFilter} for much more information.
     *
     * Just keep in mind that if the filter is empty, and no {@link Sort} is present, it's undefined as to which document is selected.
     *
     * ##### Update operators
     *
     * The update filter can contain a variety of operators to modify the document. See {@link CollectionUpdateFilter} for more information & examples.
     *
     * ##### Update by vector search
     *
     * If the collection has vector search enabled, you can update the most relevant document by providing a vector in the sort option.
     *
     * @example
     * ```ts
     * // Update by vector search
     * await collection.insertOne({ name: 'John Doe', $vector: [.12, .52, .32] });
     *
     * await collection.updateOne(
     *   { name: 'John Doe' },
     *   { $set: { name: 'Jane Doe', $vectorize: "Ooh, she's a little runaway" } },
     *   { sort: { $vector: [.09, .58, .21] } },
     * );
     * ```
     *
     * @param filter - A filter to select the document to update.
     * @param update - The update to apply to the selected document.
     * @param options - The options for this operation.
     *
     * @returns A summary of what changed.
     */
    updateOne(filter: CollectionFilter<WSchema>, update: CollectionUpdateFilter<WSchema>, options?: CollectionUpdateOneOptions): Promise<CollectionUpdateOneResult<RSchema>>;
    /**
     * ##### Overview
     *
     * Updates many documents in the collection.
     *
     * ##### Pagination
     *
     * **NOTE: This function paginates the updating of documents in batches due to server update limits.** The limit is set on the server-side, and not changeable via the client side. This means multiple requests may be made to the server.
     *
     * This operation is **not necessarily atomic**. Depending on the amount of matching documents, it can keep running (in a blocking manner) for a macroscopic amount of time. In that case, documents that are modified/inserted from another concurrent process/application may be modified/inserted during the execution of this method call.
     *
     * ##### Upserting
     *
     * If `upsert` is set to true, it will insert the document reconstructed from the filter & the update filter if no match is found.
     *
     * Only one document may be upserted per command.
     *
     * @example
     * ```ts
     * const resp = await collection.updateMany(
     *   { name: 'Kasabian' },
     *   { $set: { age: 27 }, $setOnInsert: { _id: 42 } },
     *   { upsert: true },
     * );
     *
     * if (resp.upsertedCount) {
     *   console.log(resp.upsertedId); // 42
     * }
     * ```
     *
     * ##### Filtering
     *
     * The filter can contain a variety of operators & combinators to select the document. See {@link CollectionFilter} for much more information.
     *
     * Just keep in mind that if the filter is empty, and no {@link Sort} is present, it's undefined as to which document is selected.
     *
     * ##### Update operators
     *
     * The update filter can contain a variety of operators to modify the document. See {@link CollectionUpdateFilter} for more information & examples.
     *
     * {@link Collection.updateOne} also contains some examples of basic update filter usage.
     *
     * ##### Update by vector search
     *
     * If the collection has vector search enabled, you can update the most relevant document by providing a vector in the sort option.
     *
     * @example
     * ```ts
     * // Update by vector search
     * await collection.insertOne({ name: 'John Doe', $vector: [.12, .52, .32] });
     *
     * await collection.updateMany(
     *   { name: 'John Doe' },
     *   { $set: { name: 'Jane Doe', $vectorize: "Ooh, she's a little runaway" } },
     *   { sort: { $vector: [.09, .58, .21] } },
     * );
     * ```
     *
     * @param filter - A filter to select the documents to update.
     * @param update - The update to apply to the selected documents.
     * @param options - The options for this operation.
     *
     * @returns A summary of what changed.
     */
    updateMany(filter: CollectionFilter<WSchema>, update: CollectionUpdateFilter<WSchema>, options?: CollectionUpdateManyOptions): Promise<CollectionUpdateManyResult<RSchema>>;
    /**
     * ##### Overview
     *
     * Replaces a single document in the collection.
     *
     * @example
     * ```typescript
     * await collection.insertOne({ _id: '1', name: 'John Doe' });
     * await collection.replaceOne({ _id: '1' }, { name: 'Dohn Joe' });
     * ```
     *
     * ##### Upserting
     *
     * If `upsert` is set to true, it will insert the document reconstructed from the filter & the update filter if no match is found.
     *
     * @example
     * ```ts
     * const resp = await collection.replaceOne(
     *   { _id: 42 },
     *   { name: 'Jessica' },
     *   { upsert: true },
     * );
     *
     * if (resp.upsertedCount) {
     *   console.log(resp.upsertedId); // 42
     * }
     * ```
     *
     * ##### Filtering
     *
     * The filter can contain a variety of operators & combinators to select the document. See {@link CollectionFilter} for much more information.
     *
     * Just keep in mind that if the filter is empty, and no {@link Sort} is present, it's undefined as to which document is selected.
     *
     * ##### Replace by vector search
     *
     * If the collection has vector search enabled, you can replace the most relevant document by providing a vector in the sort option.
     *
     * @example
     * ```ts
     * await collection.insertOne({ name: 'John Doe', $vector: [.12, .52, .32] });
     *
     * await collection.replaceOne(
     *   { name: 'John Doe' },
     *   { name: 'Jane Doe', $vectorize: "Ooh, she's a little runaway" },
     *   { sort: { $vector: [.09, .58, .21] } },
     * );
     * ```
     *
     * @param filter - A filter to select the document to replace.
     * @param replacement - The replacement document, which contains no `_id` field.
     * @param options - The options for this operation.
     *
     * @returns A summary of what changed.
     */
    replaceOne(filter: CollectionFilter<WSchema>, replacement: NoId<WSchema>, options?: CollectionReplaceOneOptions): Promise<CollectionReplaceOneResult<RSchema>>;
    /**
     * ##### Overview
     *
     * Atomically deletes a single document from the collection.
     *
     * @example
     * ```ts
     * await collection.insertOne({ _id: '1', name: 'John Doe' });
     * await collection.deleteOne({ name: 'John Doe' });
     * ```
     *
     * ##### Filtering
     *
     * The filter can contain a variety of operators & combinators to select the document. See {@link CollectionFilter} for much more information.
     *
     * Just keep in mind that if the filter is empty, and no {@link Sort} is present, it's undefined as to which document is selected.
     *
     * ##### Delete by vector search
     *
     * If the collection has vector search enabled, you can delete the most relevant document by providing a vector in the sort option.
     *
     * @example
     * ```ts
     * await collection.insertOne({ name: 'John Doe', $vector: [.12, .52, .32] });
     * await collection.deleteOne({}, { sort: { $vector: [.09, .58, .42] }});
     * ```
     *
     * @param filter - A filter to select the document to delete.
     * @param options - The options for this operation.
     *
     * @returns How many documents were deleted.
     */
    deleteOne(filter: CollectionFilter<WSchema>, options?: CollectionDeleteOneOptions): Promise<CollectionDeleteOneResult>;
    /**
     * ##### Overview
     *
     * Deletes many documents from the collection.
     *
     * @example
     * ```ts
     * await collection.insertMany([
     *   { name: 'John Doe', age: 1 },
     *   { name: 'John Doe', age: 2 },
     * ]);
     * await collection.deleteMany({ name: 'John Doe' });
     * ```
     *
     * ##### Pagination
     *
     * **NOTE: This function paginates the deletion of documents in batches due to server deletion limits.** The limit is set on the server-side, and not changeable via the client side. This means multiple requests may be made to the server.
     *
     * This operation is **not necessarily atomic**. Depending on the amount of matching documents, it can keep running (in a blocking manner) for a macroscopic amount of time. In that case, documents that are modified/inserted from another concurrent process/application may be modified/inserted during the execution of this method call.
     *
     * ##### Filtering
     *
     * **If an empty filter is passed, all documents in the collection will atomically be deleted in a single API call. Proceed with caution.**
     *
     * The filter can contain a variety of operators & combinators to select the documents. See {@link CollectionFilter} for much more information.
     *
     * @example
     * ```ts
     * await collection.insertMany([
     *   { name: 'John Doe' },
     *   { name: 'Jane Doe' },
     * ]);
     *
     * const resp = await collection.deleteMany({});
     * console.log(resp.deletedCount); // -1
     * ```
     *
     * @param filter - A filter to select the documents to delete.
     * @param options - The options for this operation.
     *
     * @returns How many documents were deleted.
     */
    deleteMany(filter: CollectionFilter<WSchema>, options?: WithTimeout<'generalMethodTimeoutMs'>): Promise<CollectionDeleteManyResult>;
    /**
     * ##### Overview
     *
     * Find documents in the collection, optionally matching the provided filter.
     *
     * @example
     * ```ts
     * const cursor = await collection.find({ name: 'John Doe' });
     * const docs = await cursor.toArray();
     * ```
     *
     * ##### Projection
     *
     * This overload of {@link Collection.find} is used for when no projection is provided, and it is safe to assume the returned documents are going to be of type `Schema`.
     *
     * If it can not be inferred that a projection is definitely not provided, the `Schema` is forced to be `Partial<Schema>` if the user does not provide their own, in order to prevent type errors and ensure the user is aware that the document may not be of the same type as `Schema`.
     *
     * ##### Filtering
     *
     * The filter can contain a variety of operators & combinators to select the documents. See {@link CollectionFilter} for much more information.
     *
     * If the filter is empty, all documents in the collection will be returned (up to any provided/implied limit).
     *
     * ##### Find by vector search
     *
     * If the collection has vector search enabled, you can find the most relevant documents by providing a vector in the sort option.
     *
     * Vector ANN searches cannot return more than a set number of documents, which, at the time of writing, is 1000 items.
     *
     * @example
     * ```ts
     * await collection.insertMany([
     *   { name: 'John Doe', $vector: [.12, .52, .32] },
     *   { name: 'Jane Doe', $vector: [.32, .52, .12] },
     *   { name: 'Dane Joe', $vector: [.52, .32, .12] },
     * ]);
     *
     * const cursor = collection.find({}, {
     *   sort: { $vector: [.12, .52, .32] },
     * });
     *
     * // Returns 'John Doe'
     * console.log(await cursor.next());
     * ```
     *
     * ##### Sorting
     *
     * The sort option can be used to sort the documents returned by the cursor. See {@link Sort} for more information.
     *
     * The [DataStax documentation site](https://docs.datastax.com/en/astra-db-serverless/index.html) also contains further information on the available sort operators.
     *
     * If the sort option is not provided, there is no guarantee as to the order of the documents returned.
     *
     * When providing a non-vector sort, the Data API will return a smaller number of documents, set to 20 at the time of writing, and stop there. The returned documents are the top results across the whole collection according to the requested criterion.
     *
     * @example
     * ```ts
     * await collection.insertMany([
     *   { name: 'John Doe', age: 1, height: 168 },
     *   { name: 'John Doe', age: 2, height: 42 },
     * ]);
     *
     * const cursor = collection.find({}, {
     *   sort: { age: 1, height: -1 },
     * });
     *
     * // Returns 'John Doe' (age 2, height 42), 'John Doe' (age 1, height 168)
     * console.log(await cursor.toArray());
     * ```
     *
     * ##### Other options
     *
     * Other available options include `skip`, `limit`, `includeSimilarity`, and `includeSortVector`. See {@link CollectionFindOptions} and {@link FindCursor} for more information.
     *
     * If you prefer, you may also set these options using a fluent interface on the {@link FindCursor} itself.
     *
     * @example
     * ```ts
     * // cursor :: FindCursor<string>
     * const cursor = collection.find({})
     *   .sort({ $vector: [.12, .52, .32] })
     *   .projection<{ name: string, age: number }>({ name: 1, age: 1 })
     *   .includeSimilarity(true)
     *   .map(doc => `${doc.name} (${doc.age})`);
     * ```
     *
     * @remarks
     * When not specifying sorting criteria at all (by vector or otherwise),
     * the cursor can scroll through an arbitrary number of documents as
     * the Data API and the client periodically exchange new chunks of documents.
     *
     * --
     *
     * It should be noted that the behavior of the cursor in the case documents
     * have been added/removed after the `find` was started depends on database
     * internals, and it is not guaranteed, nor excluded, that such "real-time"
     * changes in the data would be picked up by the cursor.
     *
     * @param filter - A filter to select the documents to find. If not provided, all documents will be returned.
     * @param options - The options for this operation.
     *
     * @returns a {@link FindCursor} which can be iterated over.
     */
    find(filter: CollectionFilter<WSchema>, options?: CollectionFindOptions & {
        projection?: never;
    }): CollectionFindCursor<WithSim<RSchema>, WithSim<RSchema>>;
    /**
     * ##### Overview
     *
     * Find documents in the collection, optionally matching the provided filter.
     *
     * @example
     * ```ts
     * const cursor = await collection.find({ name: 'John Doe' });
     * const docs = await cursor.toArray();
     * ```
     *
     * ##### Projection
     *
     * This overload of {@link Collection.find} is used for when a projection is provided (or at the very least, it can not be inferred that a projection is NOT provided).
     *
     * In this case, the user must provide an explicit projection type, or the type of the documents will be `Partial<Schema>`, to prevent type-mismatches when the schema is strictly provided.
     *
     * @example
     * ```ts
     * interface User {
     *   name: string,
     *   car: { make: string, model: string },
     * }
     *
     * const collection = db.collection<User>('users');
     *
     * // Defaulting to `Partial<User>` when projection is not provided
     * const cursor = await collection.find({}, {
     *   projection: { car: 1 },
     * });
     *
     * // next :: { car?: { make?: string, model?: string } }
     * const next = await cursor.next();
     * console.log(next.car?.make);
     *
     * // Explicitly providing the projection type
     * const cursor = await collection.find<Pick<User, 'car'>>({}, {
     *   projection: { car: 1 },
     * });
     *
     * // next :: { car: { make: string, model: string } }
     * const next = await cursor.next();
     * console.log(next.car.make);
     *
     * // Projection existence can not be inferred
     * function mkFind(projection?: Projection) {
     *   return collection.find({}, { projection });
     * }
     *
     * // next :: Partial<User>
     * const next = await mkFind({ car: 1 }).next();
     * console.log(next.car?.make);
     * ```
     *
     * ##### Filtering
     *
     * The filter can contain a variety of operators & combinators to select the documents. See {@link CollectionFilter} for much more information.
     *
     * If the filter is empty, all documents in the collection will be returned (up to any provided/implied limit).
     *
     * ##### Find by vector search
     *
     * If the collection has vector search enabled, you can find the most relevant documents by providing a vector in the sort option.
     *
     * Vector ANN searches cannot return more than a set number of documents, which, at the time of writing, is 1000 items.
     *
     * @example
     * ```ts
     * await collection.insertMany([
     *   { name: 'John Doe', $vector: [.12, .52, .32] },
     *   { name: 'Jane Doe', $vector: [.32, .52, .12] },
     *   { name: 'Dane Joe', $vector: [.52, .32, .12] },
     * ]);
     *
     * const cursor = collection.find({}, {
     *   sort: { $vector: [.12, .52, .32] },
     * });
     *
     * // Returns 'John Doe'
     * console.log(await cursor.next());
     * ```
     *
     * ##### Sorting
     *
     * The sort option can be used to sort the documents returned by the cursor. See {@link Sort} for more information.
     *
     * The [DataStax documentation site](https://docs.datastax.com/en/astra-db-serverless/index.html) also contains further information on the available sort operators.
     *
     * If the sort option is not provided, there is no guarantee as to the order of the documents returned.
     *
     * When providing a non-vector sort, the Data API will return a smaller number of documents, set to 20 at the time of writing, and stop there. The returned documents are the top results across the whole collection according to the requested criterion.
     *
     * @example
     * ```ts
     * await collection.insertMany([
     *   { name: 'John Doe', age: 1, height: 168 },
     *   { name: 'John Doe', age: 2, height: 42 },
     * ]);
     *
     * const cursor = collection.find({}, {
     *   sort: { age: 1, height: -1 },
     * });
     *
     * // Returns 'John Doe' (age 2, height 42), 'John Doe' (age 1, height 168)
     * console.log(await cursor.toArray());
     * ```
     *
     * ##### Other options
     *
     * Other available options include `skip`, `limit`, `includeSimilarity`, and `includeSortVector`. See {@link CollectionFindOptions} and {@link FindCursor} for more information.
     *
     * If you prefer, you may also set these options using a fluent interface on the {@link FindCursor} itself.
     *
     * @example
     * ```ts
     * // cursor :: FindCursor<string>
     * const cursor = collection.find({})
     *   .sort({ $vector: [.12, .52, .32] })
     *   .projection<{ name: string, age: number }>({ name: 1, age: 1 })
     *   .includeSimilarity(true)
     *   .map(doc => `${doc.name} (${doc.age})`);
     * ```
     *
     * @remarks
     * When not specifying sorting criteria at all (by vector or otherwise),
     * the cursor can scroll through an arbitrary number of documents as
     * the Data API and the client periodically exchange new chunks of documents.
     *
     * --
     *
     * It should be noted that the behavior of the cursor in the case documents
     * have been added/removed after the `find` was started depends on database
     * internals, and it is not guaranteed, nor excluded, that such "real-time"
     * changes in the data would be picked up by the cursor.
     *
     * @param filter - A filter to select the documents to find. If not provided, all documents will be returned.
     * @param options - The options for this operation.
     *
     * @returns a {@link FindCursor} which can be iterated over.
     */
    find<TRaw extends SomeDoc = Partial<RSchema>>(filter: CollectionFilter<WSchema>, options: CollectionFindOptions): CollectionFindCursor<TRaw, TRaw>;
    /**
     * ##### Overview
     *
     * Find a single document in the collection, optionally matching the provided filter.
     *
     * @example
     * ```ts
     * const doc = await collection.findOne({ name: 'John Doe' });
     * ```
     *
     * ##### Projection
     *
     * This overload of {@link Collection.findOne} is used for when no projection is provided, and it is safe to assume the returned document is going to be of type `Schema`.
     *
     * If it can not be inferred that a projection is definitely not provided, the `Schema` is forced to be `Partial<Schema>` if the user does not provide their own, in order to prevent type errors and ensure the user is aware that the document may not be of the same type as `Schema`.
     *
     * ##### Filtering
     *
     * The filter can contain a variety of operators & combinators to select the document. See {@link CollectionFilter} for much more information.
     *
     * If the filter is empty, and no {@link Sort} is present, it's undefined as to which document is selected.
     *
     * ##### Find by vector search
     *
     * If the collection has vector search enabled, you can find the most relevant document by providing a vector in the sort option.
     *
     * @example
     * ```ts
     * await collection.insertMany([
     *   { name: 'John Doe', $vector: [.12, .52, .32] },
     *   { name: 'Jane Doe', $vector: [.32, .52, .12] },
     *   { name: 'Dane Joe', $vector: [.52, .32, .12] },
     * ]);
     *
     * const doc = collection.findOne({}, {
     *   sort: { $vector: [.12, .52, .32] },
     * });
     *
     * // 'John Doe'
     * console.log(doc.name);
     * ```
     *
     * ##### Sorting
     *
     * The sort option can be used to pick the most relevant document. See {@link Sort} for more information.
     *
     * The [DataStax documentation site](https://docs.datastax.com/en/astra-db-serverless/index.html) also contains further information on the available sort operators.
     *
     * If the sort option is not provided, there is no guarantee as to which of the documents which matches the filter is returned.
     *
     * @example
     * ```ts
     * await collection.insertMany([
     *   { name: 'John Doe', age: 1, height: 168 },
     *   { name: 'John Doe', age: 2, height: 42 },
     * ]);
     *
     * const doc = collection.findOne({}, {
     *   sort: { age: 1, height: -1 },
     * });
     *
     * // 'John Doe' (age 2, height 42)
     * console.log(doc.name);
     * ```
     *
     * ##### Other options
     *
     * Other available options include `includeSimilarity`. See {@link CollectionFindOneOptions} for more information.
     *
     * If you want to get `skip` or `includeSortVector` as well, use {@link Collection.find} with a `limit: 1` instead.
     *
     * @example
     * ```ts
     * const doc = await cursor.findOne({}, {
     *   sort: { $vector: [.12, .52, .32] },
     *   includeSimilarity: true,
     * });
     * ```
     *
     * @param filter - A filter to select the documents to find. If not provided, all documents will be returned.
     * @param options - The options for this operation.
     *
     * @returns A document matching the criterion, or `null` if no such document exists.
     */
    findOne(filter: CollectionFilter<WSchema>, options?: CollectionFindOneOptions & {
        projection?: never;
    }): Promise<WithSim<RSchema> | null>;
    /**
     * ##### Overview
     *
     * Find a single document in the collection, optionally matching the provided filter.
     *
     * @example
     * ```ts
     * const doc = await collection.findOne({ name: 'John Doe' });
     * ```
     *
     * ##### Projection
     *
     * This overload of {@link Collection.findOne} is used for when a projection is provided (or at the very least, it can not be inferred that a projection is NOT provided).
     *
     * In this case, the user must provide an explicit projection type, or the type of the returned document will be as `Partial<Schema>`, to prevent type-mismatches when the schema is strictly provided.
     *
     * @example
     * ```ts
     * interface User {
     *   name: string,
     *   car: { make: string, model: string },
     * }
     *
     * const collection = db.collection<User>('users');
     *
     * // Defaulting to `Partial<User>` when projection is not provided
     * const doc = await collection.findOne({}, {
     *   projection: { car: 1 },
     * });
     *
     * // doc :: { car?: { make?: string, model?: string } }
     * console.log(doc.car?.make);
     *
     * // Explicitly providing the projection type
     * const doc = await collection.findOne<Pick<User, 'car'>>({}, {
     *   projection: { car: 1 },
     * });
     *
     * // doc :: { car: { make: string, model: string } }
     * console.log(doc.car.make);
     *
     * // Projection existence can not be inferred
     * function findOne(projection?: Projection) {
     *   return collection.findOne({}, { projection });
     * }
     *
     * // doc :: Partial<User>
     * const doc = await findOne({ car: 1 }).next();
     * console.log(doc.car?.make);
     * ```
     *
     * ##### Filtering
     *
     * The filter can contain a variety of operators & combinators to select the document. See {@link CollectionFilter} for much more information.
     *
     * If the filter is empty, and no {@link Sort} is present, it's undefined as to which document is selected.
     *
     * ##### Find by vector search
     *
     * If the collection has vector search enabled, you can find the most relevant document by providing a vector in the sort option.
     *
     * @example
     * ```ts
     * await collection.insertMany([
     *   { name: 'John Doe', $vector: [.12, .52, .32] },
     *   { name: 'Jane Doe', $vector: [.32, .52, .12] },
     *   { name: 'Dane Joe', $vector: [.52, .32, .12] },
     * ]);
     *
     * const doc = collection.findOne({}, {
     *   sort: { $vector: [.12, .52, .32] },
     * });
     *
     * // 'John Doe'
     * console.log(doc.name);
     * ```
     *
     * ##### Sorting
     *
     * The sort option can be used to pick the most relevant document. See {@link Sort} for more information.
     *
     * The [DataStax documentation site](https://docs.datastax.com/en/astra-db-serverless/index.html) also contains further information on the available sort operators.
     *
     * If the sort option is not provided, there is no guarantee as to which of the documents which matches the filter is returned.
     *
     * @example
     * ```ts
     * await collection.insertMany([
     *   { name: 'John Doe', age: 1, height: 168 },
     *   { name: 'John Doe', age: 2, height: 42 },
     * ]);
     *
     * const doc = collection.findOne({}, {
     *   sort: { age: 1, height: -1 },
     * });
     *
     * // 'John Doe' (age 2, height 42)
     * console.log(doc.name);
     * ```
     *
     * ##### Other options
     *
     * Other available options include `includeSimilarity`. See {@link CollectionFindOneOptions} for more information.
     *
     * If you want to get `skip` or `includeSortVector` as well, use {@link Collection.find} with a `limit: 1` instead.
     *
     * @example
     * ```ts
     * const doc = await cursor.findOne({}, {
     *   sort: { $vector: [.12, .52, .32] },
     *   includeSimilarity: true,
     * });
     * ```
     *
     * @param filter - A filter to select the documents to find. If not provided, all documents will be returned.
     * @param options - The options for this operation.
     *
     * @returns A document matching the criterion, or `null` if no such document exists.
     */
    findOne<TRaw extends SomeDoc = Partial<RSchema>>(filter: CollectionFilter<WSchema>, options: CollectionFindOneOptions): Promise<TRaw | null>;
    /**
     * ##### Overview
     *
     * Return a list of the unique values of `key` across the documents in the collection that match the provided filter.
     *
     * @example
     * ```ts
     * const docs = await collection.distinct('name');
     * ```
     *
     * ##### Major disclaimer
     *
     * **NOTE: This is a *client-side* operation**—this effectively browses all matching documents (albeit with a
     * projection) using the logic of the {@link Collection.find} method, and collects the unique value for the
     * given `key` manually. As such, there may be performance, latency and ultimately billing implications if the
     * amount of matching documents is large.
     *
     * ##### Usage
     *
     * The key may use dot-notation to access nested fields, such as `'field'`, `'field.subfield'`, `'field.3'`,
     * `'field.3.subfield'`, etc. If lists are encountered and no numeric index is specified, all items in the list are
     * pulled.
     *
     * **Note that on complex extractions, the return type may be not as expected.** In that case, it's on the user to
     * cast the return type to the correct one.
     *
     * Distinct works with arbitrary objects as well, by creating a deterministic hash of the object and comparing it
     * with the hashes of the objects already seen. This, unsurprisingly, may not be great for performance if you have
     * a lot of records that match, so it's recommended to use distinct on simple values whenever performance or number
     * of records is a concern.
     *
     * For details on the behaviour of "distinct" in conjunction with real-time changes in the collection contents, see
     * the remarks on the `find` command.
     *
     * @example
     * ```typescript
     * await collection.insertMany([
     *   { letter: { value: 'a' }, car: [1] },
     *   { letter: { value: 'b' }, car: [2, 3] },
     *   { letter: { value: 'a' }, car: [2], bus: 'no' },
     * ]);
     *
     * // ['a', 'b']
     * const distinct = await collection.distinct('letter.value');
     *
     * await collection.insertOne({
     *   x: [{ y: 'Y', 0: 'ZERO' }],
     * });
     *
     * // ['Y']
     * await collection.distinct('x.y');
     *
     * // [{ y: 'Y', 0: 'ZERO' }]
     * await collection.distinct('x.0');
     *
     * // ['Y']
     * await collection.distinct('x.0.y');
     *
     * // ['ZERO']
     * await collection.distinct('x.0.0');
     * ```
     *
     * @param key - The dot-notation key to pick which values to retrieve unique
     * @param filter - A filter to select the documents to find. If not provided, all documents will be matched.
     * @param options - The options for this operation.
     *
     * @returns A list of all the unique values selected by the given `key`
     */
    distinct<Key extends string>(key: Key, filter: CollectionFilter<WSchema>, options?: WithTimeout<'generalMethodTimeoutMs'>): Promise<Flatten<(SomeDoc & ToDotNotation<RSchema>)[Key]>[]>;
    /**
     * ##### Overview
     *
     * Counts the number of documents in the collection, optionally with a filter.
     *
     * @example
     * ```ts
     * const count = await collection.countDocuments({ name: 'John Doe' }, 1000);
     * ```
     *
     * ##### The `limit` parameter
     *
     * Takes in a `limit` option which dictates the maximum number of documents that may be present before a
     * {@link TooManyDocumentsToCountError} is thrown. If the limit is higher than the highest limit accepted by the
     * Data API, a {@link TooManyDocumentsToCountError} will be thrown anyway (i.e. `1000`).
     *
     * @example
     * ```typescript
     * await collection.insertMany([
     *   { name: 'John Doe' },
     *   { name: 'Jane Doe' },
     * ]);
     *
     * const count = await collection.countDocuments({}, 1000);
     * console.log(count); // 1
     *
     * // Will throw a TooManyDocumentsToCountError as it counts 2, but the limit is 1
     * const count = await collection.countDocuments({}, 1);
     * ```
     *
     * @remarks
     * Count operations are expensive: for this reason, the best practice is to provide a reasonable `upperBound`
     * according to the caller expectations. Moreover, indiscriminate usage of count operations for sizeable amounts
     * of documents (i.e. in the thousands and more) is discouraged in favor of alternative application-specific
     * solutions. Keep in mind that the Data API has a hard upper limit on the amount of documents it will count,
     * and that an exception will be thrown by this method if this limit is encountered.
     *
     * @param filter - A filter to select the documents to count. If not provided, all documents will be counted.
     * @param upperBound - The maximum number of documents to count.
     * @param options - The options for this operation.
     *
     * @returns The number of counted documents, if below the provided limit
     *
     * @throws TooManyDocumentsToCountError - If the number of documents counted exceeds the provided limit.
     */
    countDocuments(filter: CollectionFilter<WSchema>, upperBound: number, options?: WithTimeout<'generalMethodTimeoutMs'>): Promise<number>;
    /**
     * ##### Overview
     *
     * Gets an estimate of the count of documents in a collection.
     *
     * This gives a very rough estimate of the number of documents in the collection. It is not guaranteed to be
     * accurate, and should not be used as a source of truth for the number of documents in the collection.
     *
     * But this operation is faster than {@link Collection.countDocuments}, and while it doesn't
     * accept a filter, **it can handle more than 1000 documents.**
     *
     * @example
     * ```ts
     * const count = await collection.estimatedDocumentCount();
     * console.log(count); // Hard to predict exact number
     * ```
     *
     * @param options - The options for this operation.
     *
     * @returns The estimated number of documents in the collection
     */
    estimatedDocumentCount(options?: WithTimeout<'generalMethodTimeoutMs'>): Promise<number>;
    /**
     * ##### Overview
     *
     * Atomically finds a single document in the collection and replaces it.
     *
     * @example
     * ```typescript
     * await collection.insertOne({ _id: '1', name: 'John Doe' });
     * await collection.findOneAndReplace({ _id: '1' }, { name: 'Dohn Joe' });
     * ```
     *
     * ##### Projection
     *
     * You can set `projection` to determine which fields to include in the returned document.
     *
     * For type-safety reasons, this function allows you to pass in your own projection type, or defaults to `WithId<Schema>` if not provided.
     *
     * If you use a projection and do not pass in the appropriate type, you may very well run into runtime type errors not caught by the compiler.
     *
     * @example
     * ```ts
     * await collection.insertOne({ _id: '1', name: 'John Doe', age: 3 });
     *
     * const doc = await collection.findOneAndReplace<{ name: string }>(
     *   { _id: '1' },
     *   { name: 'Dohn Joe' },
     *   { projection: { name: 1, _id: 0 } },
     * );
     *
     * // Prints { name: 'Dohn Joe' }
     * console.log(doc);
     * ```
     *
     * ##### Upserting
     *
     * If `upsert` is set to true, it will insert the document reconstructed from the filter & the update filter if no match is found.
     *
     * @example
     * ```ts
     * const resp = await collection.findOneAndReplace(
     *   { _id: 42 },
     *   { name: 'Jessica' },
     *   { upsert: true },
     * );
     *
     * console.log(resp); // null, b/c no previous document was found
     * ```
     *
     * ##### `returnDocument`
     *
     * `returnDocument` (default `'before'`) controls whether the original or the updated document is returned.
     * - `'before'`: Returns the document as it was before the update, or `null` if the document was upserted.
     * - `'after'`: Returns the document as it is after the update.
     *
     * @example
     * ```ts
     * await collection.insertOne({ _id: '1', name: 'John Doe' });
     *
     * const after = await collection.findOneAndReplace(
     *   { _id: '1' },
     *   { name: 'Jane Doe' },
     *   { returnDocument: 'after' },
     * );
     *
     * // Prints { _id: '1', name: 'Jane Doe' }
     * console.log(after);
     * ```
     *
     * ##### Filtering
     *
     * The filter can contain a variety of operators & combinators to select the document. See {@link Filter} for much more information.
     *
     * Just keep in mind that if the filter is empty, and no {@link Sort} is present, it's undefined as to which document is selected.
     *
     * @param filter - A filter to select the document to find.
     * @param replacement - The replacement document, which contains no `_id` field.
     * @param options - The options for this operation.
     *
     * @returns The document before/after replacement, depending on the type of `returnDocument`
     */
    findOneAndReplace<TRaw extends SomeDoc = RSchema>(filter: CollectionFilter<WSchema>, replacement: NoId<WSchema>, options?: CollectionFindOneAndReplaceOptions): Promise<TRaw | null>;
    /**
     * ##### Overview
     *
     * Atomically finds a single document in the collection and deletes it.
     *
     * @example
     * ```ts
     * await collection.insertOne({ _id: '1', name: 'John Doe' });
     * await collection.findOneAndDelete({ _id: '1' });
     * ```
     *
     * ##### Projection
     *
     * You can set `projection` to determine which fields to include in the returned document.
     *
     * For type-safety reasons, this function allows you to pass in your own projection type, or defaults to `WithId<Schema>` if not provided.
     *
     * If you use a projection and do not pass in the appropriate type, you may very well run into runtime type errors not caught by the compiler.
     *
     * @example
     * ```ts
     * await collection.insertOne({ _id: '1', name: 'John Doe', age: 3 });
     *
     * const doc = await collection.findOneAndDelete<{ name: string }>(
     *   { _id: '1' },
     *   { projection: { name: 1, _id: 0 } },
     * );
     *
     * // Prints { name: 'John Doe' }
     * console.log(doc);
     * ```
     *
     * ##### Filtering
     *
     * The filter can contain a variety of operators & combinators to select the document. See {@link CollectionFilter} for much more information.
     *
     * Just keep in mind that if the filter is empty, and no {@link Sort} is present, it's undefined as to which document is selected.
     *
     * @param filter - A filter to select the document to find.
     * @param options - The options for this operation.
     *
     * @returns The deleted document, or `null` if no document was found.
     */
    findOneAndDelete<TRaw extends SomeDoc = RSchema>(filter: CollectionFilter<WSchema>, options?: CollectionFindOneAndDeleteOptions): Promise<TRaw | null>;
    /**
     * ##### Overview
     *
     * Atomically finds a single document in the collection and updates it.
     *
     * @example
     * ```ts
     * await collection.insertOne({ _id: '1', name: 'John Doe' });
     * await collection.findOneAndUpdate({ _id: '1' }, { $set: { name: 'Jane Doe' } });
     * ```
     *
     * ##### Projection
     *
     * You can set `projection` to determine which fields to include in the returned document.
     *
     * For type-safety reasons, this function allows you to pass in your own projection type, or defaults to `WithId<Schema>` if not provided.
     *
     * If you use a projection and do not pass in the appropriate type, you may very well run into runtime type errors not caught by the compiler.
     *
     * @example
     * ```ts
     * await collection.insertOne({ _id: '1', name: 'John Doe', age: 3 });
     *
     * const doc = await collection.findOneAndUpdate<{ name: string }>(
     *   { _id: '1' },
     *   { $set: { name: 'Jane Doe' } },
     *   { projection: { name: 1, _id: 0 } },
     * );
     *
     * // Prints { name: 'John Doe' }
     * console.log(doc);
     * ```
     *
     * ##### Upserting
     *
     * If `upsert` is set to true, it will insert the document reconstructed from the filter & the update filter if no match is found.
     *
     * @example
     * ```ts
     * const resp = await collection.findOneAndUpdate(
     *   { _id: 42 },
     *   { $set: { name: 'Jessica' } },
     *   { upsert: true },
     * );
     *
     * console.log(resp); // null, b/c no previous document was found
     * ```
     *
     * ##### `returnDocument`
     *
     * `returnDocument` (default `'before'`) controls whether the original or the updated document is returned.
     * - `'before'`: Returns the document as it was before the update, or `null` if the document was upserted.
     * - `'after'`: Returns the document as it is after the update.
     *
     * @example
     * ```ts
     * await collection.insertOne({ _id: '1', name: 'John Doe' });
     *
     * const after = await collection.findOneAndUpdate(
     *   { _id: '1' },
     *   { $set: { name: 'Jane Doe' } },
     *   { returnDocument: 'after' },
     * );
     *
     * // Prints { _id: '1', name: 'Jane Doe' }
     * console.log(after);
     * ```
     *
     * ##### Filtering
     *
     * The filter can contain a variety of operators & combinators to select the document. See {@link CollectionFilter} for much more information.
     *
     * Just keep in mind that if the filter is empty, and no {@link Sort} is present, it's undefined as to which document is selected.
     *
     * @param filter - A filter to select the document to find.
     * @param update - The update to apply to the selected document.
     * @param options - The options for this operation.
     *
     * @returns The document before/after the update, depending on the type of `returnDocument`
     */
    findOneAndUpdate(filter: CollectionFilter<WSchema>, update: CollectionUpdateFilter<WSchema>, options?: CollectionFindOneAndUpdateOptions): Promise<RSchema | null>;
    /**
     * ##### Overview
     *
     * Get the collection options, i.e. its configuration as read from the database.
     *
     * The method issues a request to the Data API each time it is invoked, without caching mechanisms;
     * this ensures up-to-date information for usages such as real-time collection validation by the application.
     *
     * @example
     * ```ts
     * const options = await collection.info();
     * console.log(options.vector);
     * ```
     *
     * @param options - The options for this operation.
     *
     * @returns The options that the collection was created with (i.e. the `vector` and `indexing` operations).
     */
    options(options?: WithTimeout<'collectionAdminTimeoutMs'>): Promise<CollectionDefinition<SomeDoc>>;
    /**
     * ##### Overview
     *
     * Drops the collection from the database, including all the documents it contains.
     *
     * @example
     * ```typescript
     * const collection = await db.collection('my_collection');
     * await collection.drop();
     * ```
     *
     * ##### Disclaimer
     *
     * Once the collection is dropped, this object is still technically "usable", but any further operations on it
     * will fail at the Data API level; thus, it's the user's responsibility to make sure that the collection object
     * is no longer used.
     *
     * @param options - The options for this operation.
     *
     * @returns A promise which resolves when the collection has been dropped.
     *
     * @remarks Use with caution. Wear your safety goggles. Don't say I didn't warn you.
     */
    drop(options?: WithTimeout<'collectionAdminTimeoutMs'>): Promise<void>;
    /**
     * Backdoor to the HTTP client for if it's absolutely necessary. Which it almost never (if even ever) is.
     */
    get _httpClient(): DataAPIHttpClient<"normal">;
}

/**
 * Represents filter operations exclusive to array (or dynamically typed) fields
 *
 * @public
 */
export declare interface CollectionArrayFilterOps<Elem> {
    /**
     * Checks if the array is of a certain size.
     */
    $size?: number;
    /**
     * Checks if the array contains all the specified elements.
     */
    $all?: Elem;
}

/**
 * Types some array operations. Not inherently strict or weak.
 *
 * @public
 */
export declare type CollectionArrayUpdate<Schema> = {
    [K in keyof Schema as any[] extends Schema[K] ? K : never]?: PickArrayTypes<Schema[K]>;
};

/**
 * Types the $currentDate operation. Not inherently strict or weak.
 *
 * @public
 */
export declare type CollectionCurrentDate<Schema> = {
    [K in keyof Schema as Schema[K] extends Date | {
        $date: number;
    } ? K : never]?: boolean;
};

/**
 * Weaker version of StrictDateUpdate which allows for more flexibility in typing date update operations.
 *
 * @public
 */
export declare type CollectionDateUpdate<Schema> = {
    [K in keyof Schema as ContainsDate<Schema[K]> extends true ? K : never]?: Date | {
        $date: number;
    };
};

/**
 * Represents the options for the default ID.
 *
 * **If `type` is not specified, the default ID will be a string UUID.**
 *
 * @field type - The type of the default ID.
 *
 * @public
 */
export declare interface CollectionDefaultIdOptions {
    /**
     * The type of the default ID that the API should generate if no ID is provided in the inserted document.
     *
     * **If not specified, the default ID will be a string UUID.**
     *
     * | Type       | Description    | Example                                            |
     * |------------|----------------|----------------------------------------------------|
     * | `uuid`     | A UUID v4.     | `new UUID('f47ac10b-58cc-4372-a567-0e02b2c3d479')` |
     * | `uuidv6`   | A UUID v6.     | `new UUID('6f752f1a-6b6d-4f3e-8e1e-2e167e3b5f3d')` |
     * | `uuidv7`   | A UUID v7.     | `new UUID('018e75ff-a07b-7b08-bb91-aa566c5abaa6')` |
     * | `objectId` | An ObjectID.   | `new ObjectId('507f1f77bcf86cd799439011')`         |
     * | default    | A string UUID. | `'f47ac10b-58cc-4372-a567-0e02b2c3d479'`           |
     *
     * @example
     * ```typescript
     * const collections = await db.createCollection('my-collections');
     *
     * // { name: 'Jessica', _id: 'f47ac10b-58cc-4372-a567-0e02b2c3d479' }
     * await collections.insertOne({ name: 'Jessica' });
     *```
     *
     * @example
     * ```typescript
     * const collections = await db.createCollection('my-collections', {
     *   defaultId: { type: 'uuidv6' },
     * });
     *
     * // { name: 'Allman', _id: UUID('6f752f1a-6b6d-6f3e-8e1e-2e167e3b5f3d') }
     * await collections.insertOne({ name: 'Allman' });
     * ```
     *
     * @example
     * ```typescript
     * const collections = await db.createCollection('my-collections', {
     *   defaultId: { type: 'objectId' },
     * });
     *
     * // { name: 'Brothers', _id: ObjectId('507f1f77bcf86cd799439011') }
     * await collections.insertOne({ name: 'Brothers' });
     * ```
     *
     * @remarks Make sure you're keeping this all in mind if you're specifically typing your _id field.
     */
    type: 'uuid' | 'uuidv6' | 'uuidv7' | 'objectId';
}

/**
 * Represents the options for the createCollection command.
 *
 * @field vector - Options related to vector search.
 * @field indexing - Options related to indexing.
 * @field defaultId - Options related to the default ID.
 *
 * @public
 */
export declare interface CollectionDefinition<Schema extends SomeDoc> {
    /**
     * Options related to vector search.
     */
    vector?: CollectionVectorOptions;
    /**
     * Options related to indexing.
     */
    indexing?: CollectionIndexingOptions<Schema>;
    /**
     * Options related to the default ID.
     */
    defaultId?: CollectionDefaultIdOptions;
}

/**
 * Represents an error that occurred during a `deleteMany` operation (which is, generally, paginated).
 *
 * Contains the number of documents that were successfully deleted, as well as the cumulative errors that occurred
 * during the operation.
 *
 * @field message - A human-readable message describing the *first* error
 * @field errorDescriptors - A list of error descriptors representing the individual errors returned by the API
 * @field detailedErrorDescriptors - A list of errors 1:1 with the number of errorful API requests made to the server.
 * @field partialResult - The partial result of the `DeleteMany` operation that was performed
 *
 * @public
 */
export declare class CollectionDeleteManyError extends CumulativeOperationError {
    /**
     * The name of the error. This is always 'DeleteManyError'.
     */
    name: string;
    /**
     * The partial result of the `DeleteMany` operation that was performed. This is *always* defined, and is the result
     * of the operation up to the point of the first error.
     */
    readonly partialResult: CollectionDeleteManyResult;
}

/**
 * Represents the result of a delete command.
 *
 * @field deletedCount - The number of deleted documents. Can be any non-negative integer.
 *
 * @see Collection.deleteMany
 *
 * @public
 */
export declare type CollectionDeleteManyResult = GenericDeleteManyResult;

/**
 * Represents the options for the deleteOne command.
 *
 * @field sort - The sort order to pick which document to delete if the filter selects multiple documents.
 * @field timeout - The timeout override for this method
 *
 * @see Collection.deleteOne
 *
 * @public
 */
export declare type CollectionDeleteOneOptions = GenericDeleteOneOptions;

/**
 * Represents the result of a delete command.
 *
 * @field deletedCount - The number of deleted documents. Can be either 0 or 1.
 *
 * @see Collection.deleteOne
 *
 * @public
 */
export declare interface CollectionDeleteOneResult {
    /**
     * The number of deleted documents.
     */
    deletedCount: 0 | 1;
}

/**
 * Information about a collection, used when `nameOnly` is false in {@link ListCollectionsOptions}.
 *
 * @field name - The name of the collections.
 * @field options - The creation options for the collections.
 *
 * @see ListCollectionsOptions
 * @see Db.listCollections
 *
 * @public
 */
export declare interface CollectionDescriptor {
    /**
     * The name of the collections.
     */
    name: string;
    /**
     * The creation options for the collections (i.e. the `vector`, `indexing`, and `defaultId` fields).
     */
    definition: CollectionDefinition<SomeDoc>;
}

/**
 * Represents some filter operation for a given document schema.
 *
 * **If you want stricter type-checking and full auto-complete, see {@link StrictCollectionFilter}.**
 *
 * This is a more relaxed version of {@link StrictCollectionFilter} that doesn't type-check nested fields.
 *
 * @example
 * ```typescript
 * interface BasicSchema {
 *   arr: string[],
 *   num: number,
 * }
 *
 * db.collections<BasicSchema>('coll_name').findOne({
 *   $and: [
 *     { _id: { $in: ['abc', 'def'] } },
 *     { $not: { arr: { $size: 0 } } },
 *   ],
 * });
 * ```
 *
 * @public
 */
export declare type CollectionFilter<Schema extends SomeDoc> = {
    [K in keyof ToDotNotation<NoId<Schema>>]?: CollectionFilterExpr<ToDotNotation<NoId<Schema>>[K]>;
} & {
    _id?: CollectionFilterExpr<IdOf<Schema>>;
    $and?: CollectionFilter<Schema>[];
    $or?: CollectionFilter<Schema>[];
    $not?: CollectionFilter<Schema>;
    [key: string]: any;
};

/**
 * Represents an expression in a filter statement, such as an exact value, or a filter operator
 *
 * @public
 */
export declare type CollectionFilterExpr<Elem> = Elem | (CollectionFilterOps<Elem> & {
    [key: string]: any;
});

/**
 * Represents filter operators such as `$eq` and `$in` (but not statements like `$and`)
 *
 * @public
 */
export declare type CollectionFilterOps<Elem> = {
    $eq?: Elem;
    $ne?: Elem;
    $in?: Elem[];
    $nin?: Elem[];
    $exists?: boolean;
    $lt?: Elem;
    $lte?: Elem;
    $gt?: Elem;
    $gte?: Elem;
} & (any[] extends Elem ? CollectionArrayFilterOps<Elem> : EmptyObj);

/**
 * A subclass of `FindCursor` which is identical to its parent; it just adds some more specific typing for
 * a couple of properties/functions.
 *
 * See {@link FindCursor} directly for information on the cursor itself.
 *
 * @public
 */
export declare class CollectionFindCursor<T, TRaw extends SomeDoc = SomeDoc> extends FindCursor<T, TRaw> {
    /**
     * The collection which spawned this cursor.
     *
     * @returns The collection which spawned this cursor.
     */
    get dataSource(): Collection;
    /**
     * Sets the filter for the cursor, overwriting any previous filter.
     *
     * *NB. This method does **NOT** mutate the cursor, and may be called even after the cursor is started; it simply
     * returns a new, uninitialized cursor with the given new filter set.*
     *
     * @param filter - A filter to select which records to return.
     *
     * @returns A new cursor with the new filter set.
     */
    filter(filter: CollectionFilter<TRaw>): FindCursor<T, TRaw>;
}

/**
 * Represents the options for the `findOneAndDelete` command.
 *
 * @field sort - The sort order to pick which document to delete if the filter selects multiple documents.
 * @field projection - Specifies which fields should be included/excluded in the returned documents.
 * @field timeout - The timeout override for this method
 *
 * @see Collection.findOneAndDelete
 *
 * @public
 */
export declare type CollectionFindOneAndDeleteOptions = GenericFindOneAndDeleteOptions;

/**
 * Represents the options for the `findOneAndReplace` command.
 *
 * @field returnDocument - Specifies whether to return the original or updated document.
 * @field upsert - If true, perform an insert if no documents match the filter.
 * @field sort - The sort order to pick which document to replace if the filter selects multiple documents.
 * @field projection - Specifies which fields should be included/excluded in the returned documents.
 * @field timeout - The timeout override for this method
 *
 * @see Collection.findOneAndReplace
 *
 * @public
 */
export declare type CollectionFindOneAndReplaceOptions = GenericFindOneAndReplaceOptions;

/**
 * Represents the options for the `findOneAndUpdate` command.
 *
 * @field returnDocument - Specifies whether to return the original or updated document.
 * @field upsert - If true, perform an insert if no documents match the filter.
 * @field sort - The sort order to pick which document to replace if the filter selects multiple documents.
 * @field projection - Specifies which fields should be included/excluded in the returned documents.
 * @field includeResultMetadata - When true, returns alongside the document, an `ok` field with a value of 1 if the command executed successfully.
 * @field timeout - The timeout override for this method
 *
 * @see Collection.findOneAndUpdate
 *
 * @public
 */
export declare type CollectionFindOneAndUpdateOptions = GenericFindOneAndUpdateOptions;

/**
 * Represents the options for the collection `findOne` command.
 *
 * @field sort - The sort order to pick which document to return if the filter selects multiple documents.
 * @field projection - Specifies which fields should be included/excluded in the returned documents.
 * @field includeSimilarity - If true, include the similarity score in the result via the `$similarity` field.
 * @field timeout - The timeout override for this method
 *
 * @public
 */
export declare type CollectionFindOneOptions = GenericFindOneOptions;

/**
 * Options for the collection `find` method.
 *
 * @field sort - The sort order to pick which document to return if the filter selects multiple documents.
 * @field projection - Specifies which fields should be included/excluded in the returned documents.
 * @field limit - Max number of documents to return in the lifetime of the cursor.
 * @field skip - Number of documents to skip if using a sort.
 * @field includeSimilarity - If true, include the similarity score in the result via the `$similarity` field.
 *
 * @see Collection.find
 *
 * @public
 */
export declare type CollectionFindOptions = GenericFindOptions;

/**
 * Represents the options for the indexing.
 *
 * **Only one of `allow` or `deny` can be specified.**
 *
 * See [indexing](https://docs.datastax.com/en/astra/astra-db-vector/api-reference/data-api-commands.html#advanced-feature-indexing-clause-on-createcollection) for more details.
 *
 * @example
 * ```typescript
 * const collection1 = await db.createCollection('my-collections', {
 *   indexing: {
 *     allow: ['name', 'age'],
 *   },
 * });
 *
 * const collection2 = await db.createCollection('my-collections', {
 *   indexing: {
 *     deny: ['*'],
 *   },
 * });
 * ```
 *
 * @field allow - The fields to index.
 * @field deny - The fields to not index.
 *
 * @public
 */
export declare type CollectionIndexingOptions<Schema extends SomeDoc> = {
    allow: (keyof ToDotNotation<Schema> | string)[] | ['*'];
    deny?: never;
} | {
    deny: (keyof ToDotNotation<Schema> | string)[] | ['*'];
    allow?: never;
};

/**
 * ##### Overview
 *
 * Represents an error that occurred during an `insertMany` operation (which may be paginated).
 *
 * Contains the inserted IDs of the documents that were successfully inserted, as well as the cumulative errors
 * that occurred during the operation.
 *
 * If the operation was ordered, the `insertedIds` will be in the same order as the documents that were attempted to
 * be inserted.
 *
 * @example
 * ```ts
 * try {
 *   await collection.insertMany([
 *     { _id: 'id1', desc: 'An innocent little document' },
 *     { _id: 'id2', name: 'Another little document minding its own business' },
 *     { _id: 'id2', name: 'A mean document commiting _identity theft' },
 *     { _id: 'id3', name: 'A document that will never see the light of day-tabase' },
 *   ], { ordered: true });
 * } catch (e) {
 *   if (e instanceof CollectionInsertManyError) {
 *     console.log(e.message); // "Document already exists with the given _id"
 *     console.log(e.partialResult.insertedIds); // ['id1', 'id2']
 *   }
 * }
 * ```
 *
 * ##### Collections vs Tables
 *
 * There is a sister {@link TableInsertManyError} class that is used for `insertMany` operations on tables. It's
 * identical in structure, but just uses the appropriate {@link TableInsertManyResult} type.
 *
 * @field message - A human-readable message describing the *first* error
 * @field errorDescriptors - A list of error descriptors representing the individual errors returned by the API
 * @field detailedErrorDescriptors - A list of errors 1:1 with the number of errorful API requests made to the server.
 * @field partialResult - The partial result of the `InsertMany` operation that was performed
 *
 * @public
 */
export declare class CollectionInsertManyError extends CumulativeOperationError {
    /**
     * The name of the error. This is always 'InsertManyError'.
     */
    name: string;
    /**
     * The partial result of the `InsertMany` operation that was performed. This is *always* defined, and is the result
     * of all successful insertions.
     */
    readonly partialResult: CollectionInsertManyResult<SomeDoc>;
}

/**
 * Options for an `insertMany` command on a collection.
 *
 * The parameters depend on the `ordered` option. If `ordered` is `true`, the `parallel` option is not allowed.
 *
 * @field ordered - If `true`, the docs are inserted sequentially; else, they're arbitrary inserted in parallel.
 * @field concurrency - The maximum number of concurrent requests to make at once.
 * @field chunkSize - The number of documents to upload per request. Defaults to 50.
 * @field timeout - The timeout override for this method
 *
 * @see Collection.insertMany
 *
 * @public
 */
export declare type CollectionInsertManyOptions = GenericInsertManyOptions;

/**
 * Represents the result of an `insertMany` command on a collection.
 *
 * @field insertedIds - The IDs of the inserted documents.
 * @field insertedCount - The number of inserted documents.
 *
 * @see Collection.insertMany
 *
 * @public
 */
export declare interface CollectionInsertManyResult<RSchema> {
    /**
     * The IDs of the inserted documents (including the autogenerated IDs).
     *
     * Note that it is up to the user that the IDs cover all possible types of IDs that the collection may have,
     * keeping in mind the type of the auto-generated IDs, as well as any the user may provide.
     */
    insertedIds: IdOf<RSchema>[];
    /**
     * The number of inserted documents (equals `insertedIds.length`).
     */
    insertedCount: number;
}

/**
 * Represents the result of an `insertOne` command on collection.
 *
 * @field insertedId - The ID of the inserted document.
 *
 * @see Collection.insertOne
 *
 * @public
 */
export declare interface CollectionInsertOneResult<RSchema> {
    /**
     * The ID of the inserted document (this will be an autogenerated ID if one was not provided).
     *
     * Note that it is up to the user that the ID covers all possible types of IDs that the collection may have,
     * keeping in mind the type of the auto-generated IDs, as well as any the user may provide.
     */
    insertedId: IdOf<RSchema>;
}

/**
 * Weaker version of StrictNumberUpdate which allows for more flexibility in typing number update operations.
 *
 * @public
 */
export declare type CollectionNumberUpdate<Schema> = {
    [K in keyof Schema as IsNum<Schema[K]> extends true ? K : never]?: number | bigint;
};

/**
 * Options for spawning a new `Collection` instance through {@link db.collection} or {@link db.createCollection}.
 *
 * Note that these are not all the options available for when you're actually creating a table—see {@link CreateCollectionOptions} for that.
 *
 * @field embeddingApiKey - The embedding service's API-key/headers (for $vectorize)
 * @field timeoutDefaults - Default timeouts for all collection operations
 * @field logging - Logging configuration overrides
 * @field serdes - Additional serialization/deserialization configuration
 *
 * @public
 */
export declare interface CollectionOptions extends WithKeyspace {
    /**
     * The API key for the embedding service to use, or the {@link EmbeddingHeadersProvider} if using
     * a provider that requires it (e.g. AWS bedrock).
     */
    embeddingApiKey?: string | EmbeddingHeadersProvider | null;
    /**
     * The configuration for logging events emitted by the {@link DataAPIClient}.
     *
     * This can be set at any level of the major class hierarchy, and will be inherited by all child classes.
     *
     * See {@link DataAPILoggingConfig} for *much* more information on configuration, outputs, and inheritance.
     */
    logging?: DataAPILoggingConfig;
    /**
     * Advanced & currently somewhat unstable features related to customizing the collection's ser/des behavior at a lower level.
     *
     * Use with caution. See official DataStax documentation for more info.
     *
     * @beta
     */
    serdes?: CollectionSerDesConfig;
    /**
     * ##### Overview
     *
     * The default timeout options for any operation performed on this {@link Collection} instance.
     *
     * See {@link TimeoutDescriptor} for much more information about timeouts.
     *
     * @example
     * ```ts
     * // The request timeout for all operations is set to 1000ms.
     * const client = new DataAPIClient('...', {
     *   timeoutDefaults: { requestTimeoutMs: 1000 },
     * });
     *
     * // The request timeout for all operations borne from this Db is set to 2000ms.
     * const db = client.db('...', {
     *   timeoutDefaults: { requestTimeoutMs: 2000 },
     * });
     * ```
     *
     * ##### Inheritance
     *
     * The timeout options are inherited by all child classes, and can be overridden at any level, including the individual method level.
     *
     * Individual-method-level overrides can vary in behavior depending on the method; again, see {@link TimeoutDescriptor}.
     *
     * ##### Defaults
     *
     * The default timeout options are as follows:
     * - `requestTimeoutMs`: 10000
     * - `generalMethodTimeoutMs`: 30000
     * - `collectionAdminTimeoutMs`: 60000
     * - `tableAdminTimeoutMs`: 30000
     * - `databaseAdminTimeoutMs`: 600000
     * - `keyspaceAdminTimeoutMs`: 30000
     *
     * @see TimeoutDescriptor
     */
    timeoutDefaults?: Partial<TimeoutDescriptor>;
}

/**
 * Weaker version os StrictPop which allows for more flexibility in typing pop operations.
 *
 * @public
 */
export declare type CollectionPop<Schema> = {
    [K in keyof CollectionArrayUpdate<Schema>]?: number;
};

/**
 * Weaker version of StrictPush which allows for more flexibility in typing push operations.
 *
 * @public
 */
export declare type CollectionPush<Schema> = {
    [K in keyof CollectionArrayUpdate<Schema>]?: (CollectionArrayUpdate<Schema>[K] | {
        $each: CollectionArrayUpdate<Schema>[K][];
        $position?: number;
    });
};

/**
 * Represents the options for the `replaceOne` command.
 *
 * @field upsert - If true, perform an insert if no documents match the filter.
 * @field sort - The sort order to pick which document to replace if the filter selects multiple documents.
 * @field timeout - The timeout override for this method
 *
 * @see Collection.replaceOne
 *
 * @public
 */
export declare type CollectionReplaceOneOptions = GenericReplaceOneOptions;

/**
 * Represents the result of a replaceOne operation.
 *
 * @example
 * ```typescript
 * const result = await collection.replaceOne({
 *   _id: 'abc'
 * }, {
 *   name: 'John'
 * }, {
 *   upsert: true
 * });
 *
 * if (result.upsertedCount) {
 *   console.log(`Document with ID ${result.upsertedId} was upserted`);
 * }
 * ```
 *
 * @field matchedCount - The number of documents that matched the filter.
 * @field modifiedCount - The number of documents that were actually modified.
 * @field upsertedCount - The number of documents that were upserted.
 * @field upsertedId - The identifier of the upserted document if `upsertedCount > 0`.
 *
 * @see Collection.replaceOne
 *
 * @public
 */
export declare type CollectionReplaceOneResult<RSchema> = GenericUpdateResult<IdOf<RSchema>, 0 | 1>;

/**
 * @public
 */
export declare interface CollectionSerDesConfig extends BaseSerDesConfig<CollCodecs, CollCodecSerDesFns, CollSerCtx, CollDesCtx> {
    enableBigNumbers?: boolean;
    codecs?: CollCodecs[];
}

/**
 * Represents the update filter to specify how to update a document.
 *
 * **If you want stricter type-checking and full auto-complete, see {@link StrictCollectionUpdateFilter}.**
 *
 * This is a more relaxed version of {@link StrictCollectionUpdateFilter} that doesn't type-check nested fields.
 *
 * @example
 * ```typescript
 * const updateFilter: UpdateFilter<SomeDoc> = {
 *   $set: {
 *     'customer.name': 'Jim B.'
 *   },
 *   $unset: {
 *     'customer.phone': ''
 *   },
 *   $inc: {
 *     'customer.age': 1
 *   },
 * }
 * ```
 *
 * @field $set - Set the value of a field in the document.
 * @field $setOnInsert - Set the value of a field in the document if an upsert is performed.
 * @field $unset - Remove the field from the document.
 * @field $inc - Increment the value of a field in the document.
 * @field $push - Add an element to an array field in the document.
 * @field $pop - Remove an element from an array field in the document.
 * @field $rename - Rename a field in the document.
 * @field $currentDate - Set the value of a field to the current date.
 * @field $min - Only update the field if the specified value is less than the existing value.
 * @field $max - Only update the field if the specified value is greater than the existing value.
 * @field $mul - Multiply the value of a field in the document.
 * @field $addToSet - Add an element to an array field in the document if it does not already exist.
 *
 * @public
 */
export declare interface CollectionUpdateFilter<Schema extends SomeDoc> {
    /**
     * Set the value of a field in the document.
     *
     * @example
     * ```typescript
     * const updateFilter: UpdateFilter<SomeDoc> = {
     *   $set: {
     *     'customer.name': 'Jim B.'
     *   }
     * }
     * ```
     */
    $set?: Partial<Schema> & SomeDoc;
    /**
     * Set the value of a field in the document if an upsert is performed.
     *
     * @example
     * ```typescript
     * const updateFilter: UpdateFilter<SomeDoc> = {
     *   $setOnInsert: {
     *     'customer.name': 'Jim B.'
     *   }
     * }
     * ```
     */
    $setOnInsert?: Partial<Schema> & SomeDoc;
    /**
     * Remove the field from the document.
     *
     * @example
     * ```typescript
     * const updateFilter: UpdateFilter<SomeDoc> = {
     *   $unset: {
     *     'customer.phone': ''
     *   }
     * }
     * ```
     */
    $unset?: Record<string, '' | true | 1>;
    /**
     * Increment the value of a field in the document if it's potentially a `number`.
     *
     * @example
     * ```typescript
     * const updateFilter: UpdateFilter<SomeDoc> = {
     *   $inc: {
     *     'customer.age': 1
     *   }
     * }
     * ```
     */
    $inc?: CollectionNumberUpdate<Schema> & Record<string, number>;
    /**
     * Add an element to an array field in the document.
     *
     * @example
     * ```typescript
     * const updateFilter: UpdateFilter<SomeDoc> = {
     *   $push: {
     *     'items': 'Extended warranty - 5 years'
     *   }
     * }
     * ```
     */
    $push?: CollectionPush<Schema> & SomeDoc;
    /**
     * Remove an element from an array field in the document.
     *
     * @example
     * ```typescript
     * const updateFilter: UpdateFilter<SomeDoc> = {
     *   $pop: {
     *     'items': -1
     *   }
     * }
     * ```
     */
    $pop?: CollectionPop<Schema> & Record<string, number>;
    /**
     * Rename a field in the document.
     *
     * @example
     * ```typescript
     * const updateFilter: UpdateFilter<SomeDoc> = {
     *   $rename: {
     *     'customer.name': 'client.name'
     *   }
     * }
     * ```
     */
    $rename?: Record<string, string>;
    /**
     * Set the value of a field to the current date.
     *
     * @example
     * ```typescript
     * const updateFilter: UpdateFilter<SomeDoc> = {
     *   $currentDate: {
     *     'purchase_date': true
     *   }
     * }
     * ```
     */
    $currentDate?: CollectionCurrentDate<Schema> & Record<string, boolean>;
    /**
     * Only update the field if the specified value is less than the existing value.
     *
     * @example
     * ```typescript
     * const updateFilter: UpdateFilter<SomeDoc> = {
     *   $min: {
     *     'customer.age': 18
     *   }
     * }
     * ```
     */
    $min?: (CollectionNumberUpdate<Schema> | CollectionDateUpdate<Schema>) & Record<string, number | bigint | Date | {
        $date: number;
    }>;
    /**
     * Only update the field if the specified value is greater than the existing value.
     *
     * @example
     * ```typescript
     * const updateFilter: UpdateFilter<SomeDoc> = {
     *   $max: {
     *     'customer.age': 65
     *   }
     * }
     * ```
     */
    $max?: (CollectionNumberUpdate<Schema> | CollectionDateUpdate<Schema>) & Record<string, number | bigint | Date | {
        $date: number;
    }>;
    /**
     * Multiply the value of a field in the document.
     *
     * @example
     * ```typescript
     * const updateFilter: UpdateFilter<SomeDoc> = {
     *   $mul: {
     *     'customer.age': 1.1
     *   }
     * }
     * ```
     */
    $mul?: CollectionNumberUpdate<Schema> & Record<string, number>;
    /**
     * Add an element to an array field in the document if it does not already exist.
     *
     * @example
     * ```typescript
     * const updateFilter: UpdateFilter<SomeDoc> = {
     *   $addToSet: {
     *     'items': 'Extended warranty - 5 years'
     *   }
     * }
     * ```
     */
    $addToSet?: CollectionPush<Schema> & SomeDoc;
}

/**
 * Represents an error that occurred during an `updateMany` operation (which is, generally, paginated).
 *
 * Contains the number of documents that were successfully matched and/or modified, as well as the cumulative errors
 * that occurred during the operation.
 *
 * @field message - A human-readable message describing the *first* error
 * @field errorDescriptors - A list of error descriptors representing the individual errors returned by the API
 * @field detailedErrorDescriptors - A list of errors 1:1 with the number of errorful API requests made to the server.
 * @field partialResult - The partial result of the `UpdateMany` operation that was performed
 *
 * @public
 */
export declare class CollectionUpdateManyError extends CumulativeOperationError {
    /**
     * The name of the error. This is always 'UpdateManyError'.
     */
    name: string;
    /**
     * The partial result of the `UpdateMany` operation that was performed. This is *always* defined, and is the result
     * of the operation up to the point of the first error.
     */
    readonly partialResult: CollectionUpdateManyResult<SomeDoc>;
}

/**
 Options for an `updateMany` command on a collection.
 *
 * @field upsert - If true, perform an insert if no documents match the filter.
 * @field timeout - The timeout override for this method
 *
 * @see Collection.updateMany
 *
 * @public
 */
export declare type CollectionUpdateManyOptions = GenericUpdateManyOptions;

/**
 * Represents the result of an `updateMany` command on a collection.
 *
 * @example
 * ```typescript
 * const result = await collections.updateMany({
 *   name: 'Jane',
 * }, {
 *   $set: { name: 'John' }
 * }, {
 *   upsert: true
 * });
 *
 * if (result.upsertedCount) {
 *   console.log(`Document with ID ${JSON.stringify(result.upsertedId)} was upserted`);
 * }
 * ```
 *
 * @field matchedCount - The number of documents that matched the filter.
 * @field modifiedCount - The number of documents that were actually modified.
 * @field upsertedCount - The number of documents that were upserted.
 * @field upsertedId - The identifier of the upserted document if `upsertedCount > 0`.
 *
 * @see Collection.updateMany
 *
 * @public
 */
export declare type CollectionUpdateManyResult<RSchema> = GenericUpdateResult<IdOf<RSchema>, number>;

/**
 * Options for an `updateOne` command on a collection.
 *
 * @field upsert - If true, perform an insert if no documents match the filter.
 * @field sort - The sort order to pick which document to update if the filter selects multiple documents.
 * @field timeout - The timeout override for this method
 *
 * @see Collection.updateOne
 *
 * @public
 */
export declare type CollectionUpdateOneOptions = GenericUpdateOneOptions;

/**
 * Represents the result of an `updateOne` command on a collection.
 *
 * @example
 * ```typescript
 * const result = await collection.updateOne({
 *   _id: 'abc'
 * }, {
 *   $set: { name: 'John' }
 * }, {
 *   upsert: true
 * });
 *
 * if (result.upsertedCount) {
 *   console.log(`Document with ID ${JSON.stringify(result.upsertedId)} was upserted`);
 * }
 * ```
 *
 * @field matchedCount - The number of documents that matched the filter.
 * @field modifiedCount - The number of documents that were actually modified.
 * @field upsertedCount - The number of documents that were upserted.
 * @field upsertedId - The identifier of the upserted document if `upsertedCount > 0`.
 *
 * @see Collection.updateOne
 *
 * @public
 */
export declare type CollectionUpdateOneResult<RSchema> = GenericUpdateResult<IdOf<RSchema>, 0 | 1>;

/**
 * Represents the options for the vector search.
 *
 * @field dimension - The dimension of the vectors.
 * @field metric - The similarity metric to use for the vector search.
 * @field service - Options related to configuring the automatic embedding service (vectorize)
 *
 * @public
 */
export declare interface CollectionVectorOptions {
    /**
     * The dimension of the vectors stored in the collections.
     *
     * If `service` is not provided, this must be set. Otherwise, the necessity of this being set comes on a per-model
     * basis:
     * - Some models have default vector dimensions which may be flexibly modified
     * - Some models have no default dimension, and must be given an explicit one
     * - Some models require a specific dimension that's already set by default
     *
     * You can find out more information about each model in the [DataStax docs](https://docs.datastax.com/en/astra-db-serverless/databases/embedding-generation.html),
     * or through {@link DbAdmin.findEmbeddingProviders}.
     */
    dimension?: number;
    /**
     * The similarity metric to use for the vector search.
     *
     * See [intro to vector databases](https://docs.datastax.com/en/astra/astra-db-vector/get-started/concepts.html#metrics) for more details.
     */
    metric?: 'cosine' | 'euclidean' | 'dot_product';
    /**
     * The options for defining the embedding service used for vectorize, to automatically transform your
     * text into a vector ready for semantic vector searching.
     *
     * You can find out more information about each provider/model in the [DataStax docs](https://docs.datastax.com/en/astra-db-serverless/databases/embedding-generation.html),
     * or through {@link DbAdmin.findEmbeddingProviders}.
     */
    service?: VectorizeServiceOptions;
    /**
     * Configures the index with the fastest settings for a given source of embeddings vectors.
     *
     * As of time of writing, example `sourceModel`s include `'openai-v3-large'`, `'cohere-v3'`, `'bert'`, and a handful of others.
     *
     * If no source model if provided, this setting will default to `'other'`.
     */
    sourceModel?: string;
}

/**
 * @public
 */
export declare type CollSerCtx = BaseSerCtx<CollCodecSerDesFns>;

declare type Cols2CqlTypes<Columns extends CreateTableColumnDefinitions> = {
    -readonly [P in keyof Columns]: CqlType2TSType<PickCqlType<Columns[P]>, Columns[P]>;
};

/**
 * Common base class for all command events.
 *
 * **Note that these emit *real* commands, not any abstracted commands like "insertMany" or "updateMany",
 * which may be split into multiple of those commands under the hood.**
 *
 * @public
 */
export declare abstract class CommandEvent extends DataAPIClientEvent {
    /**
     * The command object. Equal to the response body of the HTTP request.
     *
     * Note that this is the actual raw command object; it's not necessarily 1:1 with methods called on the collection/db.
     *
     * @example
     * ```typescript
     * {
     *   insertOne: { document: { name: 'John' } }
     * }
     * ```
     */
    readonly command: Record<string, any>;
    /**
     * The keyspace the command is being run in.
     */
    readonly keyspace: string;
    /**
     * The table/collection the command is being run on, if applicable.
     */
    readonly source?: string;
    /**
     * The command name.
     *
     * This is the key of the command object. For example, if the command object is
     * `{ insertOne: { document: { name: 'John' } } }`, the command name is `insertOne`.
     */
    readonly commandName: string;
    /**
     * The URL the command is being sent to.
     */
    readonly url: string;
    /* Excluded from this release type: __constructor */
    /* Excluded from this release type: _desc */
}

/**
 * The events emitted by the {@link DataAPIClient}. These events are emitted at various stages of the
 * command's lifecycle. Intended for use for monitoring and logging purposes.
 *
 * **Note that these emit *real* commands, not any abstracted commands like "insertMany" or "updateMany",
 * which may be split into multiple of those commands under the hood.**
 *
 * @public
 */
export declare type CommandEventMap = {
    /**
     * Emitted when a command is started, before the initial HTTP request is made.
     */
    commandStarted: (event: CommandStartedEvent) => void;
    /**
     * Emitted when a command has succeeded.
     */
    commandSucceeded: (event: CommandSucceededEvent) => void;
    /**
     * Emitted when a command has errored.
     */
    commandFailed: (event: CommandFailedEvent) => void;
    /**
     * Emitted when a command has warnings.
     */
    commandWarnings: (event: CommandWarningsEvent) => void;
};

/**
 * Emitted when a command has errored.
 *
 * **Note that these emit *real* commands, not any abstracted commands like "insertMany" or "updateMany",
 * which may be split into multiple of those commands under the hood.**
 *
 * See {@link CommandEvent} for more information about all the common properties available on this event.
 *
 * @public
 */
export declare class CommandFailedEvent extends CommandEvent {
    /**
     * The duration of the command, in milliseconds.
     */
    readonly duration: number;
    /**
     * The error that caused the command to fail.
     *
     * Typically, some {@link DataAPIError}, commonly a {@link DataAPIResponseError} or one of its subclasses.
     */
    readonly error: Error;
    /* Excluded from this release type: __constructor */
    /**
     * Formats the warnings into a human-readable string.
     */
    formatted(): string;
}

/**
 * Emitted when a command is started, before the initial HTTP request is made.
 *
 * **Note that these emit *real* commands, not any abstracted commands like "insertMany" or "updateMany",
 * which may be split into multiple of those commands under the hood.**
 *
 * See {@link CommandEvent} for more information about all the common properties available on this event.
 *
 * @public
 */
export declare class CommandStartedEvent extends CommandEvent {
    /**
     * The timeout for the command, in milliseconds.
     */
    readonly timeout: Partial<TimeoutDescriptor>;
    /* Excluded from this release type: __constructor */
    /**
     * Formats the warnings into a human-readable string.
     */
    formatted(): string;
}

/**
 * Emitted when a command has succeeded.
 *
 * **Note that these emit *real* commands, not any abstracted commands like "insertMany" or "updateMany",
 * which may be split into multiple of those commands under the hood.**
 *
 * See {@link CommandEvent} for more information about all the common properties available on this event.
 *
 * @public
 */
export declare class CommandSucceededEvent extends CommandEvent {
    /**
     * The duration of the command, in milliseconds. Starts counting from the moment of the initial HTTP request.
     */
    readonly duration: number;
    /**
     * The response object from the Data API.
     */
    readonly resp?: RawDataAPIResponse;
    /* Excluded from this release type: __constructor */
    /**
     * Formats the warnings into a human-readable string.
     */
    formatted(): string;
}

/**
 * Event emitted when the Data API returned a warning for some command.
 *
 * See {@link CommandEvent} for more information about all the common properties available on this event.
 *
 * @public
 */
export declare class CommandWarningsEvent extends CommandEvent {
    /**
     * The warnings that occurred.
     */
    readonly warnings: DataAPIErrorDescriptor[];
    /* Excluded from this release type: __constructor */
    /**
     * Formats the warnings into a human-readable string.
     */
    formatted(): string;
}

declare interface ConsoleLike {
    log: (...args: any[]) => void;
    error: (...args: any[]) => void;
}

declare type ContainsDate<Schema> = IsDate<Schema[keyof Schema]>;

declare interface CqlGenericType2TSTypeDict<Def> {
    map: CqlMapType2TsType<Def>;
    list: CqlListType2TsType<Def>;
    set: CqlSetType2TsType<Def>;
    vector: CqlVectorType2TsType<Def> | null;
}

declare type CqlListType2TsType<Def> = Def extends {
    valueType: infer ValueType extends string;
} ? Array<CqlType2TSType<ValueType, never> & {}> : TypeErr<'Invalid generics definition for \'list\'; should have valueType set as scalar CQL types (e.g. \'text\')'>;

declare type CqlMapType2TsType<Def> = Def extends {
    keyType: infer KeyType extends string;
    valueType: infer ValueType extends string;
} ? Map<CqlType2TSType<KeyType, never> & {}, CqlType2TSType<ValueType, never> & {}> : TypeErr<'Invalid generics definition for \'map\'; should have keyType and valueType set as scalar CQL types (e.g. \'text\')'>;

declare interface CqlNonGenericType2TSTypeDict {
    ascii: string | null;
    bigint: number | null;
    blob: DataAPIBlob | null;
    boolean: boolean | null;
    date: DataAPIDate | null;
    decimal: BigNumber | null;
    double: number | null;
    duration: DataAPIDuration | null;
    float: number | null;
    int: number | null;
    inet: InetAddress | null;
    smallint: number | null;
    text: string | null;
    time: DataAPITime | null;
    timestamp: DataAPITimestamp | null;
    tinyint: number | null;
    uuid: UUID | null;
    varchar: string | null;
    varint: bigint | null;
}

declare type CqlSetType2TsType<Def> = Def extends {
    valueType: infer ValueType extends string;
} ? Set<CqlType2TSType<ValueType, never> & {}> : TypeErr<'Invalid generics definition for \'set\'; should have valueType set as scalar CQL types (e.g. \'text\')'>;

/**
 * Converts a CQL type to its TS equivalent. If the type isn't some collection type, the second typeparam is
 * irrelevant.
 *
 * @example
 * ```ts
 * // number
 * CqlType2TSType<'int', ...>
 *
 * // DataAPIDuration
 * CqlType2TSType<'duration', ...>
 *
 * // Map<string, number>
 * CqlType2TSType<'map', { keyType: 'text', valueType: 'int' }>
 *
 * // unknown
 * CqlType2TSType<'idk', ...>
 *
 * // TypeErr<'Invalid generics definition for \'map\'; should have keyType and valueType set as scalar CQL types (e.g. \'text\')'>
 * CqlType2TSType<'map', 123>
 * ```
 *
 * @see InferTableSchema
 * @see InferTablePrimaryKey
 *
 * @public
 */
export declare type CqlType2TSType<T extends string, Def> = T extends keyof CqlNonGenericType2TSTypeDict ? CqlNonGenericType2TSTypeDict[T] : T extends keyof CqlGenericType2TSTypeDict<Def> ? CqlGenericType2TSTypeDict<Def>[T] : unknown;

declare type CqlVectorType2TsType<Def> = Def extends {
    service: unknown;
} ? DataAPIVector | string : DataAPIVector;

/**
 * Represents the options for creating a database (i.e. blocking options + timeout options + database spawn options).
 *
 * @public
 */
export declare type CreateAstraDatabaseOptions = AstraAdminBlockingOptions & WithTimeout<'databaseAdminTimeoutMs'> & {
    /**
     * Any options to override the default options set when creating the root {@link DataAPIClient}.
     */
    dbOptions?: DbOptions;
};

/**
 * Options for creating a new collection (via {@link Db.createCollection}).
 *
 * See {@link Db.createCollection} & {@link Collection} for more information.
 *
 * @field vector - The vector configuration for the collections.
 * @field indexing - The indexing configuration for the collections.
 * @field defaultId - The default ID for the collections.
 * @field keyspace - Overrides the keyspace for the collections.
 * @field timeout - The timeout override for this method
 *
 * @see Db.createCollection
 *
 * @public
 */
export declare interface CreateCollectionOptions<Schema extends SomeDoc> extends CollectionDefinition<Schema>, CollectionOptions {
    timeout?: number | Pick<Partial<TimeoutDescriptor>, 'collectionAdminTimeoutMs'>;
}

/**
 * @public
 */
export declare type CreateTableColumnDefinitions = Record<string, LooseCreateTableColumnDefinition | StrictCreateTableColumnDefinition>;

/**
 * The definition for creating a new table through the Data API, using a bespoke schema definition syntax.
 *
 * See {@link Db.createTable} for more info.
 *
 * @public
 */
export declare interface CreateTableDefinition {
    /**
     * The columns to create in the table.
     */
    readonly columns: CreateTableColumnDefinitions;
    /**
     * The primary key definition for the table.
     */
    readonly primaryKey: CreateTablePrimaryKeyDefinition;
}

/**
 * Options for creating a new index via {@link Table.createIndex}
 *
 * @public
 */
export declare interface CreateTableIndexOptions extends WithTimeout<'tableAdminTimeoutMs'> {
    /**
     * Options available for `text` and `ascii` indexes
     */
    options?: TableIndexOptions;
    /**
     * If `true`, no error will be thrown if the index already exists.
     *
     * Note that this does not check if the existing index is the same as the one attempting to be created; it simply
     * checks if the name is already in use.
     */
    ifNotExists?: boolean;
}

/**
 * Options for creating a new table (via {@link Db.createTable}).
 *
 * See {@link Db.createTable} & {@link Table} for more information.
 *
 * @field definition - The bespoke columns/primary-key definition for the table.
 * @field ifNotExists - Makes operation a no-op if the table already exists.
 * @field keyspace - Overrides the keyspace for the table (from the `Db`'s working keyspace).
 * @field embeddingApiKey - The embedding service's API-key/headers (for $vectorize)
 * @field timeoutDefaults - Default timeouts for all table operations
 * @field logging - Logging configuration overrides
 * @field serdes - Additional serialization/deserialization configuration
 * @field timeout - The timeout override for this method
 *
 * @public
 */
export declare interface CreateTableOptions<Def extends CreateTableDefinition = CreateTableDefinition> extends WithTimeout<'tableAdminTimeoutMs'>, TableOptions {
    definition: Def;
    ifNotExists?: boolean;
}

/**
 * @public
 */
export declare type CreateTablePrimaryKeyDefinition = ShortCreateTablePrimaryKeyDefinition | FullCreateTablePrimaryKeyDefinition;

/**
 * Options for creating a new index via {@link Table.createVectorIndex}
 *
 * @public
 */
export declare interface CreateTableVectorIndexOptions extends WithTimeout<'tableAdminTimeoutMs'> {
    /**
     * Options available for the vector index.
     */
    options?: TableVectorIndexOptions;
    /**
     * If `true`, no error will be thrown if the index already exists.
     *
     * Note that this does not check if the existing index is the same as the one attempting to be created; it simply
     * checks if the name is already in use.
     */
    ifNotExists?: boolean;
}

declare type CropTrailingDot<Str extends string> = Str extends `${infer T}.` ? T : Str;

/**
 * An abstract class representing an exception that occurred due to a *cumulative* operation on the Data API. This is
 * the base class for all Data API errors that represent a paginated operation, such as `insertMany`, `deleteMany`, and
 * `updateMany`, and will never be thrown directly.
 *
 * Useful for `instanceof` checks.
 *
 * This is *only* for Data API related errors, such as a non-existent collections, or a duplicate key error. It
 * is *not*, however, for errors such as an HTTP network error, or a malformed request. The exception being timeouts,
 * which are represented by the {@link DataAPITimeoutError} class.
 *
 * @field message - A human-readable message describing the *first* error
 * @field errorDescriptors - A list of error descriptors representing the individual errors returned by the API
 * @field detailedErrorDescriptors - A list of errors 1:1 with the number of errorful API requests made to the server.
 * @field partialResult - The partial result of the operation that was performed
 *
 * @public
 */
export declare abstract class CumulativeOperationError extends DataAPIResponseError {
    /**
     * The partial result of the operation that was performed. This is *always* defined, and is
     * the result of the operation up to the point of the first error. For example, if you're inserting 100 documents
     * ordered and the 50th document fails, the `partialResult` will contain the first 49 documents that were
     * successfully inserted.
     */
    readonly partialResult: unknown;
}

/**
 * An exception that may be thrown whenever something goes wrong with a cursor.
 *
 * @public
 */
export declare class CursorError extends DataAPIError {
    /**
     * The underlying cursor which caused this error.
     */
    readonly cursor: FindCursor<unknown>;
    /**
     * The state of the cursor when the error occurred.
     */
    readonly state: FindCursorStatus;
    /* Excluded from this release type: __constructor */
}

/**
 * @public
 */
export declare type CustomGuardCodec<Fns extends CodecSerDesFns> = Fns & {
    codecType: 'type';
    type: string;
    serializeGuard: (value: unknown, ctx: BaseSerCtx<Fns>) => boolean;
};

/**
 * Allows you to use a custom http client for making HTTP requests, rather than the default or fetch API.
 *
 * Just requires the implementation of a simple adapter interface.
 *
 * See the `astra-db-ts` README for more information on different clients.
 *
 * https://github.com/datastax/astra-db-ts
 *
 * @public
 */
export declare interface CustomHttpClientOptions {
    /**
     * Use a custom http client for making HTTP requests.
     */
    client: 'custom';
    /**
     * The custom "fetcher" to use.
     */
    fetcher: Fetcher;
}

/**
 * Represents a `blob` column for Data API tables.
 *
 * See {@link DataAPIBlobLike} for the types that can be converted into a `DataAPIBlob`.
 *
 * You may use the {@link blob} function as a shorthand for creating a new `DataAPIBlob`.
 *
 * See the official DataStax documentation for more information.
 *
 * @public
 */
export declare class DataAPIBlob implements TableCodec<typeof DataAPIBlob> {
    #private;
    /**
     * Implementation of `$SerializeForTable` for {@link TableCodec}
     */
    [$SerializeForTable](ctx: TableSerCtx): readonly [0, ({
        $binary: string;
    } | undefined)?];
    /**
     * Implementation of `$DeserializeForTable` for {@link TableCodec}
     */
    static [$DeserializeForTable](value: any, ctx: TableDesCtx): readonly [0, (DataAPIBlob | undefined)?];
    /**
     * Creates a new `DataAPIBlob` instance from a blob-like value.
     *
     * You can set `validate` to `false` to bypass any validation if you're confident the value is a valid blob.
     *
     * @param blob - The blob-like value to convert to a `DataAPIBlob`
     * @param validate - Whether to validate the blob-like value (default: `true`)
     *
     * @throws TypeError If `blob` is not a valid blob-like value
     */
    constructor(blob: DataAPIBlobLike, validate?: boolean);
    /**
     * Gets the byte length of the blob, agnostic of the underlying type.
     *
     * @returns The byte length of the blob
     */
    get byteLength(): number;
    /**
     * Gets the raw underlying implementation of the blob.
     *
     * @returns The raw blob
     */
    raw(): Exclude<DataAPIBlobLike, DataAPIBlob>;
    /**
     * Returns the blob as an `ArrayBuffer`, converting between types if necessary.
     *
     * @returns The blob as an `ArrayBuffer`
     */
    asArrayBuffer(): ArrayBuffer;
    /**
     * Returns the blob as a `Buffer`, if available, converting between types if necessary.
     *
     * @returns The blob as a `Buffer`
     */
    asBuffer(): Buffer;
    /**
     * Returns the blob as a base64 string, converting between types if necessary.
     *
     * @returns The blob as a base64 string
     */
    asBase64(): string;
    /**
     * Returns a pretty string representation of the `DataAPIBlob`.
     */
    toString(): string;
    /**
     * Determines whether the given value is a blob-like value (i.e. it's {@link DataAPIBlobLike}.
     *
     * @param value - The value to check
     *
     * @returns `true` if the value is a blob-like value; `false` otherwise
     */
    static isBlobLike(value: unknown): value is DataAPIBlobLike;
}

/**
 * Represents any type that can be converted into a {@link DataAPIBlob}
 *
 * @public
 */
export declare type DataAPIBlobLike = DataAPIBlob | ArrayBuffer | Buffer | {
    $binary: string;
};

/**
 * The main entrypoint into working with the Data API. It sits at the top of the
 * [conceptual hierarchy](https://github.com/datastax/astra-db-ts/tree/signature-cleanup?tab=readme-ov-file#abstraction-diagram)
 * of the SDK.
 *
 * The client may take in a default token, which can be overridden by a stronger/weaker token when spawning a new
 * {@link Db} or {@link AstraAdmin} instance.
 *
 * It also takes in a set of default options (see {@link DataAPIClientOptions}) that may also generally be overridden as necessary.
 *
 * **Depending on the Data API backend used, you may need to set the environment option to "dse", "hcd", etc.** See
 * {@link DataAPIEnvironment} for all possible backends. It defaults to "astra".
 *
 * @example
 * ```typescript
 * // Client with default token
 * const client1 = new DataAPIClient('AstraCS:...');
 *
 * // Client with no default token; must provide token in .db() or .admin()
 * const client2 = new DataAPIClient();
 *
 * // Client connecting to a local DSE instance
 * const dseToken = new UsernamePasswordTokenProvider('username', 'password');
 * const client3 = new DataAPIClient(dseToken, { environment: 'dse' });
 *
 * const db1 = client1.db('https://<db_id>-<region>.apps.astra.datastax.com');
 * const db2 = client1.db('<db_id>', '<region>');
 *
 * const coll = await db1.collections('my-collections');
 *
 * const admin1 = client1.admin();
 * const admin2 = client1.admin({ adminToken: '<stronger_token>' });
 *
 * console.log(await coll.insertOne({ name: 'RATATATA' }));
 * console.log(await admin1.listDatabases());
 * ```
 *
 * @public
 *
 * @see DataAPIEnvironment
 */
export declare class DataAPIClient extends DataAPIClientEventEmitterBase {
    #private;
    /**
     * Constructs a new instance of the {@link DataAPIClient} without a default token. The token will instead need to
     * be specified when calling `.db()` or `.admin()`.
     *
     * Prefer this method when using a db-scoped token instead of a more universal token.
     *
     * @example
     * ```typescript
     * const client = new DataAPIClient();
     *
     * // OK
     * const db1 = client.db('<db_id>', '<region>', { token: 'AstraCS:...' });
     *
     * // Will throw error as no token is ever provided
     * const db2 = client.db('<db_id>', '<region>');
     * ```
     *
     * @param options - The default options to use when spawning new instances of {@link Db} or {@link AstraAdmin}.
     */
    constructor(options?: DataAPIClientOptions | nullish);
    /**
     * Constructs a new instance of the {@link DataAPIClient} with a default token. This token will be used everywhere
     * if no overriding token is provided in `.db()` or `.admin()`.
     *
     * Prefer this method when using a universal/admin-scoped token.
     *
     * @example
     * ```typescript
     * const client = new DataAPIClient('<default_token>');
     *
     * // OK
     * const db1 = client.db('<db_id>', '<region>', { token: '<weaker_token>' });
     *
     * // OK; will use <default_token>
     * const db2 = client.db('<db_id>', '<region>');
     * ```
     *
     * @param token - The default token to use when spawning new instances of {@link Db} or {@link AstraAdmin}.
     * @param options - The default options to use when spawning new instances of {@link Db} or {@link AstraAdmin}.
     */
    constructor(token: string | TokenProvider | nullish, options?: DataAPIClientOptions | nullish);
    /**
     * Spawns a new {@link Db} instance using a direct endpoint and given options.
     *
     * **NB. This method does not validate the existence of the database—it simply creates a reference.**
     *
     * This endpoint should include the protocol and the hostname, but not the path. It's typically in the form of
     * `https://<db_id>-<region>.apps.astra.datastax.com`, but it can be used with DSE or any other Data-API-compatible
     * endpoint.
     *
     * The given options will override any default options set when creating the {@link DataAPIClient} through
     * a deep merge (i.e. unset properties in the options object will just default to the default options).
     *
     * @example
     * ```typescript
     * const db1 = client.db('https://<db_id>-<region>.apps.astra.datastax.com');
     *
     * const db2 = client.db('https://<db_id>-<region>.apps.astra.datastax.com', {
     *   keyspace: 'my-keyspace',
     *   useHttp2: false,
     * });
     *
     * const db3 = client.db('https://<db_id>-<region>.apps.astra.datastax.com', {
     *   token: 'AstraCS:...'
     * });
     * ```
     *
     * @remarks
     * Note that this does not perform any IO or validation on if the endpoint is valid or not. It's up to the user to
     * ensure that the endpoint is correct. If you want to create an actual database, see {@link AstraAdmin.createDatabase}
     * instead.
     *
     * @param endpoint - The direct endpoint to use.
     * @param options - Any options to override the default options set when creating the {@link DataAPIClient}.
     *
     * @returns A new {@link Db} instance.
     */
    db(endpoint: string, options?: DbOptions): Db;
    /**
     * Spawns a new {@link AstraAdmin} instance using the given options to work with the DevOps API (for admin
     * work such as creating/managing databases).
     *
     * **NB. This method is only available for Astra databases.**
     *
     * The given options will override any default options set when creating the {@link DataAPIClient} through
     * a deep merge (i.e. unset properties in the options object will just default to the default options).
     *
     * @example
     * ```typescript
     * const admin1 = client.admin();
     * const admin2 = client.admin({ adminToken: '<stronger_token>' });
     *
     * const dbs = await admin1.listDatabases();
     * console.log(dbs);
     * ```
     *
     * @param options - Any options to override the default options set when creating the {@link DataAPIClient}.
     *
     * @returns A new {@link AstraAdmin} instance.
     */
    admin(options?: AdminOptions): AstraAdmin;
    /**
     * Closes the client and disconnects all underlying connections. This should be called when the client is no longer
     * needed to free up resources.
     *
     * The client will be no longer usable after this method is called.
     *
     * @remarks
     * This method is idempotent and can be called multiple times without issue.
     *
     * --
     *
     * For most users, this method isn't necessary to call, as resources will be freed up when the
     * server is shut down or the process is killed. However, it's useful in long-running processes or when you want to
     * free up resources immediately.
     *
     * --
     *
     * Think of it as using malloc or using a file descriptor. Freeing them isn't always strictly necessary for
     * long-running usages, but it's there for when you need it.
     *
     * @returns A promise that resolves when the client has been closed.
     */
    close(): Promise<void>;
    /**
     * Allows for the `await using` syntax (if your typescript version \>= 5.2) to automatically close the client when
     * it's out of scope.
     *
     * Equivalent to wrapping the client usage in a `try`/`finally` block and calling `client.close()` in the `finally`
     * block.
     *
     * @example
     * ```typescript
     * async function main() {
     *   // Will unconditionally close the client when the function exits
     *   await using client = new DataAPIClient('*TOKEN*');
     *
     *   // Using the client as normal
     *   const db = client.db('*ENDPOINT*');
     *   console.log(await db.listCollections());
     *
     *   // Or pass it to another function to run your application
     *   app(client);
     * }
     * main();
     * ```
     *
     * *This will only be defined if the `Symbol.asyncDispose` symbol is actually defined.*
     */
    [Symbol.asyncDispose]: () => Promise<void>;
}

/**
 * The base class of all events that may be emitted/logged by the {@link DataAPIClient}.
 *
 * See {@link DataAPIClientEventMap} & {@link DataAPILoggingConfig} for much more info.
 *
 * @public
 */
export declare abstract class DataAPIClientEvent {
    /**
     * The name of the event.
     */
    readonly name: string;
    /* Excluded from this release type: __constructor */
    /**
     * Returns the event in a formatted string, as it would be logged to stdout/stderr (if enabled).
     */
    formatted(): string;
    /* Excluded from this release type: formattedPrefix */
}

/**
 * The base class for the {@link DataAPIClient} event emitter to make it properly typed.
 *
 * Should never need to be used directly.
 *
 * @public
 */
export declare const DataAPIClientEventEmitterBase: new () => TypedEmitter<DataAPIClientEventMap>;

/**
 * #### Overview
 *
 * The `EventMap` of events the {@link DataAPIClient} emits, which is an instance of {@link TypedEventEmitter}, when
 * events logging is enabled (via `logging` options throughout the major class hierarchy).
 *
 * There are quite a few combinations of ways in which event logging may be enabled in the logging configuration, but
 * there are a few most common ways to do so:
 * - `logging: 'all'` - This will emit all events, but will also log some of them to the console
 * - `logging: [{ events: 'all', emits: 'event' }]` - This will emit all events, without logging any of them to the console
 * - `logging: '<command>'` - This will emit only the events for the specified command, but may also log some of them to the console
 *   - The default behavior for if an event is logged to the console or not varies
 *   - See below section on event types for more info about default behaviors
 *
 * ###### When to prefer events
 *
 * Events can be thought of as a "generic logging interface" for Data API & DevOps operations. Though the {@link DataAPILoggingConfig},
 * you can also enable/disable logging to stdout/stderr, but:
 * - You're forced to use the console as output
 * - You can't programmatically interact with the logs/data
 * - You can't easily filter or format the logs
 *
 * {@link DataAPIClientEventMap} are a more flexible way to interact with the logs, allowing you to basically plug in, or
 * even build, your own logging system around them.
 *
 * And of course, you're free to use both events and console logging in tandem, if you so choose.
 *
 * ###### Disclaimer
 *
 * **Note that these emit *real* commands, not any abstracted commands like "insertMany" or "updateMany",
 * which may be split into multiple of those commands under the hood.**
 *
 * This generally applies to normal command events; no admin command events are abstracted as such.
 *
 * #### Event types
 *
 * There are two major categories of events emitted by the {@link DataAPIClient}:
 * - {@link CommandEventMap} - Events related to the execution of a command
 *   - i.e. `Db`, `Collection`, `Table` operations
 * - {@link AdminCommandEventMap} - Events related to the execution of an admin command
 *   - i.e. `AstraAdmin`, `DbAdmin` operations
 *
 * Every event may be enabled/disabled individually, independent of one another.
 *
 * ###### `commandStarted` ({@link CommandStartedEvent})
 *
 * Emitted when a command is started, before the initial HTTP request is made.
 *
 * Default behavior when logging is enabled (through 'all' or 'commandStarted'):
 * - Emits the event
 * - Does NOT log to the console
 *
 * ###### `commandSucceeded` ({@link CommandSucceededEvent})
 *
 * Emitted when a command has succeeded (i.e. the status code is 200, and no `errors` are returned).
 *
 * Default behavior when logging is enabled (through 'all' or 'commandSucceeded'):
 * - Emits the event
 * - Does NOT log to the console
 *
 * ###### `commandFailed` ({@link CommandFailedEvent})
 *
 * Emitted when a command has errored (i.e. the status code is not 200, or `errors` are returned).
 *
 * Default behavior when logging is enabled (through 'all' or 'commandFailed'):
 * - Emits the event
 * - Logs to stderr
 *
 * ###### `commandWarnings` ({@link CommandWarningsEvent})
 *
 * Emitted when a command has warnings (i.e. when the `status.warnings` field is present).
 *
 * Warnings may be present even if the command has succeeded.
 *
 * Such warnings include updates/deletes without a filter, or using deprecated command aliases.
 *
 * Default behavior when logging is enabled (through 'all' or 'commandWarnings'):
 * - Emits the event
 * - Logs to stderr
 *
 * ###### `adminCommandStarted` ({@link AdminCommandStartedEvent})
 *
 * Emitted when an admin command is started, before the initial HTTP request is made.
 *
 * Default behavior when logging is enabled (through 'all' or 'adminCommandStarted'):
 * - Emits the event
 * - Logs to stdout
 *
 * ###### `adminCommandPolling` ({@link AdminCommandPollingEvent})
 *
 * Emitted when a command is polling in a long-running operation (i.e. {@link AstraAdmin.createDatabase}).
 *
 * **NOTE: this is ONLY emitted when using {@link AstraAdmin} & {@link AstraDbAdmin} methods.** Non-Astra-backends
 * do not yet require any command polling.
 *
 * Frequency of polling depends on the command being run, and whether a custom polling interval was set.
 *
 * Default behavior when logging is enabled (through 'all' or 'adminCommandPolling'):
 * - Emits the event
 * - Logs to stdout
 *
 * ###### `adminCommandSucceeded` ({@link AdminCommandSucceededEvent})
 *
 * Emitted when an admin command has succeeded, after any necessary polling (i.e. when an HTTP 200 is returned).
 *
 * Default behavior when logging is enabled (through 'all' or 'adminCommandSucceeded'):
 * - Emits the event
 * - Logs to stdout
 *
 * ###### `adminCommandFailed` ({@link AdminCommandFailedEvent})
 *
 * Emitted when an admin command has failed (i.e. when an HTTP 4xx/5xx is returned, even if while polling).
 *
 * Default behavior when logging is enabled (through 'all' or 'adminCommandFailed'):
 * - Emits the event
 * - Logs to stderr
 *
 * ###### `adminCommandWarnings` ({@link AdminCommandWarningsEvent})
 *
 * Emitted when an admin command has warnings (i.e. when the `status.warnings` field is present).
 *
 * **NOTE: this is ONLY emitted when using {@link DataAPIDbAdmin} methods.** Astra-backends work using the DevOps API,
 * which does not produce any command warnings.
 *
 * Warnings may be present even if the command has succeeded.
 *
 * Such warnings include using deprecated command aliases, such as those with "namespace" terminology.
 *
 * @example
 * ```ts
 * const client = new DataAPIClient('*TOKEN*', {
 *   logging: [{ events: 'all', emits: 'event' }],
 * });
 * const db = client.db('*ENDPOINT*');
 *
 * client.on('commandStarted', (event) => {
 *   console.log('Command started:', event);
 * });
 *
 * client.on('commandFailed', (event) => {
 *   console.error('Command failed:', event);
 * });
 *
 * client.on('commandSucceeded', (event) => {
 *   console.log('Command succeeded:', event);
 * });
 *
 * // Output:
 * // 'Command started: <...>'
 * // 'Command succeeded: <...>'
 * await db.createCollection('my_collection');
 * ```
 *
 * @see DataAPILoggingConfig
 * @see CommandEventMap
 * @see AdminCommandEventMap
 *
 * @public
 */
export declare type DataAPIClientEventMap = AdminCommandEventMap & CommandEventMap;

/**
 * The default options for the {@link DataAPIClient}. The Data API & DevOps specific options may be overridden
 * when spawning a new instance of their respective classes.
 *
 * @public
 */
export declare interface DataAPIClientOptions {
    /**
     * The configuration for logging events emitted by the {@link DataAPIClient}.
     *
     * This can be set at any level of the major class hierarchy, and will be inherited by all child classes.
     *
     * See {@link DataAPILoggingConfig} for *much* more information on configuration, outputs, and inheritance.
     *
     * **TL;DR: Set `logging: 'all'` for a sane default.**
     */
    logging?: DataAPILoggingConfig;
    /**
     * Sets the Data API "backend" that is being used (e.g. 'dse', 'hcd', 'cassandra', or 'other'). Defaults to 'astra'.
     *
     * Generally, the majority of operations stay the same between backends. However, authentication may differ, and
     * availability of admin operations does as well.
     *
     * - With Astra databases, you'll use an `'AstraCS:...'` token; for other backends, you'll generally want to use the
     *   {@link UsernamePasswordTokenProvider}, or, rarely, even create your own.
     *
     * - {@link AstraAdmin} is only available on Astra databases. {@link AstraDbAdmin} is also only available on Astra
     *   databases, but the {@link DataAPIDbAdmin} alternative is used for all other backends, albeit the expense of a
     *   couple extra features.
     *
     * - Some functions/properties may also not be available on non-Astra backends, such as {@link Db.id} or {@link Db.info}.
     *
     * @remarks
     * No error will be thrown if this is set incorrectly, but bugs may appear in your code, with some operations just
     * throwing errors and refusing to work properly.
     *
     * @defaultValue "astra"
     */
    environment?: DataAPIEnvironment;
    /**
     * The client-wide options related to http operations.
     *
     * There are four different behaviours for setting the client:
     * - Not setting the `httpOptions` at all
     * -- This will attempt to use `fetch-h2` if available, and fall back to `fetch` if not available
     * - `client: 'default'` or `client: undefined` (or unset)
     * -- This will attempt to use `fetch-h2` if available, and throw an error if not available
     * - `client: 'fetch'`
     * -- This will always use the native `fetch` API
     * - `client: 'custom'`
     * -- This will allow you to pass a custom `Fetcher` implementation to the client
     *
     * `fetch-h2` is a fetch implementation that supports HTTP/2, and is the recommended client for the best performance.
     *
     * However, it's generally only available by default on node runtimes; in other environments, you may need to use the
     * native `fetch` API instead, or pass in the fetch-h2 module manually.
     *
     * See the `astra-db-ts` README for more information on different clients.
     *
     * https://github.com/datastax/astra-db-ts
     */
    httpOptions?: DataAPIHttpOptions;
    /**
     * The default options when spawning a {@link Db} instance.
     */
    dbOptions?: RootDbOptions;
    /**
     * The default options when spawning an {@link AstraAdmin} instance.
     */
    adminOptions?: RootAdminOptions;
    /**
     * The caller information to send with requests, of the form `[name, version?]`, or an array of such.
     *
     * **Intended generally for integrations or frameworks that wrap the client.**
     *
     * The caller information is used to identify the client making requests to the server.
     *
     * It will be sent in the headers of the request as such:
     * ```
     * User-Agent: ...<name>/<version> astra-db-ts/<version>
     * ```
     *
     * If no caller information is provided, the client will simply be identified as `astra-db-ts/<version>`.
     *
     * **NB. If providing an array of callers, they should be ordered from most important to least important.**
     * @example
     * ```typescript
     * // 'my-app/1.0.0 astra-db-ts/1.0.0'
     * const client1 = new DataAPIClient('AstraCS:...', {
     *   caller: ['my-app', '1.0.0'],
     * });
     *
     * // 'my-app/1.0.0 my-other-app astra-db-ts/1.0.0'
     * const client2 = new DataAPIClient('AstraCS:...', {
     *   caller: [['my-app', '1.0.0'], ['my-other-app']],
     * });
     * ```
     */
    caller?: OneOrMany<Caller>;
    /**
     * ##### Overview
     *
     * The default timeout options for anything spawned by this {@link DataAPIClient} instance.
     *
     * See {@link TimeoutDescriptor} for much more information about timeouts.
     *
     * @example
     * ```ts
     * // The request timeout for all operations is set to 1000ms.
     * const client = new DataAPIClient('...', {
     *   timeoutDefaults: { requestTimeoutMs: 1000 },
     * });
     *
     * // The request timeout for all operations borne from this Db is set to 2000ms.
     * const db = client.db('...', {
     *   timeoutDefaults: { requestTimeoutMs: 2000 },
     * });
     * ```
     *
     * ##### Inheritance
     *
     * The timeout options are inherited by all child classes, and can be overridden at any level, including the individual method level.
     *
     * Individual-method-level overrides can vary in behavior depending on the method; again, see {@link TimeoutDescriptor}.
     *
     * ##### Defaults
     *
     * The default timeout options are as follows:
     * - `requestTimeoutMs`: 10000
     * - `generalMethodTimeoutMs`: 30000
     * - `collectionAdminTimeoutMs`: 60000
     * - `tableAdminTimeoutMs`: 30000
     * - `databaseAdminTimeoutMs`: 600000
     * - `keyspaceAdminTimeoutMs`: 30000
     *
     * @see TimeoutDescriptor
     */
    timeoutDefaults?: Partial<TimeoutDescriptor>;
}

/**
 * Represents the options for creating a keyspace on a non-Astra database (i.e. blocking options + keyspace creation options).
 *
 * If no replication options are provided, it will default to `'SimpleStrategy'` with a replication factor of `1`.
 *
 * See {@link AstraAdminBlockingOptions} for more options about blocking behavior.
 *
 * If `updateDbKeyspace` is set to true, the underlying `Db` instance used to create the `DbAdmin` will have its
 * current working keyspace set to the newly created keyspace immediately (even if the keyspace isn't technically
 * yet created).
 *
 * @example
 * ```typescript
 * // If using non-astra, this may be a common idiom:
 * const client = new DataAPIClient({ environment: 'dse' });
 * const db = client.db('<endpoint>', { token: '<token>' });
 *
 * // Will internally call `db.useKeyspace('new_keyspace')`
 * await db.admin().createKeyspace('new_keyspace', {
 *   updateDbKeyspace: true,
 * });
 *
 * // Creates collections in keyspace `new_keyspace` by default now
 * const coll = db.createCollection('my_coll');
 * ```
 *
 * @public
 */
export declare interface DataAPICreateKeyspaceOptions extends WithTimeout<'keyspaceAdminTimeoutMs'> {
    replication?: KeyspaceReplicationOptions;
    updateDbKeyspace?: boolean;
}

/**
 * Represents a `date` column for Data API tables.
 *
 * You may use the {@link date} function as a shorthand for creating a new `DataAPIDate`.
 *
 * See the official DataStax documentation for more information.
 *
 * @public
 */
export declare class DataAPIDate implements TableCodec<typeof DataAPIDate> {
    #private;
    /**
     * Implementation of `$SerializeForTable` for {@link TableCodec}
     */
    [$SerializeForTable](ctx: TableSerCtx): readonly [0, (string | undefined)?];
    /**
     * Implementation of `$DeserializeForTable` for {@link TableCodec}
     */
    static [$DeserializeForTable](value: any, ctx: TableDesCtx): readonly [0, (DataAPIDate | undefined)?];
    /**
     * Creates a new `DataAPIVector` instance from various formats.
     *
     * @param input - The input to create the `DataAPIDate` from
     */
    constructor(input?: string | Date | DataAPIDateComponents);
    /**
     * Returns the {@link DataAPIDateComponents} that make up this `DataAPIDate`
     *
     * @returns The components of the date
     */
    components(): DataAPIDateComponents;
    /**
     * Converts this `DataAPIDate` to a `Date` object
     *
     * If no `base` date/time is provided to use the time from, the time component is set to be the current time.
     *
     * @param base - The base date/time to use for the time component
     *
     * @returns The `Date` object representing this `DataAPIDate`
     */
    toDate(base?: Date | DataAPITime | DataAPITimestamp): Date;
    /**
     * Returns the string representation of this `DataAPIDate`
     *
     * @returns The string representation of this `DataAPIDate`
     */
    toString(): string;
}

/**
 * Represents the time components that make up a `DataAPIDate`
 *
 * @public
 */
export declare interface DataAPIDateComponents {
    /**
     * The year of the date
     */
    year: number;
    /**
     * The month of the date (should be between 1 and 12)
     */
    month: number;
    /**
     * The day of the month
     */
    date: number;
}

/**
 * An administrative class for managing non-Astra databases, including creating, listing, and deleting keyspaces.
 *
 * **Shouldn't be instantiated directly; use {@link Db.admin} to obtain an instance of this class.**
 *
 * **Note that the `environment` parameter MUST match the one used in the `DataAPIClient` options.**
 *
 * @example
 * ```typescript
 * const client = new DataAPIClient('*TOKEN*');
 *
 * // Create an admin instance through a Db
 * const db = client.db('*ENDPOINT*');
 * const dbAdmin1 = db.admin({ environment: 'dse' });
 * const dbAdmin2 = db.admin({ environment: 'dse', adminToken: 'stronger-token' });
 *
 * await admin1.createKeyspace({
 *   replication: {
 *     class: 'NetworkTopologyStrategy',
 *     datacenter1: 3,
 *     datacenter2: 2,
 *   },
 * });
 *
 * const keyspaces = await admin1.listKeyspaces();
 * console.log(keyspaces);
 * ```
 *
 * @see Db.admin
 * @see DataAPIDbAdmin.dbAdmin
 *
 * @public
 */
export declare class DataAPIDbAdmin extends DbAdmin {
    #private;
    /* Excluded from this release type: __constructor */
    /**
     * Gets the underlying `Db` object. The options for the db were set when the `DataAPIDbAdmin` instance, or whatever
     * spawned it, was created.
     *
     * @example
     * ```typescript
     * const dbAdmin = client.admin().dbAdmin('<endpoint>', {
     *   keyspace: 'my-keyspace',
     *   useHttp2: false,
     * });
     *
     * const db = dbAdmin.db();
     * console.log(db.keyspace);
     * ```
     *
     * @returns The underlying `Db` object.
     */
    db(): Db;
    /**
     * Returns detailed information about the availability and usage of the vectorize embedding providers available on the
     * current database (may vary based on cloud provider & region).
     *
     * @example
     * ```typescript
     * const { embeddingProviders } = await dbAdmin.findEmbeddingProviders();
     *
     * // ['text-embedding-3-small', 'text-embedding-3-large', 'text-embedding-ada-002']
     * console.log(embeddingProviders['openai'].models.map(m => m.name));
     * ```
     *
     * @param options - The options for the timeout of the operation.
     *
     * @returns The available embedding providers.
     */
    findEmbeddingProviders(options?: WithTimeout<'databaseAdminTimeoutMs'>): Promise<FindEmbeddingProvidersResult>;
    /**
     * Lists the keyspaces in the database.
     *
     * The first element in the returned array is the default keyspace of the database, and the rest are additional
     * keyspaces in no particular order.
     *
     * @example
     * ```typescript
     * const keyspaces = await dbAdmin.listKeyspaces();
     *
     * // ['default_keyspace', 'my_other_keyspace']
     * console.log(keyspaces);
     * ```
     *
     * @returns A promise that resolves to list of all the keyspaces in the database.
     */
    listKeyspaces(options?: WithTimeout<'keyspaceAdminTimeoutMs'>): Promise<string[]>;
    /**
     * Creates a new, additional, keyspace for this database.
     *
     * **NB. The operation will always wait for the operation to complete, regardless of the {@link AstraAdminBlockingOptions}. Expect it to take roughly 8-10 seconds.**
     *
     * @example
     * ```typescript
     * await dbAdmin.createKeyspace('my_keyspace');
     *
     * await dbAdmin.createKeyspace('my_keyspace', {
     *   replication: {
     *     class: 'SimpleStrategy',
     *     replicationFactor: 3,
     *   },
     * });
     *
     * await dbAdmin.createKeyspace('my_keyspace', {
     *   replication: {
     *     class: 'NetworkTopologyStrategy',
     *     datacenter1: 3,
     *     datacenter2: 2,
     *   },
     * });
     * ```
     *
     * @param keyspace - The name of the new keyspace.
     * @param options - The options for the timeout & replication behavior of the operation.
     *
     * @returns A promise that resolves when the operation completes.
     */
    createKeyspace(keyspace: string, options?: DataAPICreateKeyspaceOptions): Promise<void>;
    /**
     * Drops a keyspace from this database.
     *
     * **NB. The operation will always wait for the operation to complete, regardless of the {@link AstraAdminBlockingOptions}. Expect it to take roughly 8-10 seconds.**
     *
     * @example
     * ```typescript
     * // ['default_keyspace', 'my_other_keyspace']
     * console.log(await dbAdmin.listKeyspaces());
     *
     * await dbAdmin.dropKeyspace('my_other_keyspace');
     *
     * // ['default_keyspace', 'my_other_keyspace']
     * console.log(await dbAdmin.listKeyspaces());
     * ```
     *
     * @param keyspace - The name of the keyspace to drop.
     * @param options - The options for the timeout of the operation.
     *
     * @returns A promise that resolves when the operation completes.
     */
    dropKeyspace(keyspace: string, options?: WithTimeout<'keyspaceAdminTimeoutMs'>): Promise<void>;
    get _httpClient(): DataAPIHttpClient<"admin">;
}

/**
 * An object representing a *complete* error response from the Data API, including the original command that was sent,
 * and the raw API response from the server.
 *
 * This is *not* used for "hard" (4XX, 5XX) errors, which are rarer and would be thrown directly by the underlying
 * code.
 *
 * @field errorDescriptors - A list of error descriptors representing the individual errors returned by the API
 * @field command - The raw command send to the API
 * @field rawResponse - The raw response from the API
 *
 * @public
 */
export declare interface DataAPIDetailedErrorDescriptor {
    /**
     * A list of error descriptors representing the individual errors returned by the API.
     *
     * This will likely be a singleton list in many cases, such as for `insertOne` or `deleteOne` commands, but may be
     * longer for bulk operations like `insertMany` which may have multiple insertion errors.
     */
    readonly errorDescriptors: DataAPIErrorDescriptor[];
    /**
     * The original command that was sent to the API, as a plain object. This is the *raw* command, not necessarily in
     * the exact format the client may use, in some rare cases.
     *
     * @example
     * ```typescript
     * {
     *   insertOne: {
     *     document: { _id: 'docml10', name: 'Document 10' },
     *   }
     * }
     * ```
     */
    readonly command: Record<string, any>;
    /**
     * The raw response from the API
     *
     * @example
     * ```typescript
     * {
     *   status: {
     *     insertedIds: [ 'id1', 'id2', 'id3']
     *   },
     *   data: undefined,
     *   errors: [
     *     {
     *       message: "Failed to insert document with _id 'id3': Document already exists with the given _id",
     *       errorCode: 'DOCUMENT_ALREADY_EXISTS'
     *     }
     *   ]
     * }
     * ```
     */
    readonly rawResponse: RawDataAPIResponse;
}

/**
 * Represents a `duration` column for Data API tables.
 *
 * You may use the {@link duration} function as a shorthand for creating a new `DataAPIDuration`.
 *
 * See the official DataStax documentation for more information.
 *
 * @public
 */
export declare class DataAPIDuration implements TableCodec<typeof DataAPIDuration> {
    #private;
    /**
     * Implementation of `$SerializeForTable` for {@link TableCodec}
     */
    [$SerializeForTable](ctx: TableSerCtx): readonly [0, (string | undefined)?];
    /**
     * Implementation of `$DeserializeForTable` for {@link TableCodec}
     */
    static [$DeserializeForTable](value: any, ctx: TableDesCtx): readonly [0, (DataAPIDuration | undefined)?];
    /**
     * Creates a new `DataAPIDuration` instance from a duration string.
     *
     * @param input - The duration string to create the `DataAPIDuration` from
     */
    constructor(input: string);
    /**
     * Returns the string representation of this `DataAPIDuration`
     *
     * @returns The string representation of this `DataAPIDuration`
     */
    toString(): string;
}

/**
 * All the available Data API backends the Typescript client recognizes.
 *
 * If using a non-Astra database as the backend, the `environment` option should be set in the `DataAPIClient` options,
 * as well as in the `db.admin()` options.
 *
 * @public
 */
export declare type DataAPIEnvironment = typeof DataAPIEnvironments[number];

/**
 * All the available Data API backends the Typescript client recognizes.
 *
 * If using a non-Astra database as the backend, the `environment` option should be set in the `DataAPIClient` options,
 * as well as in the `db.admin()` options.
 *
 * @public
 */
export declare const DataAPIEnvironments: readonly ["astra", "dse", "hcd", "cassandra", "other"];

/**
 * An abstract class representing *some* exception that occurred related to the Data API. This is the base class for all
 * Data API errors, and will never be thrown directly.
 *
 * Useful for `instanceof` checks.
 *
 * This is *only* for Data API related errors, such as a non-existent collections, or a duplicate key error. It
 * is *not*, however, for errors such as an HTTP network error, or a malformed request. The exception being timeouts,
 * which are represented by the {@link DataAPITimeoutError} class.
 *
 * @public
 */
export declare abstract class DataAPIError extends Error {
}

/**
 * An object representing a single "soft" (2XX) error returned from the Data API, typically with an error code and a
 * human-readable message. An API request may return with an HTTP 200 success error code, but contain a nonzero
 * amount of these, such as for duplicate inserts, or invalid IDs.
 *
 * This is *not* used for "hard" (4XX, 5XX) errors, which are rarer and would be thrown directly by the underlying
 * code.
 *
 * @example
 * ```typescript
 * {
 *   errorCode: 'DOCUMENT_ALREADY_EXISTS',
 *   message: "Failed to insert document with _id 'id3': Document already exists with the given _id",
 *   attributes: {},
 * }
 * ```
 *
 * @field errorCode - A string code representing the exact error
 * @field message - A human-readable message describing the error
 * @field attributes - A map of additional attributes returned by the API. Often empty
 *
 * @public
 */
export declare interface DataAPIErrorDescriptor {
    /**
     * A string code representing the exact error
     */
    readonly errorCode?: string;
    /**
     * A human-readable message describing the error
     */
    readonly message?: string;
    /**
     * A map of additional attributes that may be useful for debugging or logging returned by the API. Not guaranteed to
     * be non-empty. Probably more often empty than not.
     */
    readonly attributes?: Record<string, any>;
}

/**
 * The most explicit way to configure logging, with the ability to set both events and specific outputs.
 *
 * Settings the `emits` field to `[]` will disable logging for the specified events.
 *
 * See {@link DataAPIClientEventMap} & {@link DataAPILoggingConfig} for much more info.
 *
 * @public
 */
export declare interface DataAPIExplicitLoggingConfig {
    readonly events: OneOrMany<DataAPILoggingEvent>;
    readonly emits: OneOrMany<DataAPILoggingOutput>;
}

/* Excluded from this release type: DataAPIHttpClient */

/* Excluded from this release type: DataAPIHttpClientOpts */

/**
 * An error thrown on non-2XX status codes from the Data API, such as 4XX or 5XX errors.
 *
 * @public
 */
export declare class DataAPIHttpError extends DataAPIError {
    /**
     * The error descriptors returned by the API to describe what went wrong.
     */
    readonly status: number;
    /**
     * The raw string body of the HTTP response, if it exists
     */
    readonly body?: string;
    /**
     * The "raw", errored response from the API.
     */
    readonly raw: FetcherResponseInfo;
    /* Excluded from this release type: __constructor */
}

/**
 * The options available for the {@link DataAPIClient} related to making HTTP requests.
 *
 * There are four different behaviours for setting the client:
 * - Not setting the `httpOptions` at all
 * -- This will attempt to use `fetch-h2` if available, and fall back to `fetch` if not available
 * - `client: 'default'` or `client: undefined` (or unset)
 * -- This will attempt to use `fetch-h2` if available, and throw an error if not available
 * - `client: 'fetch'`
 * -- This will always use the native `fetch` API
 * - `client: 'custom'`
 * -- This will allow you to pass a custom `Fetcher` implementation to the client
 *
 * `fetch-h2` is a fetch implementation that supports HTTP/2, and is the recommended client for the best performance.
 *
 * However, it's generally only available by default on node runtimes; on other runtimes, you may need to use the
 * native `fetch` API instead, or pass in the fetch-h2 module manually.
 *
 * See the `astra-db-ts` README for more information on different clients.
 *
 * https://github.com/datastax/astra-db-ts
 *
 * @public
 */
export declare type DataAPIHttpOptions = DefaultHttpClientOptions | FetchHttpClientOptions | CustomHttpClientOptions;

/**
 * #### Overview
 *
 * The configuration for logging events emitted by the {@link DataAPIClient}.
 *
 * This can be set at any level of the major class hierarchy, and will be inherited by all child classes.
 *
 * #### Configuration inheritance
 *
 * The logging config, at its core, is just a list of events to enable/disable, and where to emit/log them.
 *
 * When they're inherited by child classes, it's done as a simple list merge, with the child's config taking precedence.
 * (e.g. `[...parentConfig, ...childConfig]`). Each new layer of config is applied on top of the previous one, overwriting
 * any previous settings for the same events.
 *
 * #### Configuration & shorthands
 *
 * There's multiple ways to configure logging, depending on how much control you want:
 *
 * `logging: 'all'`
 * - This will emit all events, but will also log some of them to the console
 * - When you use just `'all'`, it simply replaces it with {@link EventLoggingDefaults}
 *
 * `logging: [{ events: 'all', emits: 'event' }]`
 * - This will emit all events, without logging any of them to the console
 *
 * `logging: '<command>' | ['<commands>']`
 * - This will emit only the events for the specified command, but may also log some of them to the console
 * - Each command's behavior is listed below, & defined in {@link EventLoggingDefaults}
 *
 * `logging: ['all', [{ events: ['<commands>'], emits: [] }]]`
 * - This will emit all but the specified events, but will also log some of them to the console
 *
 * Just keep in mind that it's really just a list of configuration "layers".
 *
 * #### Event types
 *
 * See {@link DataAPIClientEventMap} for more information on the types of events emitted.
 *
 * #### Output types
 *
 * The `emits` field can be set to either 'event', 'stdout', or 'stderr'.
 *
 * - 'event' will emit the event to the {@link DataAPIClient} instance
 * - 'stdout' will log the event to stdout
 * - 'stderr' will log the event to stderr
 *
 * #### Examples
 *
 * ```ts
 * const client = new DataAPIClient('*TOKEN*', {
 *  logging: [{ events: 'all', emits: 'stdout' }],
 * });
 * const db = client.db('*ENDPOINT*');
 *
 * // Output:
 * // '[CommandStartedEvent]: createCollection in default_keyspace'
 * // '[CommandSucceededEvent]: createCollection in default_keyspace (took ...ms)'
 * await db.createCollection('my_collection');
 * ```
 *
 * @see DataAPIClientEventMap
 * @see DataAPILoggingEvent
 * @see DataAPILoggingOutput
 *
 * @public
 */
export declare type DataAPILoggingConfig = DataAPILoggingEvent | readonly (DataAPILoggingEvent | DataAPIExplicitLoggingConfig)[];

/**
 * @public
 */
export declare const DataAPILoggingDefaults: NormalizedLoggingConfig[];

/**
 * Represents the different events that can be emitted/logged by the {@link DataAPIClient}, as well as the convenient
 * shorthand 'all' to configure all events at once.
 *
 * See {@link DataAPIClientEventMap} & {@link DataAPILoggingConfig} for much more info.
 *
 * @public
 */
export declare type DataAPILoggingEvent = 'all' | keyof DataAPIClientEventMap;

/**
 * Represents the different outputs that can be emitted/logged to by the {@link DataAPIClient}.
 *
 * This can be set to either 'event', 'stdout', or 'stderr'. However, attempting to set both 'stdout' and 'stderr'
 * as an output for a single event will result in an error.
 *
 * See {@link DataAPIClientEventMap} & {@link DataAPILoggingConfig} for much more info.
 *
 * @public
 */
export declare type DataAPILoggingOutput = 'event' | 'stdout' | 'stderr';

/* Excluded from this release type: DataAPIRequestInfo */

/**
 * An error representing the *complete* errors for an operation. This is a cohesive error that represents all the
 * errors that occurred during a single operation, and should not be thought of as *always* 1:1 with the number of
 * API requests—rather it's 1:1 with the number of *logical* operations performed by the user (i.e. the methods
 * on the {@link Collection} class).
 *
 * This is *not* used for "hard" (4XX, 5XX) errors, which are rarer and would be thrown directly by the underlying
 * code.
 *
 * @field message - A human-readable message describing the *first* error
 * @field errorDescriptors - A list of error descriptors representing the individual errors returned by the API
 * @field detailedErrorDescriptors - A list of errors 1:1 with the number of errorful API requests made to the server.
 *
 * @public
 */
export declare class DataAPIResponseError extends DataAPIError {
    /**
     * A human-readable message describing the *first* error.
     *
     * This is *always* equal to `errorDescriptors[0]?.message` if it exists, otherwise it's given a generic
     * default message.
     */
    readonly message: string;
    /**
     * A list of error descriptors representing the individual errors returned by the API.
     *
     * This is *always* equal to `detailedErrorDescriptors.flatMap(d => d.errorDescriptors)`, for the user's
     * convenience.
     */
    readonly errorDescriptors: DataAPIErrorDescriptor[];
    /**
     * A list of errors 1:1 with the number of errorful API requests made to the server. Each element contains the
     * original command, the raw response, and the error descriptors for that request.
     *
     * For operations that only make one request, this will be a singleton list (i.e. `insertOne`).
     */
    readonly detailedErrorDescriptors: DataAPIDetailedErrorDescriptor[];
    /* Excluded from this release type: __constructor */
}

/**
 * Represents a `time` column for Data API tables.
 *
 * You may use the {@link time} function as a shorthand for creating a new `DataAPITime`.
 *
 * See the official DataStax documentation for more information.
 *
 * @public
 */
export declare class DataAPITime implements TableCodec<typeof DataAPITime> {
    #private;
    /**
     * Implementation of `$SerializeForTable` for {@link TableCodec}
     */
    [$SerializeForTable](ctx: TableSerCtx): readonly [0, (string | undefined)?];
    /**
     * Implementation of `$DeserializeForTable` for {@link TableCodec}
     */
    static [$DeserializeForTable](value: any, ctx: TableDesCtx): readonly [0, (DataAPITime | undefined)?];
    /**
     * Creates a new `DataAPITime` instance from various formats.
     *
     * @param input - The input to create the `DataAPITime` from
     */
    constructor(input?: string | Date | (DataAPITimeComponents & {
        nanoseconds?: number;
    }));
    /**
     * Returns the {@link DataAPITimeComponents} that make up this `DataAPITime`
     *
     * @returns The components of the time
     */
    components(): DataAPITimeComponents;
    /**
     * Converts this `DataAPITime` to a `Date` object
     *
     * If no `base` date/time is provided to use the date from, the date component is set to be the current date.
     *
     * @param base - The base date/time to use for the date component
     *
     * @returns The `Date` object representing this `DataAPITime`
     */
    toDate(base?: Date | DataAPIDate | DataAPITimestamp): Date;
    /**
     * Returns the string representation of this `DataAPITime`
     *
     * @returns The string representation of this `DataAPITime`
     */
    toString(): string;
}

/**
 * Represents the time components that make up a `DataAPITime`
 *
 * @public
 */
export declare interface DataAPITimeComponents {
    /**
     * The hour of the time
     */
    hours: number;
    /**
     * The minute of the time
     */
    minutes: number;
    /**
     * The second of the time
     */
    seconds: number;
    /**
     * The nanosecond of the time
     */
    nanoseconds: number;
}

/**
 * An error thrown when a Data API operation timed out.
 *
 * Depending on the method, this may be a request timeout occurring during a specific HTTP request, or can happen over
 * the course of a method involving several requests in a row, such as a paginated `insertMany`.
 *
 * @public
 */
export declare class DataAPITimeoutError extends DataAPIError {
    /**
     * The timeout that was set for the operation, in milliseconds.
     */
    readonly timeout: Partial<TimeoutDescriptor>;
    readonly timedOutTypes: TimedOutCategories;
    /* Excluded from this release type: __constructor */
    static mk(info: HTTPRequestInfo, types: TimedOutCategories): DataAPITimeoutError;
}

/**
 * Represents a `timestamp` column for Data API tables.
 *
 * You may use the {@link timestamp} function as a shorthand for creating a new `DataAPITimestamp`.
 *
 * See the official DataStax documentation for more information.
 *
 * @public
 */
export declare class DataAPITimestamp implements CollCodec<typeof DataAPITimestamp>, TableCodec<typeof DataAPITimestamp> {
    #private;
    /**
     * Implementation of `$SerializeForTable` for {@link TableCodec}
     */
    [$SerializeForTable](ctx: TableSerCtx): readonly [0, (string | undefined)?];
    /**
     * Implementation of `$SerializeForCollection` for {@link TableCodec}
     */
    [$SerializeForCollection](ctx: CollSerCtx): readonly [0, ({
        $date: string;
    } | undefined)?];
    /**
     * Implementation of `$DeserializeForTable` for {@link TableCodec}
     */
    static [$DeserializeForTable](value: any, ctx: TableDesCtx): readonly [0, (DataAPITimestamp | undefined)?];
    /**
     * Implementation of `$DeserializeForCollection` for {@link TableCodec}
     */
    static [$DeserializeForCollection](_: string, value: any, ctx: CollDesCtx): readonly [0, (DataAPITimestamp | undefined)?];
    /**
     * Creates a new `DataAPITimestamp` instance from various formats.
     *
     * @param input - The input to create the `DataAPITimestamp` from
     */
    constructor(input?: string | Date | Partial<DataAPITimestampComponents>);
    /**
     * Returns the {@link DataAPITimestampComponents} that make up this `DataAPITimestamp`
     *
     * @returns The components of the timestamp
     */
    components(): DataAPITimestampComponents;
    /**
     * Converts this `DataAPITimestamp` to a `Date` object
     *
     * @returns The `Date` object representing this `DataAPITimestamp`
     */
    toDate(): Date;
    /**
     * Returns the string representation of this `DataAPITimestamp`
     *
     * @returns The string representation of this `DataAPITimestamp`
     */
    toString(): string;
}

/**
 * Represents the time components that make up a `DataAPITimestamp`
 *
 * @public
 */
export declare interface DataAPITimestampComponents {
    /**
     * The year of the timestamp
     */
    year: number;
    /**
     * The month of the timestamp (should be between 1 and 12)
     */
    month: number;
    /**
     * The day of the month
     */
    date: number;
    /**
     * The hour of the timestamp
     */
    hours: number;
    /**
     * The minute of the timestamp
     */
    minutes: number;
    /**
     * The second of the timestamp
     */
    seconds: number;
    /**
     * The nanosecond of the timestamp
     */
    nanoseconds: number;
}

/**
 * Represents a `vector` column for Data API tables.
 *
 * See {@link DataAPIVectorLike} for the types that can be converted into a `DataAPIVector`.
 *
 * You may use the {@link vector} function as a shorthand for creating a new `DataAPIVector`.
 *
 * See the official DataStax documentation for more information.
 *
 * @public
 */
export declare class DataAPIVector implements CollCodec<typeof DataAPIVector>, TableCodec<typeof DataAPIVector> {
    #private;
    /**
     * Implementation of `$SerializeForTable` for {@link TableCodec}
     */
    [$SerializeForTable](ctx: TableSerCtx): readonly [0, (number[] | {
        $binary: string;
    } | undefined)?];
    /**
     * Implementation of `$SerializeForCollection` for {@link TableCodec}
     */
    [$SerializeForCollection](ctx: CollSerCtx): readonly [0, (number[] | {
        $binary: string;
    } | undefined)?];
    /**
     * Implementation of `$DeserializeForTable` for {@link TableCodec}
     */
    static [$DeserializeForTable](value: any, ctx: TableDesCtx): readonly [0, (DataAPIVector | undefined)?];
    /**
     * Implementation of `$DeserializeForCollection` for {@link TableCodec}
     */
    static [$DeserializeForCollection](_: string, value: any, ctx: CollDesCtx): readonly [0, (DataAPIVector | undefined)?];
    /**
     * Creates a new `DataAPIVector` instance from a vector-like value.
     *
     * You can set `validate` to `false` to bypass any validation if you're confident the value is a valid vector.
     *
     * @param vector - The vector-like value to convert to a `DataAPIVector`
     * @param validate - Whether to validate the vector-like value (default: `true`)
     *
     * @throws TypeError If `vector` is not a valid vector-like value
     */
    constructor(vector: DataAPIVectorLike, validate?: boolean);
    /**
     * Returns the length of the vector (# of floats), agnostic of the underlying type.
     *
     * @returns The length of the vector
     */
    get length(): number;
    /**
     * Gets the raw underlying implementation of the vector.
     *
     * @returns The raw vector
     */
    raw(): Exclude<DataAPIVectorLike, DataAPIVector>;
    /**
     * Returns the vector as a `number[]`, converting between types if necessary.
     *
     * @returns The vector as a `number[]`
     */
    asArray(): number[];
    /**
     * Returns the vector as a `Float32Array`, converting between types if necessary.
     *
     * @returns The vector as a `Float32Array`
     */
    asFloat32Array(): Float32Array;
    /**
     * Returns the vector as a base64 string, converting between types if necessary.
     *
     * @returns The vector as a base64 string
     */
    asBase64(): string;
    /**
     * Returns a pretty string representation of the `DataAPIVector`.
     */
    toString(): string;
    /**
     * Determines whether the given value is a vector-like value (i.e. it's {@link DataAPIVectorLike}.
     *
     * @param value - The value to check
     *
     * @returns `true` if the value is a vector-like value; `false` otherwise
     */
    static isVectorLike(value: unknown): value is DataAPIVectorLike;
}

/**
 * Represents any type that can be converted into a {@link DataAPIVector}
 *
 * @public
 */
export declare type DataAPIVectorLike = number[] | {
    $binary: string;
} | Float32Array | DataAPIVector;

/**
 * A shorthand function for `new DataAPIDate(date?)`
 *
 * If no date is provided, it defaults to the current date.
 *
 * @public
 */
export declare const date: (date?: string | Date | DataAPIDateComponents) => DataAPIDate;

/**
 * #### Overview
 *
 * Represents an interface to some Data-API-enabled database instance. This is the entrypoint for database-level DML, such as
 * creating/deleting collections/tables, connecting to collections/tables, and executing arbitrary commands.
 *
 * **Shouldn't be instantiated directly; use {@link DataAPIClient.db} to obtain an instance of this class.**
 *
 * Note that creating an instance of a `Db` doesn't trigger actual database creation; the database must have already
 * existed beforehand. If you need to create a new database, use the {@link AstraAdmin} class.
 *
 * @example
 * ```ts
 * // Connect to a database using a direct endpoint
 * const db = client.db('*ENDPOINT*');
 *
 * // Overrides default options from the DataAPIClient
 * const db = client.db('*ENDPOINT*', {
 *   keyspace: 'my_keyspace',
 *   useHttp2: false,
 * });
 * ```
 *
 * ###### The "working keyspace"
 *
 * The `Db` class has a concept of a "working keyspace", which is the default keyspace used for all operations in the database. This can be overridden in each method call, but if not, the default keyspace is used.
 *
 * If no explicit keyspace is provided when creating the `Db` instance, it will default to:
 * - On DataStax Astra dbs: `default_keyspace`
 * - On all other dbs, it will remain undefined
 *   - In this case, the keyspace must be set using either:
 *     - The `db.useKeyspace()` mutator method
 *     - The `updateDbKeyspace` parameter in `dbAdmin.createKeyspace()`
 *
 * Changing the working namespaces does NOT retroactively update any collections/tables spawned from this `Db` instance.
 *
 * See {@link Db.useKeyspace} and {@link DbAdmin.createKeyspace} for more information.
 *
 * @example
 * ```ts
 * // Method 1:
 * db.useKeyspace('my_keyspace');
 *
 * // Method 2:
 * // (If using non-astra, this may be a common idiom)
 * await db.admin().createKeyspace('my_keyspace', {
 *   updateDbKeyspace: true,
 * });
 * ```
 *
 * ###### Astra vs. non-Astra
 *
 * The `Db` class is designed to work with both Astra and non-Astra databases. However, there are some differences in behaviour between the two:
 * - Astra DBs have an ID & region, which can be accessed using `db.id` and `db.region` respectively
 * - Astra DBs have a `db.info()` method, which provides detailed information about the database
 * - The `db.admin()` method will return differently depending on the environment
 *   - For Astra DBs, it will return an {@link AstraDbAdmin} instance
 *   - For non-Astra DBs, it will return a {@link DataAPIDbAdmin} instance
 *   - (The `environment` option must also be set in the `admin()` method)
 * - As aforementioned, the default keyspace is different between Astra and non-Astra databases
 *   - See the previous section for more information
 *
 * @see DataAPIClient.db
 * @see AstraAdmin.db
 * @see Table
 * @see Collection
 * @see DbAdmin
 *
 * @public
 */
export declare class Db {
    #private;
    /* Excluded from this release type: __constructor */
    /**
     * The default keyspace to use for all operations in this database, unless overridden in a method call.
     *
     * @example
     * ```typescript
     * // Uses 'default_keyspace' as the default keyspace for all future db spawns
     * const client1 = new DataAPIClient('*TOKEN*');
     *
     * // Overrides the default keyspace for all future db spawns
     * const client2 = new DataAPIClient('*TOKEN*', {
     *   dbOptions: { keyspace: 'my_keyspace' },
     * });
     *
     * // Created with 'default_keyspace' as the default keyspace
     * const db1 = client1.db('*ENDPOINT*');
     *
     * // Created with 'my_keyspace' as the default keyspace
     * const db2 = client1.db('*ENDPOINT*', {
     *   keyspace: 'my_keyspace'
     * });
     *
     * // Uses 'default_keyspace'
     * const coll1 = db1.collection('users');
     *
     * // Uses 'my_keyspace'
     * const coll2 = db1.collection('users', {
     *   keyspace: 'my_keyspace'
     * });
     * ```
     */
    get keyspace(): string;
    /**
     * The ID of the database (UUID), if it's an Astra database.
     *
     * If it's not an Astra database, this will throw an error, as they have no applicable/appropriate ID.
     *
     * @throws InvalidEnvironmentError - if the database is not an Astra database.
     */
    get id(): string;
    /**
     * The region of the database (e.g. `'us-east-1'`), if it's an Astra database.
     *
     * If it's not an Astra database, this will throw an error, as they have no applicable/appropriate region.
     *
     * @throws InvalidEnvironmentError - if the database is not an Astra database.
     */
    get region(): string;
    /**
     * ##### Overview
     *
     * Sets the default working keyspace of the `Db` instance. Does not retroactively update any previous collections
     * spawned from this `Db` to use the new keyspace.
     *
     * See {@link Db} for more info on "working keyspaces".
     *
     * @example
     * ```typescript
     * // Spawns a `Db` with default working keyspace `my_keyspace`
     * const db = client.db('<endpoint>', { keyspace: 'my_keyspace' });
     *
     * // Gets a collection from keyspace `my_keyspace`
     * const coll1 = db.collection('my_coll');
     *
     * // `db` now uses `my_other_keyspace` as the default keyspace for all operations
     * db.useKeyspace('my_other_keyspace');
     *
     * // Gets a collection from keyspace `my_other_keyspace`
     * // `coll1` still uses keyspace `my_keyspace`
     * const coll2 = db.collection('my_other_coll');
     *
     * // Gets `my_coll` from keyspace `my_keyspace` again
     * // (The default keyspace is still `my_other_keyspace`)
     * const coll3 = db.collection('my_coll', { keyspace: 'my_keyspace' });
     * ```
     *
     * ##### `updateDbKeyspace` in `DbAdmin.createKeyspace`
     *
     * If you want to create a `Db` in a not-yet-existing keyspace, you can use the `updateDbKeyspace` option in {@link DbAdmin.createKeyspace} to set the default keyspace of the `Db` instance to the new keyspace.
     *
     * This may be a common idiom when working with non-Astra databases.
     *
     * @example
     * ```typescript
     * const client = new DataAPIClient({ environment: 'dse' });
     * const db = client.db('<endpoint>', { token: '<token>' });
     *
     * // Will internally call `db.useKeyspace('new_keyspace')`
     * await db.admin().createKeyspace('new_keyspace', {
     *   updateDbKeyspace: true,
     * });
     *
     * // Creates collection in keyspace `new_keyspace` by default now
     * const coll = db.createCollection('my_coll');
     * ```
     *
     * @param keyspace - The keyspace to use
     */
    useKeyspace(keyspace: string): void;
    /**
     * ##### Overview
     *
     * Spawns a new {@link AstraDbAdmin} instance for this database, used for performing administrative operations
     * on the database, such as managing keyspaces, or getting database information.
     *
     * The given options will override any default options set when creating the {@link DataAPIClient} through
     * a deep merge (i.e. unset properties in the options object will just default to the default options).
     *
     * @example
     * ```typescript
     * const admin1 = db.admin();
     * const admin2 = db.admin({ adminToken: '<stronger-token>' });
     *
     * const keyspaces = await admin1.listKeyspaces();
     * console.log(keyspaces);
     * ```
     *
     * ##### Astra vs. non-Astra
     *
     * **If using a non-Astra backend, the `environment` option MUST be set as it is on the `DataAPIClient`**
     *
     * If on Astra, this method will return a new {@link AstraDbAdmin} instance, which provides a few extra methods
     * for Astra databases, such as {@link AstraDbAdmin.info} or {@link AstraDbAdmin.drop}.
     *
     * @param options - Any options to override the default options set when creating the {@link DataAPIClient}.
     *
     * @returns A new {@link AstraDbAdmin} instance for this database instance.
     *
     * @throws InvalidEnvironmentError - if the database is not an Astra database.
     */
    admin(options?: AdminOptions & {
        environment?: 'astra';
    }): AstraDbAdmin;
    /**
     * ##### Overview
     *
     * Spawns a new {@link DataAPIDbAdmin} instance for this database, used for performing administrative operations
     * on the database, such as managing keyspaces, or getting database information.
     *
     * The given options will override any default options set when creating the {@link DataAPIClient} through
     * a deep merge (i.e. unset properties in the options object will just default to the default options).
     *
     * **If using a non-Astra backend, the `environment` option MUST be set as it is on the `DataAPIClient`**
     *
     * @example
     * ```typescript
     * const client = new DataAPIClient({ environment: 'dse' });
     * const db = client.db('*ENDPOINT*', { token });
     *
     * // OK
     * const admin1 = db.admin({ environment: 'dse' });
     *
     * // Will throw "mismatching environments" error
     * const admin2 = db.admin();
     *
     * const keyspaces = await admin1.listKeyspaces();
     * console.log(keyspaces);
     * ```
     *
     * ##### Astra vs. non-Astra
     *
     * **If using a non-Astra backend, the `environment` option MUST be set as it is on the `DataAPIClient`**
     *
     * If on non-Astra, this method will return a new {@link DataAPIDbAdmin} instance, which conforms strictly to the
     * {@link DbAdmin} interface, with the {@link DataAPIDbAdmin.createKeyspace} method being the only method that
     * differs slightly from the interface version.
     *
     * @param options - Any options to override the default options set when creating the {@link DataAPIClient}.
     *
     * @returns A new {@link AstraDbAdmin} instance for this database instance.
     *
     * @throws InvalidEnvironmentError - if the database is not an Astra database.
     */
    admin(options: AdminOptions & {
        environment: Exclude<DataAPIEnvironment, 'astra'>;
    }): DataAPIDbAdmin;
    /**
     * ##### Overview
     *
     * Fetches information about the database, such as the database name, region, and other metadata.
     *
     * **NOTE: Only available for Astra databases.**
     *
     * For the full, complete, information, see {@link AstraDbAdmin.info}.
     *
     * The method issues a request to the DevOps API each time it is invoked, without caching mechanisms;
     * this ensures up-to-date information for usages such as real-time collection validation by the application.
     *
     * @example
     * ```typescript
     * const info = await db.info();
     * console.log(info.name);
     * ```
     *
     * ##### On non-Astra
     *
     * This operation requires a call to the DevOps API, which is only available on Astra databases. As such, this method
     * will throw an error if the database is not an Astra database.
     *
     * @returns A promise that resolves to the database information.
     *
     * @throws Error - if the database is not an Astra database.
     */
    info(options?: WithTimeout<'databaseAdminTimeoutMs'>): Promise<AstraDbInfo>;
    /**
     * ##### Overview
     *
     * Establishes a reference to a collection in the database. This method does not perform any I/O.
     *
     * **NOTE: This method does not validate the existence of the collection—it simply creates a reference.**
     *
     * @example
     * ```ts
     * interface User {
     *   name: string,
     *   age?: number,
     * }
     *
     * // Basic usage
     * const users1 = db.collection<User>('users');
     * users1.insertOne({ name: 'John' });
     *
     * // Untyped collection from different keyspace
     * const users2 = db.collection('users', {
     *   keyspace: 'my_keyspace',
     * });
     * users2.insertOne({ 'anything[you]$want': 'John' }); // Dangerous
     * ```
     *
     * ##### No I/O
     *
     * **Unlike the MongoDB Node.js driver, this method does not create a collection if it doesn't exist.**
     *
     * Use {@link Db.createCollection} to create a new collection instead.
     *
     * ##### Typing & Types
     *
     * Collections are inherently untyped, but you can provide your own client-side compile-time schema for type inference and early-bug-catching purposes.
     *
     * A `Collection` is typed as `Collection<Schema extends SomeDoc = SomeDoc>`, where:
     * - `Schema` is the user-intended type of the documents in the collection.
     * - `SomeDoc` is set to `Record<string, any>`, representing any valid JSON object.
     *
     * Certain datatypes may be represented as TypeScript classes (some native, some provided by `astra-db-ts`), however.
     *
     * You may also provide your own datatypes by providing some custom serialization logic as well (see later section).
     *
     * Please see {@link Collection} for *much* more info on typing them, and more.
     *
     * @example
     * ```ts
     * import { UUID, DataAPIVector, ... } from 'astra-db-ts';
     *
     * interface User {
     *   _id: string,
     *   dob: Date,
     *   friends?: Record<string, UUID>, // UUID is also `astra-db-ts` provided
     *   vector: DataAPIVector,
     * }
     *
     * const collection = db.collection<User>('users');
     *
     * // res.insertedId is of type string
     * const res = await collection.insertOne({
     *   _id: '123',
     *   dob: new Date(),
     *   friends: { 'Alice': UUID.random() },
     *   vector: new DataAPIVector([1, 2, 3]), // This can also be passed as a number[]
     * });
     * ```
     *
     * ###### Disclaimer
     *
     * **Collections are inherently untyped**
     *
     * **It is on the user to ensure that the TS type of the `Collection` corresponds with the actual CQL table schema, in its TS-deserialized form. Incorrect or dynamic tying could lead to surprising behaviours and easily-preventable errors.**
     *
     * **There is no runtime type validation or enforcement of the schema.**
     *
     * @param name - The name of the collection.
     * @param options - Options for spawning the collection.
     *
     * @returns A new, unvalidated, reference to the collection.
     *
     * @see SomeDoc
     * @see VectorDoc
     * @see VectorizeDoc
     * @see db.createCollection
     */
    collection<WSchema extends SomeDoc, RSchema extends WithId<SomeDoc> = FoundDoc<WSchema>>(name: string, options?: CollectionOptions): Collection<WSchema, RSchema>;
    /**
     * ##### Overview
     *
     * Establishes a reference to a table in the database. This method does not perform any I/O.
     *
     * **NOTE: This method does not validate the existence of the table—it simply creates a reference.**
     *
     * @example
     * ```ts
     * interface User {
     *   name: string,
     *   age?: number,
     * }
     *
     * // Basic usage
     * const users1 = db.table<User>('users');
     * users1.insertOne({ name: 'John' });
     *
     * // Untyped table from different keyspace
     * const users2 = db.table('users', {
     *   keyspace: 'my_keyspace',
     * });
     * users2.insertOne({ 'anything[you]$want': 'John' }); // Dangerous
     * ```
     *
     * ##### No I/O
     *
     * **This method does not create a table if it doesn't exist.**
     *
     * Use {@link Db.createTable} to create a new table instead.
     *
     * ##### Typing & Types
     *
     * A `Table` is typed as `Table<Schema extends SomeRow = SomeRow>`, where:
     *  - `Schema` is the type of the rows in the table (the table schema).
     *  - `SomeRow` is set to `Record<string, any>`, representing any valid JSON object.
     *
     * Certain datatypes may be represented as TypeScript classes (some native, some provided by `astra-db-ts`), however.
     *
     * You may also provide your own datatypes by providing some custom serialization logic as well (see later section).
     *
     * ***Please see {@link Table} for *much* more info on typing them, and more.***
     *
     * @example
     * ```ts
     * import { DataAPIDate, UUID, DataAPIVector, ... } from 'astra-db-ts';
     *
     * interface User {
     *   id: string,       // Partition key
     *   dob: DataAPIDate, // Clustering (partition sort) key
     *   friends: Map<string, UUID>,
     *   vector: DataAPIVector,
     * }
     *
     * type UserPK = Pick<User, 'id' | 'dob'>;
     *
     * const table = db.table<User, UserPK>('users');
     *
     * // res.insertedId is of type { id: string }
     * const res = await table.insertOne({
     *   id: '123',
     *   dob: new DataAPIDate(new Date()),
     *   friends: new Map([['Alice', UUID.random()]]),
     *   vector: new DataAPIVector([1, 2, 3]), // Class enables encoding optimization
     * });
     * ```
     *
     * ###### Disclaimer
     *
     * *It is on the user to ensure that the TS type of the `Table` corresponds with the actual CQL table schema, in its TS-deserialized form. Incorrect or dynamic tying could lead to surprising behaviours and easily-preventable errors.*
     *
     * See {@link Db.createTable}, {@link Db.table}, and {@link InferTableSchema} for much more information about typing.
     *
     * @param name - The name of the table.
     * @param options - Options for spawning the table.
     *
     * @returns A new, unvalidated, reference to the table.
     *
     * @see SomeRow
     * @see db.createTable
     * @see InferTableSchema
     * @see InferTablePrimaryKey
     */
    table<WSchema extends SomeRow, PKeys extends SomeRow = Partial<FoundRow<WSchema>>, RSchema extends SomeRow = FoundRow<WSchema>>(name: string, options?: TableOptions): Table<WSchema, PKeys, RSchema>;
    /**
     * ##### Overview
     *
     * Creates a new collection in the database, and establishes a reference to it.
     *
     * This is a *blocking* command which performs actual I/O (unlike {@link Db.collection}, which simply creates an
     * unvalidated reference to a collection).
     *
     * @example
     * ```ts
     * // Most basic usage
     * const users = await db.createCollection('users');
     *
     * // With custom options in a different keyspace
     * const users2 = await db.createCollection('users', {
     *   keyspace: 'my_keyspace',
     *   defaultId: {
     *     type: 'objectId',
     *   },
     * });
     * ```
     *
     * ##### Idempotency
     *
     * Creating a collection is idempotent as long as the options remain the same; if the collection already exists with the same options, a {@link DataAPIResponseError} will be thrown.
     *
     * ("options" mean the `createCollection` options actually sent to the server, not things like `timeout` which are just client-side).
     *
     * ##### Enabling vector search
     *
     * *If vector options are not specified, the collection will not support vector search.*
     *
     * You can enable it by providing a `vector` option with the desired configuration, optionally with a `vector.service` block to enable vectorize (auto-embedding-generation).
     *
     * @example
     * ```ts
     * const users = await db.createCollection('users', {
     *   vector: {
     *     service: {
     *       provider: 'nvidia',
     *       modelName: 'NV-Embed-QA',
     *     },
     *   },
     * });
     *
     * // Now, `users` supports vector search
     * await users.insertOne({ $vectorize: 'I like cars!!!' });
     * await users.fineOne({}, { sort: { $vectorize: 'I like cars!!!' } });
     * ```
     *
     * ##### Typing & Types
     *
     * Collections are inherently untyped, but you can provide your own client-side compile-time schema for type inference and early-bug-catching purposes.
     *
     * A `Collection` is typed as `Collection<Schema extends SomeDoc = SomeDoc>`, where:
     * - `Schema` is the user-intended type of the documents in the collection.
     * - `SomeDoc` is set to `Record<string, any>`, representing any valid JSON object.
     *
     * Certain datatypes may be represented as TypeScript classes (some native, some provided by `astra-db-ts`), however.
     *
     * You may also provide your own datatypes by providing some custom serialization logic as well (see later section).
     *
     * Please see {@link Collection} for *much* more info on typing them, and more.
     *
     * @example
     * ```ts
     * import { UUID, DataAPIVector, ... } from 'astra-db-ts';
     *
     * interface User {
     *   _id: string,
     *   dob: Date,
     *   friends?: Record<string, UUID>, // UUID is also `astra-db-ts` provided
     *   vector: DataAPIVector,
     * }
     *
     * const collection = await db.createCollection<User>('users');
     *
     * // res.insertedId is of type string
     * const res = await collection.insertOne({
     *   _id: '123',
     *   dob: new Date(),
     *   friends: { 'Alice': UUID.random() },
     *   vector: new DataAPIVector([1, 2, 3]), // This can also be passed as a number[]
     * });
     * ```
     *
     * ##### Disclaimer
     *
     * **Collections are inherently untyped**
     *
     * **It is on the user to ensure that the TS type of the `Collection` corresponds with the actual CQL table schema, in its TS-deserialized form. Incorrect or dynamic tying could lead to surprising behaviours and easily-preventable errors.**
     *
     * **There is no runtime type validation or enforcement of the schema.**
     *
     * @param name - The name of the collection to create.
     * @param options - Options for the collection.
     *
     * @returns A promised reference to the newly created collection.
     *
     * @throws CollectionAlreadyExistsError - if the collection already exists and `checkExists` is `true` or unset.
     *
     * @see SomeDoc
     * @see db.collection
     */
    createCollection<WSchema extends SomeDoc, RSchema extends WithId<SomeDoc> = FoundDoc<WSchema>>(name: string, options?: CreateCollectionOptions<WSchema>): Promise<Collection<WSchema, RSchema>>;
    /**
     * ##### Overview
     *
     * Creates a new table in the database, and establishes a reference to it.
     *
     * This is a *blocking* command which performs actual I/O (unlike {@link Db.table}, which simply creates an
     * unvalidated reference to a table).
     *
     * ##### Overloads
     *
     * *This overload of `createTable` infers the TS-equivalent schema of the table from the provided `CreateTableDefinition`.*
     *
     * *Provide an explicit `Schema` type to disable this (e.g. `db.createTable<SomeRow>(...)`).*
     *
     * @example
     * ```ts
     * // Function to create the actual table
     * const mkUserTable = () => db.createTable('users', {
     *   definition: {
     *     columns: {
     *       name: 'text',
     *       dob: {
     *         type: 'timestamp',
     *       },
     *       friends: {
     *         type: 'set',
     *         valueType: 'text',
     *       },
     *     },
     *     primaryKey: {
     *       partitionBy: ['name', 'height'],
     *       partitionSort: { dob: 1 },
     *     },
     *   },
     * });
     *
     * // Type inference is as simple as that
     * type User = InferTableSchema<typeof mkUserTable>;
     *
     * // And now `User` can be used wherever.
     * const main = async () => {
     *   const table = await mkUserTable();
     *   const found: User | null = await table.findOne({});
     * };
     * ```
     *
     * ##### Idempotency
     *
     * Creating a table is idempotent if the `ifNotExists` option is set to `true`. Otherwise, an error will be thrown if a table with the same name is thrown.
     *
     * If a table is "recreated" with the same name & `ifNotExists` is set to `true`, but the columns definition differ, the operation will silently succeed, **but the original table schema will be retained**.
     *
     * ##### Typing & Types
     *
     * A `Table` is typed as `Table<Schema extends SomeRow = SomeRow>`, where:
     *  - `Schema` is the type of the rows in the table (the table schema).
     *  - `SomeRow` is set to `Record<string, any>`, representing any valid JSON object.
     *
     * Certain datatypes may be represented as TypeScript classes (some native, some provided by `astra-db-ts`), however.
     *
     * You may also provide your own datatypes by providing some custom serialization logic as well (see later section).
     *
     * ***Please see {@link Table} for *much* more info on typing them, and more.***
     *
     * ##### Disclaimer
     *
     * *It is on the user to ensure that the TS type of the `Table` corresponds with the actual CQL table schema, in its TS-deserialized form. Incorrect or dynamic tying could lead to surprising behaviours and easily-preventable errors.*
     *
     * See {@link Db.createTable}, {@link Db.table}, and {@link InferTableSchema} for much more information about typing.
     *
     * @param name - The name of the table to create.
     * @param options - Options for the table.
     *
     * @returns A promised reference to the newly created table.
     *
     * @see SomeRow
     * @see db.table
     * @see InferTableSchema
     * @see InferTablePrimaryKey
     * @see CreateTableDefinition
     */
    createTable<const Def extends CreateTableDefinition>(name: string, options: CreateTableOptions<Def>): Promise<Table<InferTableSchema<Def>, InferTablePrimaryKey<Def>>>;
    /**
     * ##### Overview
     *
     * Creates a new table in the database, and establishes a reference to it.
     *
     * This is a *blocking* command which performs actual I/O (unlike {@link Db.table}, which simply creates an
     * unvalidated reference to a table).
     *
     * ##### Overloads
     *
     * *This overload of `createTable` uses the provided `Schema` type to type the Table.*
     *
     * *Don't provide a `Schema` type if you want to infer it from the `CreateTableDefinition` via {@link InferTableSchema}.*
     *
     * @example
     * ```ts
     * interface User {
     *   name: string,
     *   dob: DataAPIDate,
     *   friends?: Set<string>,
     * }
     *
     * type UserPK = Pick<User, 'name' | 'dob'>;
     *
     * const table = await db.createTable<User, UserPK>('users', {
     *   definition: {
     *     columns: {
     *       name: 'text',
     *       dob: {
     *         type: 'timestamp',
     *       },
     *       friends: {
     *         type: 'set',
     *         valueType: 'text',
     *       },
     *     },
     *     primaryKey: {
     *       partitionBy: ['name'],
     *       partitionSort: { dob: 1 },
     *     },
     *   },
     * });
     *
     * const found: User | null = await table.findOne({});
     * ```
     *
     * ##### Idempotency
     *
     * Creating a table is idempotent if the `ifNotExists` option is set to `true`. Otherwise, an error will be thrown if a table with the same name is thrown.
     *
     * If a table is "recreated" with the same name & `ifNotExists` is set to `true`, but the columns definition differ, the operation will silently succeed, **but the original table schema will be retained**.
     *
     * ##### Typing & Types
     *
     * A `Table` is typed as `Table<Schema extends SomeRow = SomeRow>`, where:
     *  - `Schema` is the type of the rows in the table (the table schema).
     *  - `SomeRow` is set to `Record<string, any>`, representing any valid JSON object.
     *
     * Certain datatypes may be represented as TypeScript classes (some native, some provided by `astra-db-ts`), however.
     *
     * You may also provide your own datatypes by providing some custom serialization logic as well (see later section).
     *
     * ***Please see {@link Table} for *much* more info on typing them, and more.***
     *
     * ##### Disclaimer
     *
     * *It is on the user to ensure that the TS type of the `Table` corresponds with the actual CQL table schema, in its TS-deserialized form. Incorrect or dynamic tying could lead to surprising behaviours and easily-preventable errors.*
     *
     * See {@link Db.createTable}, {@link Db.table}, and {@link InferTableSchema} for much more information about typing.
     *
     * @param name - The name of the table to create.
     * @param options - Options for the table.
     *
     * @returns A promised reference to the newly created table.
     *
     * @see SomeRow
     * @see db.table
     * @see InferTableSchema
     * @see InferTablePrimaryKey
     * @see CreateTableDefinition
     */
    createTable<WSchema extends SomeRow, PKeys extends SomeRow = Partial<FoundRow<WSchema>>, RSchema extends SomeRow = FoundRow<WSchema>>(name: string, options: CreateTableOptions): Promise<Table<WSchema, PKeys, RSchema>>;
    /**
     * ##### Overview
     *
     * Drops a collection from the database, including all the contained documents.
     *
     * You can also specify a keyspace in the options parameter, which will override the working keyspace for this `Db`
     * instance.
     *
     * @example
     * ```typescript
     * // Uses db's working keyspace
     * const success1 = await db.dropCollection('users');
     * console.log(success1); // true
     *
     * // Overrides db's working keyspace
     * const success2 = await db.dropCollection('users', {
     *   keyspace: 'my_keyspace'
     * });
     * console.log(success2); // true
     * ```
     *
     * @param name - The name of the collection to drop.
     * @param options - Options for this operation.
     *
     * @returns A promise that resolves to `true` if the collection was dropped successfully.
     *
     * @remarks Use with caution. Have steel-toe boots on. Don't say I didn't warn you.
     */
    dropCollection(name: string, options?: DropCollectionOptions): Promise<void>;
    /**
     * ##### Overview
     *
     * Drops a table from the database, including all the contained rows.
     *
     * You can also specify a keyspace in the options parameter, which will override the working keyspace for this `Db`
     * instance.
     *
     * @example
     * ```typescript
     * // Uses db's working keyspace
     * const success1 = await db.dropTable('users');
     * console.log(success1); // true
     *
     * // Overrides db's working keyspace
     * const success2 = await db.dropTable('users', {
     *   keyspace: 'my_keyspace'
     * });
     * console.log(success2); // true
     * ```
     *
     * @param name - The name of the table to drop.
     * @param options - Options for this operation.
     *
     * @returns A promise that resolves to `true` if the table was dropped successfully.
     *
     * @remarks Use with caution. Wear a mask. Don't say I didn't warn you.
     */
    dropTable(name: string, options?: DropTableOptions): Promise<void>;
    /**
     * ##### Overview
     *
     * Drops an index from the database.
     *
     * This operation is idempotent if `ifExists` is set to `true`.
     *
     * See {@link Table.createIndex} & {@link Table.createVectorIndex}
     *
     * ##### Name uniqueness
     *
     * The name of the index is must actually be unique per keyspace, which is why this is a database-level command: to make it clear that the index is being dropped from the keyspace, not a specific table.
     *
     * @param name - The name of the index to drop.
     * @param options - The options for this operation.
     *
     * @returns A promise that resolves when the index is dropped.
     */
    dropTableIndex(name: string, options?: TableDropIndexOptions): Promise<void>;
    /**
     * Lists the collection names in the database.
     *
     * If you want to include the collection options in the response, set `nameOnly` to `false` (or omit it completely),
     * using the other overload.
     *
     * You can also specify a keyspace in the options parameter, which will override the working keyspace for this `Db`
     * instance.
     *
     * @example
     * ```typescript
     * // ['users', 'posts']
     * console.log(await db.listCollections({ nameOnly: true }));
     * ```
     *
     * @param options - Options for this operation.
     *
     * @returns A promise that resolves to an array of collection names.
     */
    listCollections(options: ListCollectionsOptions & {
        nameOnly: true;
    }): Promise<string[]>;
    /**
     * Lists the collections in the database.
     *
     * If you want to use only the collection names, set `nameOnly` to `true`, using the other overload.
     *
     * You can also specify a keyspace in the options parameter, which will override the working keyspace for this `Db`
     * instance.
     *
     * @example
     * ```typescript
     * // [{ name: 'users' }, { name: 'posts', options: { ... } }]
     * console.log(await db.listCollections());
     * ```
     *
     * @param options - Options for this operation.
     *
     * @returns A promise that resolves to an array of collection info.
     */
    listCollections(options?: ListCollectionsOptions & {
        nameOnly?: false;
    }): Promise<CollectionDescriptor[]>;
    /**
     * Lists the table names in the database.
     *
     * If you want to include the table options in the response, set `nameOnly` to `false` (or omit it completely),
     * using the other overload.
     *
     * You can also specify a keyspace in the options parameter, which will override the working keyspace for this `Db`
     * instance.
     *
     * @example
     * ```typescript
     * // ['users', 'posts']
     * console.log(await db.listTables({ nameOnly: true }));
     * ```
     *
     * @param options - Options for this operation.
     *
     * @returns A promise that resolves to an array of table names.
     */
    listTables(options: ListTablesOptions & {
        nameOnly: true;
    }): Promise<string[]>;
    /**
     * Lists the tables in the database.
     *
     * If you want to use only the table names, set `nameOnly` to `true`, using the other overload.
     *
     * You can also specify a keyspace in the options parameter, which will override the working keyspace for this `Db`
     * instance.
     *
     * @example
     * ```typescript
     * // [{ name: 'users' }, { name: 'posts', definition: { ... } }]
     * console.log(await db.listTables());
     * ```
     *
     * @param options - Options for this operation.
     *
     * @returns A promise that resolves to an array of table info.
     */
    listTables(options?: ListTablesOptions & {
        nameOnly?: false;
    }): Promise<TableDescriptor[]>;
    /**
     * Send a POST request to the Data API for this database with an arbitrary, caller-provided payload.
     *
     * You can specify a table/collection to target in the options parameter, thereby allowing you to perform
     * arbitrary table/collection-level operations as well.
     *
     * If the keyspace is set to `null`, the command will be run at the database level.
     *
     * If no collection is specified, the command will be executed at the keyspace level.
     *
     * You can also specify a keyspace in the options parameter, which will override the working keyspace for this `Db`
     * instance.
     *
     * @example
     * ```typescript
     * const colls = await db.command({ findCollections: {} });
     * console.log(colls); // { status: { collections: [] } }
     *
     * const user = await db.command({ findOne: {} }, { collection: 'users' });
     * console.log(user); // { data: { document: null } }
     *
     * const post = await db.command({ findOne: {} }, { table: 'posts' });
     * console.log(post); // { data: { document: null } }
     * ```
     *
     * @param command - The command to send to the Data API.
     * @param options - Options for this operation.
     *
     * @returns A promise that resolves to the raw response from the Data API.
     */
    command(command: Record<string, any>, options?: RunCommandOptions): Promise<RawDataAPIResponse>;
    get _httpClient(): DataAPIHttpClient<"normal">;
}

/**
 * Represents some DatabaseAdmin class used for managing some specific database.
 *
 * This abstract version lists the core functionalities that any database admin class may have, but
 * subclasses may have additional methods or properties (e.g. {@link AstraDbAdmin}).
 *
 * Use {@link Db.admin} or {@link AstraAdmin.dbAdmin} to obtain an instance of this class.
 *
 * @public
 */
export declare abstract class DbAdmin {
    /**
     * Gets the underlying `Db` object. The options for the db were set when the DbAdmin instance, or whatever spawned
     * it, was created.
     *
     * @example
     * ```typescript
     * const dbAdmin = client.admin().dbAdmin('<endpoint>', {
     *   keyspace: 'my-keyspace',
     *   useHttp2: false,
     * });
     *
     * const db = dbAdmin.db();
     * console.log(db.id);
     * ```
     *
     * @returns The underlying `Db` object.
     */
    abstract db(): Db;
    /**
     * Returns detailed information about the availability and usage of the vectorize embedding providers available on the
     * current database (may vary based on cloud provider & region).
     *
     * @example
     * ```typescript
     * const { embeddingProviders } = await dbAdmin.findEmbeddingProviders();
     *
     * // ['text-embedding-3-small', 'text-embedding-3-large', 'text-embedding-ada-002']
     * console.log(embeddingProviders['openai'].models.map(m => m.name));
     * ```
     *
     * @param options - The options for the timeout of the operation.
     *
     * @returns The available embedding providers.
     */
    abstract findEmbeddingProviders(options?: WithTimeout<'databaseAdminTimeoutMs'>): Promise<FindEmbeddingProvidersResult>;
    /**
     * Retrieves a list of all the keyspaces in the database.
     *
     * Semantic order is not guaranteed, but implementations are free to assign one. {@link AstraDbAdmin}, for example,
     * always has the first keyspace in the array be the default one.
     *
     * @example
     * ```typescript
     * const keyspaces = await dbAdmin.listKeyspaces();
     *
     * // ['default_keyspace', 'my_other_keyspace']
     * console.log(keyspaces);
     * ```
     *
     * @returns A promise that resolves to list of all the keyspaces in the database.
     */
    abstract listKeyspaces(options?: WithTimeout<'keyspaceAdminTimeoutMs'>): Promise<string[]>;
    /**
     * Creates a new, additional, keyspace for this database.
     *
     * **NB. this is a "long-running" operation. See {@link AstraAdminBlockingOptions} about such blocking operations.** The
     * default polling interval is 1 second. Expect it to take roughly 8-10 seconds to complete.
     *
     * @example
     * ```typescript
     * await dbAdmin.createKeyspace('my_other_keyspace1');
     *
     * // ['default_keyspace', 'my_other_keyspace1']
     * console.log(await dbAdmin.listKeyspaces());
     *
     * await dbAdmin.createKeyspace('my_other_keyspace2', {
     *   blocking: false,
     * });
     *
     * // Will not include 'my_other_keyspace2' until the operation completes
     * console.log(await dbAdmin.listKeyspaces());
     * ```
     *
     * @remarks
     * Note that if you choose not to block, the created keyspace will not be able to be used until the
     * operation completes, which is up to the caller to determine.
     *
     * @param keyspace - The name of the new keyspace.
     * @param options - The options for the blocking behavior of the operation.
     *
     * @returns A promise that resolves when the operation completes.
     */
    abstract createKeyspace(keyspace: string, options?: WithTimeout<'keyspaceAdminTimeoutMs'>): Promise<void>;
    /**
     * Drops a keyspace from this database.
     *
     * **NB. this is a "long-running" operation. See {@link AstraAdminBlockingOptions} about such blocking operations.** The
     * default polling interval is 1 second. Expect it to take roughly 8-10 seconds to complete.
     *
     * @example
     * ```typescript
     * await dbAdmin.dropKeyspace('my_other_keyspace1');
     *
     * // ['default_keyspace', 'my_other_keyspace2']
     * console.log(await dbAdmin.listKeyspaces());
     *
     * await dbAdmin.dropKeyspace('my_other_keyspace2', {
     *   blocking: false,
     * });
     *
     * // Will still include 'my_other_keyspace2' until the operation completes
     * // ['default_keyspace', 'my_other_keyspace2']
     * console.log(await dbAdmin.listKeyspaces());
     * ```
     *
     * @remarks
     * Note that if you choose not to block, the keyspace will still be able to be used until the operation
     * completes, which is up to the caller to determine.
     *
     * @param keyspace - The name of the keyspace to drop.
     * @param options - The options for the blocking behavior of the operation.
     *
     * @returns A promise that resolves when the operation completes.
     */
    abstract dropKeyspace(keyspace: string, options?: WithTimeout<'keyspaceAdminTimeoutMs'>): Promise<void>;
}

/**
 * The options available spawning a new {@link Db} instance.
 *
 * If any of these options are not provided, the client will use the default options provided by the {@link DataAPIClient}.
 *
 * @public
 */
export declare interface DbOptions {
    /**
     * The configuration for logging events emitted by the {@link DataAPIClient}.
     *
     * This can be set at any level of the major class hierarchy, and will be inherited by all child classes.
     *
     * See {@link DataAPILoggingConfig} for *much* more information on configuration, outputs, and inheritance.
     */
    logging?: DataAPILoggingConfig;
    /**
     * The keyspace to use for the database.
     *
     * There are a few rules for what the default keyspace will be:
     * 1. If a keyspace was provided when creating the {@link DataAPIClient}, it will default to that value.
     * 2. If using an `astra` database, it'll default to "default_keyspace".
     * 3. Otherwise, no default will be set, and it'll be on the user to provide one when necessary.
     *
     * The client itself will not throw an error if an invalid keyspace (or even no keyspace at all) is provided—it'll
     * let the Data API propagate the error itself.
     *
     * Every db method will use this keyspace as the default keyspace, but they all allow you to override it
     * in their options.
     *
     * @example
     * ```typescript
     * const client = new DataAPIClient('AstraCS:...');
     *
     * // Using 'default_keyspace' as the keyspace
     * const db1 = client.db('https://<db_id>-<region>.apps.astra.datastax.com');
     *
     * // Using 'my_keyspace' as the keyspace
     * const db2 = client.db('https://<db_id>-<region>.apps.astra.datastax.com', {
     *   keyspace: 'my_keyspace',
     * });
     *
     * // Finds 'my_collection' in 'default_keyspace'
     * const coll1 = db1.collections('my_collection');
     *
     * // Finds 'my_collection' in 'my_keyspace'
     * const coll2 = db1.collections('my_collection');
     *
     * // Finds 'my_collection' in 'other_keyspace'
     * const coll3 = db1.collections('my_collection', { keyspace: 'other_keyspace' });
     * ```
     *
     * @defaultValue 'default_keyspace'
     */
    keyspace?: string | null;
    /**
     * The access token for the Data API, typically of the format `'AstraCS:...'`.
     *
     * If never provided, this will default to the token provided when creating the {@link DataAPIClient}.
     *
     * @example
     * ```typescript
     * const client = new DataAPIClient('strong-token');
     *
     * // Using 'strong-token' as the token
     * const db1 = client.db('https://<db_id>-<region>.apps.astra.datastax.com');
     *
     * // Using 'weaker-token' instead of 'strong-token'
     * const db2 = client.db('https://<db_id>-<region>.apps.astra.datastax.com', {
     *   token: 'weaker-token',
     * });
     * ```
     */
    token?: string | TokenProvider | null;
    /**
     * The path to the Data API, which is going to be `api/json/v1` for all Astra instances. However, it may vary
     * if you're using a different Data API-compatible endpoint.
     *
     * Defaults to `'api/json/v1'` if never provided. However, if it was provided when creating the {@link DataAPIClient},
     * it will default to that value instead.
     *
     * @defaultValue 'api/json/v1'
     */
    dataApiPath?: string;
    /**
     * Advanced & currently somewhat unstable features related to customizing the client's ser/des behavior at a lower level.
     *
     * Use with caution. See official DataStax documentation for more info.
     *
     * @beta
     */
    serdes?: DbSerDesConfig;
    /**
     * Additional headers to include in the HTTP requests to the DevOps API.
     *
     * @remarks
     * There are more than likely more official/structured ways to set any desired headers, such as through
     * {@link TokenProvider}s or {@link EmbeddingHeadersProvider}s. This is more of a last-resort option, such
     * as for enabling feature-flags or other non-standard headers.
     */
    additionalHeaders?: Record<string, string>;
    /**
     * ##### Overview
     *
     * The default timeout options for anything spawned by this {@link Db} instance.
     *
     * See {@link TimeoutDescriptor} for much more information about timeouts.
     *
     * @example
     * ```ts
     * // The request timeout for all operations is set to 1000ms.
     * const client = new DataAPIClient('...', {
     *   timeoutDefaults: { requestTimeoutMs: 1000 },
     * });
     *
     * // The request timeout for all operations borne from this Db is set to 2000ms.
     * const db = client.db('...', {
     *   timeoutDefaults: { requestTimeoutMs: 2000 },
     * });
     * ```
     *
     * ##### Inheritance
     *
     * The timeout options are inherited by all child classes, and can be overridden at any level, including the individual method level.
     *
     * Individual-method-level overrides can vary in behavior depending on the method; again, see {@link TimeoutDescriptor}.
     *
     * ##### Defaults
     *
     * The default timeout options are as follows:
     * - `requestTimeoutMs`: 10000
     * - `generalMethodTimeoutMs`: 30000
     * - `collectionAdminTimeoutMs`: 60000
     * - `tableAdminTimeoutMs`: 30000
     * - `databaseAdminTimeoutMs`: 600000
     * - `keyspaceAdminTimeoutMs`: 30000
     *
     * @see TimeoutDescriptor
     */
    timeoutDefaults?: Partial<TimeoutDescriptor>;
}

/**
 * ##### Overview
 *
 * The config for common table/collection serialization/deserialization logic.
 *
 * Such custom logic may be used for various purposes, such as:
 * - Integrating your own custom data types
 * - Validating data before it's sent to the database, or after it's received
 * - Adding support for datatypes not yet supported by the client
 *
 * ##### Disclaimer
 *
 * This is an advanced feature, and should be used with caution. It's possible to break the client's behavior by using this feature incorrectly.
 *
 * These features are currently generally unstable, and should generally not be used in production (except for a couple, such as `mutateInPlace` or `enableBigNumbers`).
 *
 * See the official DataStax documentation for more info.
 *
 * @see CollectionSerDesConfig
 * @see TableSerDesConfig
 * @see $SerializeForCollections
 * @see $SerializeForTables
 *
 * @beta
 */
export declare interface DbSerDesConfig {
    /**
     * Advanced & currently somewhat unstable features related to customizing spawned tables' ser/des behavior at a lower level.
     *
     * Use with caution. See official DataStax documentation for more info.
     *
     * @beta
     */
    table?: Omit<TableSerDesConfig, 'mutateInPlace'>;
    /**
     * Advanced & currently somewhat unstable features related to customizing spawned collections' ser/des behavior at a lower level.
     *
     * Use with caution. See official DataStax documentation for more info.
     *
     * @beta
     */
    collection?: Omit<CollectionSerDesConfig, 'mutateInPlace'>;
    /**
     * ##### Overview
     *
     * Enables an optimization which allows inserted rows/documents to be mutated in-place when serializing.
     *
     * ##### Context
     *
     * For example, when you insert a record like so:
     * ```ts
     * import { uuid } from '@datastax/astra-db-ts';
     * await collection.insertOne({ name: 'Alice', friends: { john: uuid('...') } });
     * ```
     *
     * The document is internally serialized as such:
     * ```ts
     * { name: 'Alice', friends: { john: { $uuid: '...' } } }
     * ```
     *
     * To avoid mutating a user-provided object, the client will be forced to clone any objects that contain
     * a custom datatype, as well as their parents (which looks something like this):
     * ```ts
     * { ...original, friends: { ...original.friends, john: { $uuid: '...' } } }
     * ```
     *
     * ##### Enabling this option
     *
     * This can be a minor performance hit, especially for large objects, so if you're confident that you won't be
     * needing the object after it's inserted, you can enable this option to avoid the cloning, and instead mutate
     * the object in-place.
     *
     * @example
     * ```ts
     * // Before
     * const collection = db.collection<User>('users');
     *
     * const doc = { name: 'Alice', friends: { john: uuid(4) } };
     * await collection.insertOne(doc);
     *
     * console.log(doc); // { name: 'Alice', friends: { john: UUID<4>('...') } }
     *
     * // After
     * const collection = db.collection<User>('users', {
     *   serdes: { mutateInPlace: true },
     * });
     *
     * const doc = { name: 'Alice', friends: { john: UUID.v4() } };
     * await collection.insertOne(doc);
     *
     * console.log(doc); // { name: 'Alice', friends: { john: { $uuid: '...' } } }
     * ```
     *
     * @defaultValue false
     */
    mutateInPlace?: boolean;
}

/**
 * The default keyspace used when no keyspace is explicitly provided on DB creation.
 *
 * @public
 */
export declare const DEFAULT_KEYSPACE = "default_keyspace";

/**
 * The options available for the {@link DataAPIClient} related to making HTTP requests using the default http client.
 *
 * If loading the default client fails, and httpOptions is set, it'll throw an {@link FailedToLoadDefaultClientError}.
 *
 * If loading the default client fails, and httpOptions is not set, it'll silently fall back to the native fetch API.
 *
 * If you're minifying your code, you'll need to provide the fetch-h2 module manually (see
 * {@link DefaultHttpClientOptions.fetchH2}).
 *
 * See the `astra-db-ts` README for more information on different clients.
 *
 * https://github.com/datastax/astra-db-ts
 *
 * @public
 */
export declare interface DefaultHttpClientOptions {
    /**
     * Use the default http client for making HTTP requests (currently fetch-h2).
     *
     * Leave undefined to use the default client (you don't need to specify `'default'`).
     */
    client?: 'default';
    /**
     * Whether to prefer HTTP/2 for requests to the Data API; if set to `false`, HTTP/1.1 will be used instead.
     *
     * **Note that this is only available when using the Data API; the DevOps API does not support HTTP/2**
     *
     * Both versions are generally interchangeable, but HTTP2 is generally recommended for better performance.
     *
     * Defaults to `true` if never provided.
     *
     * @defaultValue true
     */
    preferHttp2?: boolean;
    /**
     * Options specific to HTTP/1.1 requests.
     */
    http1?: Http1Options;
    /**
     * The fetch-h2 module to use for making HTTP requests.
     *
     * Leave undefined to use the default module.
     */
    fetchH2?: unknown;
}

/**
 * An abstract class representing *some* exception that occurred related to the DevOps API. This is the base class for all
 * DevOps API errors, and will never be thrown directly.
 *
 * Useful for `instanceof` checks.
 *
 * @public
 */
export declare abstract class DevOpsAPIError extends Error {
}

/**
 * A representation of what went wrong when interacting with the DevOps API.
 *
 * @field id - The API-specific error code.
 * @field message - A user-friendly error message, if one exists (it most often does).
 *
 * @public
 */
export declare interface DevOpsAPIErrorDescriptor {
    /**
     * The API-specific error code.
     */
    id: number;
    /**
     * A user-friendly error message, if one exists (it most often does).
     */
    message?: string;
}

/* Excluded from this release type: DevOpsAPIHttpClient */

declare interface DevOpsAPIHttpClientOpts extends HTTPClientOptions {
    tokenProvider: TokenProvider | undefined;
}

/* Excluded from this release type: DevOpsAPIRequestInfo */

declare interface DevopsAPIResponse {
    data?: Record<string, any>;
    headers: Record<string, string>;
    status: number;
}

/**
 * An error representing a response from the DevOps API that was not successful (non-2XX status code).
 *
 * @field errors - The error descriptors returned by the API to describe what went wrong.
 * @field rootError - The raw axios error that was thrown.
 * @field status - The HTTP status code of the response, if available.
 *
 * @public
 */
export declare class DevOpsAPIResponseError extends DevOpsAPIError {
    /**
     * The error descriptors returned by the API to describe what went wrong.
     */
    readonly errors: DevOpsAPIErrorDescriptor[];
    /**
     * The HTTP status code of the response, if available.
     */
    readonly status: number;
    /**
     * The "raw", errored response from the API.
     */
    readonly raw: FetcherResponseInfo;
    /* Excluded from this release type: __constructor */
}

/**
 * An error thrown when an admin operation timed out.
 *
 * Depending on the method, this may be a request timeout occurring during a specific HTTP request, or can happen over
 * the course of a method involving several requests in a row, such as a blocking `createDatabase`.
 *
 * @field url - The URL that the request was made to.
 * @field timeout - The timeout that was set for the operation, in milliseconds.
 *
 * @public
 */
export declare class DevOpsAPITimeoutError extends DevOpsAPIError {
    /**
     * The URL that the request was made to.
     */
    readonly url: string;
    /**
     The timeout that was set for the operation, in milliseconds.
     */
    readonly timeout: Partial<TimeoutDescriptor>;
    readonly timedOutTypes: TimedOutCategories;
    /* Excluded from this release type: __constructor */
    static mk(info: HTTPRequestInfo, types: TimedOutCategories): DevOpsAPITimeoutError;
}

/**
 * Error thrown when the DevOps API returns is in an unexpected state (i.e. `'PARKED'` when `'ACTIVE'` or `'PENDING'`
 * was expected).
 *
 * @field dbInfo - The complete database info, which includes the status of the database.
 * @field status - The HTTP status code of the response, if available.
 *
 * @public
 */
export declare class DevOpsUnexpectedStateError extends DevOpsAPIError {
    /**
     * The expected states that were not met.
     */
    readonly expected: string[];
    /**
     * The complete database info, which includes the status of the database.
     */
    readonly dbInfo?: Record<string, any>;
    /* Excluded from this release type: __constructor */
}

/**
 * Represents the options for dropping a database (i.e. blocking options + timeout options).
 *
 * @public
 */
export declare type DropAstraDatabaseOptions = AstraAdminBlockingOptions & WithTimeout<'databaseAdminTimeoutMs'>;

/**
 * Options for dropping a collections.
 *
 * @field keyspace - Overrides the keyspace for the collections.
 * @field timeout - The timeout override for this method
 *
 * @see Db.dropCollection
 *
 * @public
 */
export declare interface DropCollectionOptions extends WithTimeout<'collectionAdminTimeoutMs'>, WithKeyspace {
}

/**
 * An operation to drop columns from the table.
 *
 * @public
 */
export declare interface DropColumnOperation<Schema extends SomeRow> {
    /**
     * The columns to drop from the table.
     */
    columns: (keyof Schema)[];
}

/**
 * The options for dropping a table (via {@link Db.dropTable}).
 *
 * @public
 */
export declare interface DropTableOptions extends WithTimeout<'tableAdminTimeoutMs'>, WithKeyspace {
    /**
     * If `true`, no error will be thrown if the table does not exist.
     *
     * Defaults to `false`.
     */
    ifExists?: boolean;
}

/**
 * An operation to disable vectorize (auto-embedding-generation) on existing vector columns on the table.
 *
 * @public
 */
export declare interface DropVectorizeOperation<Schema extends SomeRow> {
    /**
     * The columns to disable vectorize on.
     */
    columns: (keyof Schema)[];
}

/**
 * A shorthand function for `new DataAPIDuration(duration)`
 *
 * @public
 */
export declare const duration: (duration: string) => DataAPIDuration;

/**
 * The most basic embedding header provider, used for the vast majority of providers.
 *
 * Generally, anywhere this can be used in the public `astra-db-ts` interfaces, you may also pass in a plain
 * string or null/undefined, which is transformed into an {@link EmbeddingAPIKeyHeaderProvider} under the hood.
 *
 * @example
 * ```typescript
 * const provider = new EmbeddingAPIKeyHeaderProvider('api-key');
 * const collections = await db.collections('my_coll', { embeddingApiKey: provider });
 *
 * // or just
 *
 * const collections = await db.collections('my_coll', { embeddingApiKey: 'api-key' });
 * ```
 *
 * @see EmbeddingHeadersProvider
 *
 * @public
 */
export declare class EmbeddingAPIKeyHeaderProvider extends EmbeddingHeadersProvider {
    #private;
    /**
     * Constructs an instead of the {@link EmbeddingAPIKeyHeaderProvider}.
     *
     * @param apiKey - The api-key/token to regurgitate in `getTokenAsString`
     */
    constructor(apiKey: string | nullish);
    /**
     * Returns the proper header for the default embedding header authentication, or an empty record if `apiKey` was undefined.
     *
     * @returns the proper header for the default embedding header authentication.
     */
    getHeaders(): Record<string, string>;
}

/**
 * The base class for an "embedding headers provider", a general concept for anything that provides headers used for
 * vectorize operations on a per-call basis, whether the headers be static, dynamically fetched at runtime, or
 * periodically refreshed/cycled.
 *
 * The {@link EmbeddingHeadersProvider.getHeaders} function is called for every request to the Data API, regardless
 * of if vectorize is being utilized or not. Note that this is called for every individual request on multipart
 * operations, such as insertMany or find.
 *
 * `astra-db-ts` provides all the main embedding headers providers you may ever need to use, but you're able to extend
 * this class to create your own if you find it necessary.
 *
 * Generally, where you can pass in a `EmbeddingHeadersProvider`, you may also pass in a plain string which is
 * translated into an {@link EmbeddingAPIKeyHeaderProvider} under the hood.
 *
 * @example
 * ```typescript
 * // Using explicit `EmbeddingHeadersProvider`
 * const provider = new AWSEmbeddingHeadersProvider('access-key-id', 'secret-access-key');
 * const coll1 = await db.collections('my_coll1', { embeddingApiKey: provider });
 *
 * // Implicitly converted to `EmbeddingAPIKeyHeaderProvider`
 * const coll2 = await db.collections('my_coll2', { embeddingApiKey: 'sk-...' });
 * ```
 *
 * @see EmbeddingAPIKeyHeaderProvider
 * @see AWSEmbeddingHeadersProvider
 *
 * @public
 */
export declare abstract class EmbeddingHeadersProvider {
    /**
     * The function which provides the headers.
     *
     * It may do any I/O as it wishes to obtain/refresh the token, as it's called for every request to the Data API.
     *
     * If no promise is returned, it will not be awaited (no minor performance impact).
     */
    abstract getHeaders(): Promise<Record<string, string>> | Record<string, string>;
    /* Excluded from this release type: parseHeaders */
}

/**
 * Information about a specific auth method, such as `HEADER`, `SHARED_SECRET`, or `NONE` for a specific provider. See
 * {@link EmbeddingProviderInfo.supportedAuthentication} for more information.
 *
 * See {@link EmbeddingHeadersProvider} for more info about the `HEADER` auth through the client.
 *
 * @example
 * ```typescript
 * // openai.supportedAuthentication.HEADER:
 * {
 *   enabled: true,
 *   tokens: [{
 *     accepted: 'x-embedding-api-key',
 *     forwarded: 'Authorization',
 *   }],
 * }
 * ```
 *
 * @field enabled - Whether this method of auth is supported for the provider.
 * @field tokens - Additional info on how exactly this method of auth is supposed to be used.
 *
 * @see EmbeddingProviderInfo
 *
 * @public
 */
export declare interface EmbeddingProviderAuthInfo {
    /**
     * Whether this method of auth is supported for the provider.
     */
    enabled: boolean;
    /**
     * Additional info on how exactly this method of auth is supposed to be used.
     *
     * See {@link EmbeddingHeadersProvider} for more info about the `HEADER` auth through the client.
     *
     * Will be an empty array if `enabled` is `false`.
     */
    tokens: EmbeddingProviderTokenInfo[];
}

/**
 * Info about a specific embedding provider
 *
 * @field displayName - The prettified name of the provider (as shown in the portal)
 * @field url - The embeddings endpoint used for the provider
 * @field supportedAuthentication - Enabled methods of auth for the provider
 * @field parameters - Any additional parameters the provider may take in
 * @field models - The specific models that the provider supports
 *
 * @see FindEmbeddingProvidersResult
 *
 * @public
 */
export declare interface EmbeddingProviderInfo {
    /**
     * The prettified name of the provider (as shown in the Astra portal).
     *
     * @example
     * ```typescript
     * // openai.displayName:
     * 'OpenAI'
     * ```
     */
    displayName: string;
    /**
     * The embeddings endpoint used for the provider.
     *
     * May use a Python f-string-style string interpolation pattern for certain providers which take in additional
     * parameters (such as `huggingfaceDedicated` or `azureOpenAI`).
     *
     * @example
     * ```typescript
     * // openai.url:
     * 'https://api.openai.com/v1/'
     *
     * // huggingfaceDedicated.url:
     * 'https://{endpointName}.{regionName}.{cloudName}.endpoints.huggingface.cloud/embeddings'
     * ```
     */
    url: string;
    /**
     * Supported methods of authentication for the provider.
     *
     * Possible methods include `HEADER`, `SHARED_SECRET`, and `NONE`.
     *
     * - `HEADER`: Authentication using direct API keys passed through headers on every Data API call.
     * See {@link EmbeddingHeadersProvider} for more info.
     * ```typescript
     * const collections = await db.createCollection('my_coll', {
     *   vector: {
     *     service: {
     *       provider: 'openai',
     *       modelName: 'text-embedding-3-small',
     *       authentication: {
     *         // Name of the key in Astra portal's OpenAI integration (KMS).
     *         providerKey: '*KEY_NAME*',
     *       },
     *     },
     *   },
     * });
     * ```
     *
     * - `SHARED_SECRET`: Authentication tied to a collections at collections creation time using the Astra KMS.
     * ```typescript
     * const collections = await db.collections('my_coll', {
     *   // Not tied to the collections; can be different every time.
     *   embeddingApiKey: 'sk-...',
     * });
     * ```
     *
     * - `NONE`: For when a client doesn't need authentication to use (e.g. nvidia).
     * ```typescript
     * const collections = await db.createCollection('my_coll', {
     *   vector: {
     *     service: {
     *       provider: 'nvidia',
     *       modelName: 'NV-Embed-QA',
     *     },
     *   },
     * });
     * ```
     *
     * @example
     * ```typescript
     * // openai.supportedAuthentication.HEADER:
     * {
     *   enabled: true,
     *   tokens: [{
     *     accepted: 'x-embedding-api-key',
     *     forwarded: 'Authorization',
     *   }],
     * }
     * ```
     */
    supportedAuthentication: Record<string, EmbeddingProviderAuthInfo>;
    /**
     * Any additional, arbitrary parameters the provider may take in. May or may not be required.
     *
     * Passed into the `parameters` block in {@link VectorizeServiceOptions} (except for `vectorDimension`).
     *
     * @example
     * ```typescript
     * // openai.parameters[1]
     * {
     *   name: 'projectId',
     *   type: 'STRING',
     *   required: false,
     *   defaultValue: '',
     *   validation: {},
     *   help: 'Optional, OpenAI Project ID. If provided passed as `OpenAI-Project` header.',
     * }
     * ```
     */
    parameters: EmbeddingProviderProviderParameterInfo[];
    /**
     * The specific models that the provider supports.
     *
     * May include an `endpoint-defined-model` for some providers, such as `huggingfaceDedicated`, where the model
     * may be truly arbitrary.
     *
     * @example
     * ```typescript
     * // nvidia.models[0]
     * {
     *   name: 'NV-Embed-QA',
     *   vectorDimension: 1024,
     *   parameters: [],
     * }
     *
     * // huggingfaceDedicated.models[0]
     * {
     *   name: 'endpoint-defined-model',
     *   vectorDimension: null,
     *   parameters: [{
     *     name: 'vectorDimension',
     *     type: 'number',
     *     required: true,
     *     defaultValue: '',
     *     validation: {
     *       numericRange: [2, 3072],
     *     },
     *     help: 'Vector dimension to use in the database, should be the same as ...',
     *   }],
     * }
     * ```
     */
    models: EmbeddingProviderModelInfo[];
}

/**
 * The specific models that the provider supports.
 *
 * May include an `endpoint-defined-model` for some providers, such as `huggingfaceDedicated`, where the model
 * may be truly arbitrary.
 *
 * @example
 * ```typescript
 * // nvidia.models[0]
 * {
 *   name: 'NV-Embed-QA',
 *   vectorDimension: 1024,
 *   parameters: [],
 * }
 * ```
 *
 * @field name - The name of the model to use
 * @field vectorDimension - The preset, exact vector dimension to be used (if applicable)
 * @field parameters - Any additional parameters the model may take in
 *
 * @see EmbeddingProviderInfo
 *
 * @public
 */
export declare interface EmbeddingProviderModelInfo {
    /**
     * The name of the model to use.
     *
     * May be `endpoint-defined-model` for some providers, such as `huggingfaceDedicated`, where the model
     * may be truly arbitrary.
     *
     * @example
     * ```typescript
     * // openai.models[0].name
     * 'text-embedding-3-small'
     *
     * // huggingfaceDedicated.models[0].name
     * 'endpoint-defined-model'
     * ```
     */
    name: string;
    /**
     * The preset, exact vector dimension to be used (if applicable).
     *
     * If not present, a `vectorDimension` parameter will be present in the `model.parameters` block.
     *
     * @example
     * ```typescript
     * // openai.models[3].vectorDimension (text-embedding-ada-002)
     * 1536
     *
     * // huggingfaceDedicated.models[0].vectorDimension (endpoint-defined-model)
     * null
     * ```
     */
    vectorDimension: number | null;
    /**
     * Any additional, arbitrary parameters the modem may take in. May or may not be required.
     *
     * Passed into the `parameters` block in {@link VectorizeServiceOptions} (except for `vectorDimension`).
     *
     * @example
     * ```typescript
     * // openai.models[0].parameters[0] (text-embedding-3-small)
     * {
     *   name: 'vectorDimension',
     *   type: 'number',
     *   required: true,
     *   defaultValue: '1536',
     *   validation: { numericRange: [2, 1536] },
     *   help: 'Vector dimension to use in the database and when calling OpenAI.',
     * }
     * ```
     */
    parameters: EmbeddingProviderModelParameterInfo[];
}

/**
 * Info about any additional, arbitrary parameter the model may take in. May or may not be required.
 *
 * Passed into the `parameters` block in {@link VectorizeServiceOptions} (except for `vectorDimension`, which should be
 * set in the upper-level `dimension: number` field).
 *
 * @example
 * ```typescript
 * // openai.parameters[1]
 * {
 *   name: 'vectorDimension',
 *   type: 'number',
 *   required: true,
 *   defaultValue: '1536',
 *   validation: { numericRange: [2, 1536] },
 *   help: 'Vector dimension to use in the database and when calling OpenAI.',
 * }
 * ```
 *
 * @field name - The name of the parameter to be passed in.
 * @field type - The datatype of the parameter.
 * @field required - Whether the parameter is required to be passed in.
 * @field defaultValue - The default value of the provider, or an empty string if there is none.
 * @field validation - Validations that may be done on the inputted value.
 * @field help - Any additional help text/information about the parameter.
 *
 * @see EmbeddingProviderInfo
 * @see EmbeddingProviderModelInfo
 *
 * @public
 */
export declare interface EmbeddingProviderModelParameterInfo {
    /**
     * The name of the parameter to be passed in.
     *
     * The one exception is the `vectorDimension` parameter, which should be passed into the `dimension` field of the
     * `vector` block in {@link VectorOptions}.
     *
     * @example
     * ```typescript
     * // huggingface.parameters[0].name
     * endpointName
     * ```
     */
    name: string;
    /**
     * The datatype of the parameter.
     *
     * Commonly `number` or `STRING`.
     *
     * @example
     * ```typescript
     * // huggingface.parameters[0].type
     * STRING
     * ```
     */
    type: string;
    /**
     * Whether the parameter is required to be passed in.
     *
     * @example
     * ```typescript
     * // huggingface.parameters[0].required
     * true
     * ```
     */
    required: boolean;
    /**
     * The default value of the provider, or an empty string if there is none.
     *
     * Will always be in string form (even if the `type` is `'number'`).
     *
     * @example
     * ```typescript
     * // huggingface.parameters[0].defaultValue
     * ''
     * ```
     */
    defaultValue: string;
    /**
     * Validations that may be done on the inputted value.
     *
     * Commonly either an empty record, or `{ numericRange: [<min>, <max>] }`.
     *
     * @example
     * ```typescript
     * // huggingface.parameters[0].validation
     * {}
     * ```
     */
    validation: Record<string, unknown>[];
    /**
     * Any additional help text/information about the parameter.
     *
     * @example
     * ```typescript
     * // huggingface.parameters[0].help
     * 'The name of your Hugging Face dedicated endpoint, the first part of the Endpoint URL.'
     * ```
     */
    help: string;
}

/**
 * Info about any additional, arbitrary parameter the provider may take in. May or may not be required.
 *
 * Passed into the `parameters` block in {@link VectorizeServiceOptions} (except for `vectorDimension`, which should be
 * set in the upper-level `dimension: number` field).
 *
 * @example
 * ```typescript
 * // openai.parameters[1]
 * {
 *   name: 'projectId',
 *   type: 'STRING',
 *   required: false,
 *   defaultValue: '',
 *   validation: {},
 *   help: 'Optional, OpenAI Project ID. If provided passed as `OpenAI-Project` header.',
 *   displayName: 'Organization ID',
 *   hint: 'Add an (optional) organization ID',
 * }
 * ```
 *
 * @field name - The name of the parameter to be passed in.
 * @field type - The datatype of the parameter.
 * @field required - Whether the parameter is required to be passed in.
 * @field defaultValue - The default value of the provider, or an empty string if there is none.
 * @field validation - Validations that may be done on the inputted value.
 * @field help - Any additional help text/information about the parameter.
 * @field displayName - Display name for the parameter.
 * @field hint - Hint for parameter usage.
 *
 * @see EmbeddingProviderInfo
 * @see EmbeddingProviderModelInfo
 *
 * @public
 */
export declare interface EmbeddingProviderProviderParameterInfo extends EmbeddingProviderModelParameterInfo {
    /**
     * Display name for the parameter.
     *
     * @example
     * ```typescript
     * // openai.parameters[0].displayName
     * 'Organization ID'
     * ```
     */
    displayName: string;
    /**
     * Hint for parameter usage.
     *
     * @example
     * ```typescript
     * // openai.parameters[0].hint
     * 'Add an (optional) organization ID'
     * ```
     */
    hint: string;
}

/**
 * Info on how exactly a method of auth may be used.
 *
 * @example
 * ```typescript
 * // openai.supportedAuthentication.HEADER.tokens[0]:
 * {
 *   accepted: 'x-embedding-api-key',
 *   forwarded: 'Authorization',
 * }
 * ```
 *
 * @field accepted - The accepted token
 * @field forwarded - How the token is forwarded to the embedding provider
 *
 * @see EmbeddingProviderAuthInfo
 *
 * @public
 */
export declare interface EmbeddingProviderTokenInfo {
    /**
     * The accepted token.
     *
     * May most often be `providerKey` for `SHARED_SECRET`, or `x-embedding-api-key` for `HEADER`.
     *
     * See {@link EmbeddingHeadersProvider} for more info about the `HEADER` auth through the client.
     */
    accepted: string;
    /**
     * How the token is forwarded to the embedding provider.
     */
    forwarded: string;
}

declare type EmissionStrategy<Kind extends ClientKind> = (logger: Logger) => {
    emitCommandStarted?(info: DataAPIRequestInfo, opts: ExecCmdOpts<Kind>): void;
    emitCommandFailed?(info: DataAPIRequestInfo, error: Error, started: number, opts: ExecCmdOpts<Kind>): void;
    emitCommandSucceeded?(info: DataAPIRequestInfo, resp: RawDataAPIResponse, started: number, opts: ExecCmdOpts<Kind>): void;
    emitCommandWarnings?(info: DataAPIRequestInfo, warnings: DataAPIErrorDescriptor[], opts: ExecCmdOpts<Kind>): void;
};

/* Excluded declaration from this release type: EmissionStrategy */

/**
 * Utility type to represent an empty object without eslint complaining.
 *
 * @public
 */
export declare type EmptyObj = {};

/* Excluded from this release type: ExecCmdOpts */

declare type Expand<T> = T extends infer O ? {
    [K in keyof O]: O[K];
} : never;

/**
 * Error thrown when the default fetch-h2 client fails to load.
 *
 * @public
 */
export declare class FailedToLoadDefaultClientError extends Error {
    /**
     * Root error that caused the failure to load the default client.
     */
    readonly rootCause: Error;
    /* Excluded from this release type: __constructor */
}

/* Excluded from this release type: FetchCtx */

/**
 * A simple adapter interface that allows you to define a custom http client that `astra-db-ts` may use to make requests.
 *
 * See [FetchH2](https://github.com/datastax/astra-db-ts/blob/master/src/api/fetch/fetch-h2.ts) and
 * [FetchNative](https://github.com/datastax/astra-db-ts/blob/master/src/api/fetch/fetch-native.ts) for example
 * implementations.
 *
 * @public
 */
export declare interface Fetcher {
    /**
     * Makes the actual API request for the given request information. Please take all request information into account
     * when making the request, or you may run into errors or unexpected behavior from your implementation.
     *
     * @param info - The request information (url, body, method, headers, etc.)
     */
    fetch(info: FetcherRequestInfo): Promise<FetcherResponseInfo>;
    /**
     * Optional method which may destroy any resources, if necessary. Called on {@link DataAPIClient.close}.
     */
    close?(): Promise<void>;
}

/**
 * The information required to make a request with a {@link Fetcher}. Please take all request information into account
 * when making the request, or you may run into errors or unexpected behavior from your implementation.
 *
 * @public
 */
export declare interface FetcherRequestInfo {
    /**
     * The full URL to make the request to.
     */
    url: string;
    /**
     * The JSON.stringified body of the request, if it exists. Make sure you're settings the content-type
     * as `application/json` if applicable.
     */
    body: string | undefined;
    /**
     * The HTTP method to use for the request.
     */
    method: 'DELETE' | 'GET' | 'POST';
    /**
     * The base headers to include in the request (you may add or even override your own as necessary)
     */
    headers: Record<string, string>;
    /**
     * Whether to force HTTP/1.1 for the request. This is important as the DevOps API does not support HTTP/2, and thus
     * you may need to force HTTP/1.1 for certain requests if you're using a client that prefers HTTP/2.
     */
    forceHttp1: boolean | undefined;
    /**
     * Creates the timeout error for the request (you may need to first catch your own timeout error and then call this
     * method to create the new ubiquitous error).
     */
    mkTimeoutError: () => Error;
    /**
     * The timeout in milliseconds for the request.
     */
    timeout: number;
}

/**
 * Response object from an API call made by a {@link Fetcher}.
 *
 * @public
 */
export declare interface FetcherResponseInfo {
    /**
     * The string body of the response, if it exists.
     */
    body?: string;
    /**
     * The headers of the response.
     */
    headers: Record<string, string>;
    /**
     * The HTTP status code of the response.
     */
    status: number;
    /**
     * The HTTP version used for the request.
     */
    httpVersion: 1 | 2;
    /**
     * The URL that the request was made to.
     */
    url: string;
    /**
     * The status text for the response.
     */
    statusText: string;
    /**
     * Any additional attributes that may be included in the response (for use w/ custom {@link Fetcher} implementations).
     *
     * This is mainly for any potential logging or debugging information that may be useful for the user.
     */
    additionalAttributes?: Record<string, any>;
}

/**
 * Fetcher implementation which uses `fetch-h2` to perform HTTP/1.1 or HTTP/2 calls. Generally more performant than
 * the native fetch API, but less portable.
 *
 * @public
 */
export declare class FetchH2 implements Fetcher {
    private readonly _http1;
    private readonly _preferred;
    private readonly _timeoutErrorCls;
    constructor(options: DefaultHttpClientOptions | undefined, preferHttp2: boolean);
    /**
     * Performances the necessary HTTP request using the desired HTTP version.
     */
    fetch(info: FetcherRequestInfo): Promise<FetcherResponseInfo>;
    /**
     * Explicitly releases any underlying network resources held by the `fetch-h2` context.
     */
    close(): Promise<void>;
}

/**
 * The options available for the {@link DataAPIClient} related to making HTTP requests using the native fetch API.
 *
 * This will be the fallback client if the default client fails to load/if the default client is not available.
 *
 * See the `astra-db-ts` README for more information on different clients.
 *
 * https://github.com/datastax/astra-db-ts
 *
 * @public
 */
export declare interface FetchHttpClientOptions {
    /**
     * Use the native fetch API for making HTTP requests.
     */
    client: 'fetch';
}

/**
 * Fetcher implementation which uses the native fetch API to perform HTTP calls. Much more portable
 * than {@link FetchH2}, though may be less performant.
 *
 * @public
 */
export declare class FetchNative implements Fetcher {
    /**
     Performances the necessary HTTP request.
     */
    fetch(info: FetcherRequestInfo): Promise<FetcherResponseInfo>;
    /**
     * No-op since the native fetch API has no resources to clean up
     */
    close(): Promise<void>;
}

/**
 * Represents a generic filter type.
 *
 * See {@link CollectionFilter} & {@link TableFilter} for the more specific filter types.
 *
 * @public
 */
export declare type Filter = Record<string, any>;

/**
 * Lazily iterates over the results of some generic `find` operation using a Data API.
 *
 * **Shouldn't be directly instantiated, but rather created via {@link Collection.find}**.
 *
 * Typed as `FindCursor<T, TRaw>` where `T` is the type of the mapped records and `TRaw` is the type of the raw
 * records before any mapping. If no mapping function is provided, `T` and `TRaw` will be the same type. Mapping
 * is done using the {@link FindCursor.map} method.
 *
 * Options may be set either through the `find({}, options)` method, or through the various fluent option-setting
 * methods, which, ***unlike Mongo***, do not mutate the existing cursor, but rather return a new, uninitialized cursor
 * with the new option(s) set. This means that option methods may be called even after the cursor is started.
 *
 * @example
 * ```typescript
 * interface Person {
 *   firstName: string,
 *   lastName: string,
 *   age: number,
 * }
 *
 * const collection = db.collection<Person>('people');
 * const cursor1: Cursor<Person> = collection.find().filter({ firstName: 'John' });
 *
 * // Lazily iterate all documents matching the filter
 * for await (const doc of cursor1) {
 *   console.log(doc);
 * }
 *
 * // Rewind the cursor to be able to iterate again
 * cursor1.rewind();
 *
 * // Get all documents matching the filter as an array
 * const docs = await cursor1.toArray();
 *
 * // Immutably set options & map as needed (changing options returns a new, uninitialized cursor)
 * const cursor2: Cursor<string> = cursor
 *   .project<Omit<Person, 'age'>>({ age: 0 })
 *   .map(doc => doc.firstName + ' ' + doc.lastName);
 *
 * // Get next document from cursor
 * const doc = await cursor2.next();
 * ```
 *
 * @public
 */
export declare abstract class FindCursor<T, TRaw extends SomeDoc = SomeDoc> {
    #private;
    /* Excluded from this release type: __constructor */
    /**
     * The table/collection which spawned this cursor.
     *
     * @returns The table/collection which spawned this cursor.
     */
    get dataSource(): Table<SomeRow> | Collection;
    /**
     * Whether the cursor is closed, whether it be manually, or because the cursor is exhausted.
     *
     * @returns Whether or not the cursor is closed.
     */
    get state(): FindCursorStatus;
    /**
     * Returns the number of raw records in the buffer.
     *
     * Unless the cursor was closed before the buffer was completely read, the total number of records retrieved from the
     * server is equal to ({@link FindCursor.consumed} + {@link FindCursor.buffered}).
     *
     * @returns The number of raw records in the buffer.
     */
    buffered(): number;
    /**
     * Returns the number of records that have been read be the user from the cursor.
     *
     * Unless the cursor was closed before the buffer was completely read, the total number of records retrieved from the
     * server is equal to ({@link FindCursor.consumed} + {@link FindCursor.buffered}).
     *
     * @returns The number of records that have been read be the user from the cursor.
     */
    consumed(): number;
    /**
     * Consumes up to `max` records from the buffer, or all records if `max` is not provided.
     *
     * **Note that this actually consumes the buffer; it doesn't just peek at it.**
     *
     * @param max - The maximum number of records to read from the buffer. If not provided, all records will be read.
     *
     * @returns The records read from the buffer.
     */
    consumeBuffer(max?: number): TRaw[];
    /**
     * Sets the filter for the cursor, overwriting any previous filter.
     *
     * *NB. This method does **NOT** mutate the cursor, and may be called even after the cursor is started; it simply
     * returns a new, uninitialized cursor with the given new filter set.*
     *
     * @param filter - A filter to select which records to return.
     *
     * @returns A new cursor with the new filter set.
     */
    filter(filter: Filter): FindCursor<T, TRaw>;
    /**
     * Sets the sort criteria for prioritizing records.
     *
     * *NB. This method does **NOT** mutate the cursor, and may be called even after the cursor is started; it simply
     * returns a new, uninitialized cursor with the given new sort set.*
     *
     * @param sort - The sort order to prioritize which records are returned.
     *
     * @returns A new cursor with the new sort set.
     */
    sort(sort: Sort): FindCursor<T, TRaw>;
    /**
     * Sets the maximum number of records to return.
     *
     * If `limit == 0`, there will be no limit on the number of records returned.
     *
     * *NB. This method does **NOT** mutate the cursor, and may be called even after the cursor is started; it simply
     * returns a new, uninitialized cursor with the given new limit set.*
     *
     * @param limit - The limit for this cursor.
     *
     * @returns A new cursor with the new limit set.
     */
    limit(limit: number): FindCursor<T, TRaw>;
    /**
     * Sets the number of records to skip before returning.
     *
     * *NB. This method does **NOT** mutate the cursor, and may be called even after the cursor is started; it simply
     * returns a new, uninitialized cursor with the given new skip set.*
     *
     * @param skip - The skip for the cursor query.
     *
     * @returns A new cursor with the new skip set.
     */
    skip(skip: number): FindCursor<T, TRaw>;
    /**
     * Sets the projection for the cursor, overwriting any previous projection.
     *
     * *NB. This method does **NOT** mutate the cursor, and may be called even after the cursor is started; it simply
     * returns a new, uninitialized cursor with the given new projection set.*
     *
     * **To properly type this method, you should provide a type argument to specify the shape of the projected
     * records.**
     *
     * **Note that you may NOT provide a projection after a mapping is already provided, to prevent potential
     * de-sync errors.** If you really want to do so, you may use {@link FindCursor.clone} to create a new cursor
     * with the same configuration, but without the mapping, and then set the projection.
     *
     * @example
     * ```typescript
     * const cursor = table.find({ name: 'John' });
     *
     * // T is `any` because the type is not specified
     * const rawProjected = cursor.project({ id: 0, name: 1 });
     *
     * // T is { name: string }
     * const projected = cursor.project<{ name: string }>({ id: 0, name: 1 });
     *
     * // You can also chain instead of using intermediate variables
     * const fluentlyProjected = table
     *   .find({ name: 'John' })
     *   .project<{ name: string }>({ id: 0, name: 1 });
     *
     * // It's important to keep mapping in mind
     * const mapProjected = table
     *   .find({ name: 'John' })
     *   .map(doc => doc.name);
     *   .project<string>({ id: 0, name: 1 });
     * ```
     *
     * @param projection - Specifies which fields should be included/excluded in the returned records.
     *
     * @returns A new cursor with the new projection set.
     */
    project<RRaw extends SomeDoc = Partial<TRaw>>(projection: Projection): FindCursor<RRaw, RRaw>;
    /**
     * Sets whether similarity scores should be included in the cursor's results.
     *
     * *NB. This method does **NOT** mutate the cursor, and may be called even after the cursor is started; it simply
     * returns a new, uninitialized cursor with the given new similarity setting.*
     *
     * @param includeSimilarity - Whether similarity scores should be included.
     *
     * @returns A new cursor with the new similarity setting.
     */
    includeSimilarity(includeSimilarity?: boolean): FindCursor<WithSim<TRaw>, WithSim<TRaw>>;
    /**
     * Sets whether the sort vector should be fetched on the very first API call. Note that this is a requirement
     * to use {@link FindCursor.getSortVector}—it'll unconditionally return `null` if this is not set to `true`.
     *
     * *NB. This method does **NOT** mutate the cursor, and may be called even after the cursor is started; it simply
     * returns a new, uninitialized cursor with the given new setting.*
     *
     * @param includeSortVector - Whether the sort vector should be fetched on the first API call
     *
     * @returns A new cursor with the new sort vector inclusion setting.
     */
    includeSortVector(includeSortVector?: boolean): FindCursor<T, TRaw>;
    /**
     * Map all records using the provided mapping function. Previous mapping functions will be composed with the new
     * mapping function (new ∘ old).
     *
     * *NB. This method does **NOT** mutate the cursor, and may be called even after the cursor is started; it simply
     * returns a new, uninitialized cursor with the given new mapping set.*
     *
     * **You may NOT set a projection after a mapping is already provided, to prevent potential de-sync errors.** If you
     * really want to do so, you may use {@link FindCursor.clone} to create a new cursor with the same configuration, but
     * without the mapping, and then set the projection.
     *
     * @param mapping - The mapping function to apply to all records.
     *
     * @returns A new cursor with the new mapping set.
     */
    map<R>(mapping: (doc: T) => R): FindCursor<R, TRaw>;
    /**
     * Returns a new, uninitialized cursor with the same filter and options set on this cursor. No state is shared between
     * the two cursors; only the configuration.
     *
     * Like mongo, mapping functions are *not* cloned.
     *
     * @returns A behavioral clone of this cursor.
     */
    clone(): FindCursor<TRaw, TRaw>;
    /**
     * Rewinds the cursor to its uninitialized state, clearing the buffer and any state. Any configuration set on the
     * cursor will remain, but iteration will start from the beginning, sending new queries to the server, even if the
     * resultant data was already fetched by this cursor.
     */
    rewind(): void;
    /**
     * Fetches the next record from the cursor. Returns `null` if there are no more records to fetch.
     *
     * If the cursor is uninitialized, it will be initialized. If the cursor is closed, this method will return `null`.
     *
     * @returns The next record, or `null` if there are no more records.
     */
    next(): Promise<T | null>;
    /**
     * Tests if there is a next record in the cursor.
     *
     * If the cursor is uninitialized, it will be initialized. If the cursor is closed, this method will return `false`.
     *
     * @returns Whether or not there is a next record.
     */
    hasNext(): Promise<boolean>;
    /**
     * Retrieves the vector used to perform the vector search, if applicable.
     *
     * - If `includeSortVector` is not `true`, this will unconditionally return `null`. No find request will be made.
     *
     * - If `sort: { $vector }` was used, `getSortVector()` will simply regurgitate that same `$vector`.
     *
     * - If `sort: { $vectorize }` was used, `getSortVector()` will return the `$vector` that was created from the text.
     *
     * - If vector search is not used, `getSortVector()` will simply return `null`. A find request will still be made.
     *
     * If `includeSortVector` is `true`, and this function is called before any other cursor operation (such as
     * `.next()` or `.toArray()`), it'll make an API request to fetch the sort vector, filling the cursor's buffer
     * in the process.
     *
     * If the cursor has already been executed before this function has been called, no additional API request
     * will be made to fetch the sort vector, as it has already been cached.
     *
     * But to reiterate, if `includeSortVector` is `false`, and this function is called, no API request is made, and
     * the cursor's buffer is not populated; it simply returns `null`.
     *
     * @returns The sort vector, or `null` if none was used (or if `includeSortVector !== true`).
     */
    getSortVector(): Promise<DataAPIVector | null>;
    /**
     * An async iterator that lazily iterates over all records in the cursor.
     *
     * **Note that there'll only be partial results if the cursor has been previously iterated over. You may use {@link FindCursor.rewind}
     * to reset the cursor.**
     *
     * If the cursor is uninitialized, it will be initialized. If the cursor is closed, this method will return immediately.
     *
     * It will close the cursor when iteration is complete, even if it was broken early.
     *
     * @example
     * ```typescript
     * for await (const doc of cursor) {
     *   console.log(doc);
     * }
     * ```
     */
    [Symbol.asyncIterator](): AsyncGenerator<T, void, void>;
    /**
     * Iterates over all records in the cursor, calling the provided consumer for each record.
     *
     * If the consumer returns `false`, iteration will stop.
     *
     * Note that there'll only be partial results if the cursor has been previously iterated over. You may use {@link FindCursor.rewind}
     * to reset the cursor.
     *
     * If the cursor is uninitialized, it will be initialized. If the cursor is closed, this method will return immediately.
     *
     * It will close the cursor when iteration is complete, even if it was stopped early.
     *
     * @param consumer - The consumer to call for each record.
     *
     * @returns A promise that resolves when iteration is complete.
     */
    forEach(consumer: ((doc: T) => boolean) | ((doc: T) => void)): Promise<void>;
    /**
     * Returns an array of all matching records in the cursor. The user should ensure that there is enough memory to
     * store all records in the cursor.
     *
     * Note that there'll only be partial results if the cursor has been previously iterated over. You may use {@link FindCursor.rewind}
     * to reset the cursor.
     *
     * If the cursor is uninitialized, it will be initialized. If the cursor is closed, this method will return an empty array.
     *
     * @returns An array of all records in the cursor.
     */
    toArray(): Promise<T[]>;
    /**
     * Closes the cursor. The cursor will be unusable after this method is called, or until {@link FindCursor.rewind} is called.
     */
    close(): void;
}

/**
 * Represents the status of a cursor.
 *
 * | Status         | Description                                                                        |
 * |----------------|------------------------------------------------------------------------------------|
 * | `idle`         | The cursor is uninitialized/not in use, and may be modified freely.                |
 * | `started`      | The cursor is currently in use, and cannot be modified w/out rewinding or cloning. |
 * | `closed`       | The cursor is closed, and cannot be used w/out rewinding or cloning.               |
 *
 * @public
 *
 * @see FindCursor.state
 */
export declare type FindCursorStatus = 'idle' | 'started' | 'closed';

/**
 * The overarching result containing the `embeddingProviders` map.
 *
 * @field embeddingProviders - Map of embedding provider names to info about said provider.
 *
 * @see DbAdmin.findEmbeddingProviders
 *
 * @public
 */
export declare interface FindEmbeddingProvidersResult {
    /**
     * A map of embedding provider names (e.g. `openai`), to information about said provider (e.g. models/auth).
     *
     * @example
     * ```typescript
     * {
     *   openai: {
     *     displayName: 'OpenAI',
     *     ...,
     *   }
     * }
     * ```
     */
    embeddingProviders: Record<string, EmbeddingProviderInfo>;
}

/**
 * Represents a flattened version of the given type. Only goes one level deep.
 *
 * @public
 */
export declare type Flatten<Type> = Type extends (infer Item)[] ? Item : Type;

/**
 * Represents a document as it's returned by the database by default.
 *
 * Shorthand type for `WithSim` & `WithId`.
 *
 * @public
 */
export declare type FoundDoc<Doc> = WithId<Omit<Doc, '$vector' | '$vectorize'>>;

/**
 * Represents a row as it's returned by the database by default.
 *
 * Ensures that all `DataAPIVector` fields are just returned as `DataAPIVector`, and not `DataAPIVector | string` in case vectorize is enabled on any of the vector columns.
 *
 * @public
 */
export declare type FoundRow<Doc> = {
    [K in keyof Doc]-?: DataAPIVector extends Doc[K] ? Exclude<Doc[K], string> : Doc[K];
};

/**
 * @public
 */
export declare interface FullCreateTablePrimaryKeyDefinition {
    readonly partitionBy: readonly string[];
    readonly partitionSort?: Record<string, 1 | -1>;
}

/**
 * Represents the result of some generic `deleteMany` command.
 *
 * @field deletedCount - The number of deleted documents. Can be any non-negative integer.
 *
 * @public
 */
export declare interface GenericDeleteManyResult {
    /**
     * The number of deleted documents.
     */
    deletedCount: number;
}

/**
 * Represents the options for some generic `deleteOne` command.
 *
 * @field sort - The sort order to pick which document to delete if the filter selects multiple documents.
 * @field timeout - The timeout override for this method
 *
 * @public
 */
export declare interface GenericDeleteOneOptions extends WithTimeout<'generalMethodTimeoutMs'> {
    sort?: Sort;
}

/**
 * Represents the result of some generic `deleteOne` command.
 *
 * @field deletedCount - The number of deleted documents. Can be either 0 or 1.
 *
 * @public
 */
export declare interface GenericDeleteOneResult {
    deletedCount: 0 | 1;
}

/**
 * Represents the options for the `findOneAndDelete` command.
 *
 * @field sort - The sort order to pick which document to delete if the filter selects multiple documents.
 * @field projection - Specifies which fields should be included/excluded in the returned documents.
 * @field timeout - The timeout override for this method
 *
 * @see Collection.findOneAndDelete
 *
 * @public
 */
export declare interface GenericFindOneAndDeleteOptions extends WithTimeout<'generalMethodTimeoutMs'> {
    /**
     * The order in which to apply the update if the filter selects multiple documents.
     *
     * If multiple documents match the filter, only one will be updated.
     *
     * Defaults to `null`, where the order is not guaranteed.
     * @defaultValue null
     */
    sort?: Sort;
    /**
     * Specifies which fields should be included/excluded in the returned documents.
     *
     * If not specified, all fields are included.
     *
     * When specifying a projection, it's the user's responsibility to handle the return type carefully, as the
     * projection will, of course, affect the shape of the returned documents. It may be a good idea to cast
     * the returned documents into a type that reflects the projection to avoid runtime errors.
     *
     * @example
     * ```typescript
     * interface User {
     *   name: string;
     *   age: number;
     * }
     *
     * const collection = db.collection<User>('users');
     *
     * const doc = await collection.findOne({}, {
     *   projection: {
     *     _id: 0,
     *     name: 1,
     *   },
     *   vector: [.12, .52, .32],
     *   includeSimilarity: true,
     * }) as { name: string, $similarity: number };
     *
     * // Ok
     * console.log(doc.name);
     * console.log(doc.$similarity);
     *
     * // Causes type error
     * console.log(doc._id);
     * console.log(doc.age);
     * ```
     */
    projection?: Projection;
}

/**
 * Represents the options for the `findOneAndReplace` command.
 *
 * @field returnDocument - Specifies whether to return the original or updated document.
 * @field upsert - If true, perform an insert if no documents match the filter.
 * @field sort - The sort order to pick which document to replace if the filter selects multiple documents.
 * @field projection - Specifies which fields should be included/excluded in the returned documents.
 * @field timeout - The timeout override for this method
 *
 * @see Collection.findOneAndReplace
 *
 * @public
 */
export declare interface GenericFindOneAndReplaceOptions extends WithTimeout<'generalMethodTimeoutMs'> {
    /**
     * Specifies whether to return the document before or after the update.
     *
     * Set to `before` to return the document before the update to see the original state of the document.
     *
     * Set to `after` to return the document after the update to see the updated state of the document immediately.
     *
     * Defaults to `'before'`.
     *
     * @defaultValue 'before'
     */
    returnDocument?: 'before' | 'after';
    /**
     * If true, perform an insert if no documents match the filter.
     *
     * If false, do not insert if no documents match the filter.
     *
     * Defaults to false.
     *
     * @defaultValue false
     */
    upsert?: boolean;
    /**
     * The order in which to apply the update if the filter selects multiple documents.
     *
     * If multiple documents match the filter, only one will be updated.
     *
     * Defaults to `null`, where the order is not guaranteed.
     *
     * @defaultValue null
     */
    sort?: Sort;
    /**
     * Specifies which fields should be included/excluded in the returned documents.
     *
     * If not specified, all fields are included.
     *
     * When specifying a projection, it's the user's responsibility to handle the return type carefully, as the
     * projection will, of course, affect the shape of the returned documents. It may be a good idea to cast
     * the returned documents into a type that reflects the projection to avoid runtime errors.
     *
     * @example
     * ```typescript
     * interface User {
     *   name: string;
     *   age: number;
     * }
     *
     * const collection = db.collection<User>('users');
     *
     * const doc = await collection.findOne({}, {
     *   projection: {
     *     _id: 0,
     *     name: 1,
     *   },
     *   vector: [.12, .52, .32],
     *   includeSimilarity: true,
     * }) as { name: string, $similarity: number };
     *
     * // Ok
     * console.log(doc.name);
     * console.log(doc.$similarity);
     *
     * // Causes type error
     * console.log(doc._id);
     * console.log(doc.age);
     * ```
     */
    projection?: Projection;
}

/**
 * Represents the options for the `findOneAndUpdate` command.
 *
 * @field returnDocument - Specifies whether to return the original or updated document.
 * @field upsert - If true, perform an insert if no documents match the filter.
 * @field sort - The sort order to pick which document to replace if the filter selects multiple documents.
 * @field projection - Specifies which fields should be included/excluded in the returned documents.
 * @field includeResultMetadata - When true, returns alongside the document, an `ok` field with a value of 1 if the command executed successfully.
 * @field timeout - The timeout override for this method
 *
 * @see Collection.findOneAndUpdate
 *
 * @public
 */
export declare interface GenericFindOneAndUpdateOptions extends WithTimeout<'generalMethodTimeoutMs'> {
    /**
     * Specifies whether to return the document before or after the update.
     *
     * Set to `before` to return the document before the update to see the original state of the document.
     *
     * Set to `after` to return the document after the update to see the updated state of the document immediately.
     *
     * Defaults to `'before'`.
     *
     * @defaultValue 'before'
     */
    returnDocument?: 'before' | 'after';
    /**
     * If true, perform an insert if no documents match the filter.
     *
     * If false, do not insert if no documents match the filter.
     *
     * Defaults to false.
     * @defaultValue false
     */
    upsert?: boolean;
    /**
     * The order in which to apply the update if the filter selects multiple documents.
     *
     * If multiple documents match the filter, only one will be updated.
     *
     * Defaults to `null`, where the order is not guaranteed.
     * @defaultValue null
     */
    sort?: Sort;
    /**
     * Specifies which fields should be included/excluded in the returned documents.
     *
     * If not specified, all fields are included.
     *
     * When specifying a projection, it's the user's responsibility to handle the return type carefully, as the
     * projection will, of course, affect the shape of the returned documents. It may be a good idea to cast
     * the returned documents into a type that reflects the projection to avoid runtime errors.
     *
     * @example
     * ```typescript
     * interface User {
     *   name: string;
     *   age: number;
     * }
     *
     * const collection = db.collection<User>('users');
     *
     * const doc = await collection.findOne({}, {
     *   projection: {
     *     _id: 0,
     *     name: 1,
     *   },
     *   vector: [.12, .52, .32],
     *   includeSimilarity: true,
     * }) as { name: string, $similarity: number };
     *
     * // Ok
     * console.log(doc.name);
     * console.log(doc.$similarity);
     *
     * // Causes type error
     * console.log(doc._id);
     * console.log(doc.age);
     * ```
     */
    projection?: Projection;
}

/**
 * Represents the options for some generic `findOne` command.
 *
 * @field sort - The sort order to pick which document to return if the filter selects multiple documents.
 * @field projection - Specifies which fields should be included/excluded in the returned documents.
 * @field includeSimilarity - If true, include the similarity score in the result via the `$similarity` field.
 * @field timeout - The timeout override for this method
 *
 * @public
 */
export declare interface GenericFindOneOptions extends WithTimeout<'generalMethodTimeoutMs'> {
    /**
     * The order in which to apply the update if the filter selects multiple records.
     *
     * Defaults to `null`, where the order is not guaranteed.
     */
    sort?: Sort;
    /**
     * The projection to apply to the returned records, to specify only a select set of fields to return.
     *
     * If using a projection, it is heavily recommended to provide a custom type for the returned records as a generic typeparam to the `find` method.
     */
    projection?: Projection;
    /**
     * If true, include the similarity score in the result via the `$similarity` field.
     */
    includeSimilarity?: boolean;
}

/**
 * Options for some generic `find` command.
 *
 * @field sort - The sort order to pick which document to return if the filter selects multiple documents.
 * @field projection - Specifies which fields should be included/excluded in the returned documents.
 * @field limit - Max number of documents to return in the lifetime of the cursor.
 * @field skip - Number of documents to skip if using a sort.
 * @field includeSimilarity - If true, include the similarity score in the result via the `$similarity` field.
 *
 * @public
 */
export declare interface GenericFindOptions extends WithTimeout<'generalMethodTimeoutMs'> {
    /**
     * The order in which to apply the update if the filter selects multiple records.
     *
     * Defaults to `null`, where the order is not guaranteed.
     */
    sort?: Sort;
    /**
     * The projection to apply to the returned records, to specify only a select set of fields to return.
     *
     * If using a projection, it is heavily recommended to provide a custom type for the returned records as a generic typeparam to the `find` method.
     */
    projection?: Projection;
    /**
     * The maximum number of records to return in the lifetime of the cursor.
     *
     * Defaults to `null`, which means no limit.
     */
    limit?: number;
    /**
     * The number of records to skip before starting to return records.
     *
     * Defaults to `null`, which means no skip.
     */
    skip?: number;
    /**
     * If true, include the similarity score in the result via the `$similarity` field.
     */
    includeSimilarity?: boolean;
    /**
     * If true, the sort vector will be available through `await cursor.getSortVector()`
     */
    includeSortVector?: boolean;
}

/* Excluded from this release type: GenericInsertManyDocumentResponse */

/**
 * Options for a generic `insertMany` command using the Data API.
 *
 * The parameters depend on the `ordered` option. If `ordered` is `true`, the `parallel` option is not allowed.
 *
 * @field ordered - If `true`, the records are inserted sequentially; else, they're arbitrary inserted in parallel.
 * @field concurrency - The maximum number of concurrent requests to make at once.
 * @field chunkSize - The number of records to upload per request. Defaults to 20.
 * @field timeout - The timeout override for this method
 *
 * @public
 */
export declare type GenericInsertManyOptions = GenericInsertManyUnorderedOptions | GenericInsertManyOrderedOptions;

/**
 * Options for a generic `insertMany` command using the Data API when `ordered` is `true`.
 *
 * @field ordered - If `true`, the records are inserted sequentially in the order provided.
 * @field chunkSize - The number of records to upload per request. Defaults to 50.
 * @field timeout - The timeout override for this method
 *
 * @see GenericInsertManyOptions
 *
 * @public
 */
export declare interface GenericInsertManyOrderedOptions extends WithTimeout<'generalMethodTimeoutMs'> {
    /**
     * If `true`, the records are inserted in the order provided. If an error occurs, the operation stops and the
     * remaining records are not inserted.
     */
    ordered: true;
    /**
     * The number of records to upload per request. Defaults to 50.
     *
     * If you have large records, you may find it beneficial to reduce this number and increase concurrency to
     * improve throughput. Leave it unspecified (recommended) to use the system default.
     *
     * @defaultValue 50
     */
    chunkSize?: number;
}

/* Excluded from this release type: GenericInsertManyResult */

/**
 * Options for a generic `insertMany` command using the Data API when `ordered` is `false` or unset.
 *
 * @field ordered - If `false` or unset, the records are inserted in an arbitrary, parallelized order.
 * @field concurrency - The maximum number of concurrent requests to make at once.
 * @field chunkSize - The number of records to upload per request. Defaults to 50.
 * @field timeout - The timeout override for this method
 *
 * @see Collection.insertMany
 *
 * @public
 */
export declare interface GenericInsertManyUnorderedOptions extends WithTimeout<'generalMethodTimeoutMs'> {
    /**
     * If `false`, the records are inserted in an arbitrary order. If an error occurs, the operation does not stop
     * and the remaining records are inserted. This allows the operation to be parallelized for better performance.
     */
    ordered?: false;
    /**
     * The maximum number of concurrent requests to make at once.
     */
    concurrency?: number;
    /**
     * The number of records to upload per request. Defaults to 50.
     *
     * If you have large records, you may find it beneficial to reduce this number and increase concurrency to
     * improve throughput. Leave it unspecified (recommended) to use the system default.
     *
     * @defaultValue 50
     */
    chunkSize?: number;
}

/* Excluded from this release type: GenericInsertOneResult */

/**
 * Represents the options for some generic `replaceOne` command.
 *
 * @field upsert - If true, perform an insert if no documents match the filter.
 * @field sort - The sort order to pick which document to replace if the filter selects multiple documents.
 * @field timeout - The timeout override for this method
 *
 * @public
 */
export declare interface GenericReplaceOneOptions extends WithTimeout<'generalMethodTimeoutMs'> {
    upsert?: boolean;
    sort?: Sort;
}

/**
 Options for some generic `updateMany` command
 *
 * @field upsert - If true, perform an insert if no documents match the filter.
 * @field timeout - The timeout override for this method
 *
 * @public
 */
export declare interface GenericUpdateManyOptions extends WithTimeout<'generalMethodTimeoutMs'> {
    upsert?: boolean;
}

/**
 * Options for a generic `updateOne` command using the Data API.
 *
 * @field upsert - If true, perform an insert if no documents match the filter.
 * @field sort - The sort order to pick which document to update if the filter selects multiple documents.
 * @field timeout - The timeout override for this method
 *
 * @public
 */
export declare interface GenericUpdateOneOptions extends WithTimeout<'generalMethodTimeoutMs'> {
    /**
     * If true, perform an insert if no documents match the filter.
     *
     * If false, do not insert if no documents match the filter.
     *
     * Defaults to false.
     *
     * @defaultValue false
     */
    upsert?: boolean;
    /**
     * The order in which to apply the update if the filter selects multiple documents.
     *
     * If multiple documents match the filter, only one will be updated.
     *
     * Defaults to `null`, where the order is not guaranteed.
     *
     * @defaultValue null
     */
    sort?: Sort;
}

/**
 * Represents the result of a generic `update` command using the Data API.
 *
 * @example
 * ```typescript
 * const result = await collection.updateOne({
 *   _id: 'abc'
 * }, {
 *   $set: { name: 'John' }
 * }, {
 *   upsert: true
 * });
 *
 * if (result.upsertedCount) {
 *   console.log(`Record with identifier ${JSON.stringify(result.upsertedId)} was upserted`);
 * }
 * ```
 *
 * @field matchedCount - The number of records that matched the filter.
 * @field modifiedCount - The number of records that were actually modified.
 * @field upsertedCount - The number of records that were upserted.
 * @field upsertedId - The identifier of the upserted record if `upsertedCount > 0`.
 *
 * @public
 */
export declare type GenericUpdateResult<ID, N extends number> = (GuaranteedUpdateResult<N> & UpsertedUpdateResult<ID>) | (GuaranteedUpdateResult<N> & NoUpsertUpdateResult);

/**
 * Represents the set of fields that are guaranteed to be present in the result of some generic `update` command using
 * the Data API
 *
 * @field matchedCount - The number of records that matched the filter.
 * @field modifiedCount - The number of records that were actually modified.
 *
 * @public
 */
export declare interface GuaranteedUpdateResult<N extends number> {
    /**
     * The number of records that matched the filter.
     */
    matchedCount: N;
    /**
     * The number of records that were actually modified.
     */
    modifiedCount: N;
}

/* Excluded from this release type: HeaderProvider */

/**
 * The options available for the {@link DataAPIClient} related to making HTTP/1.1 requests.
 *
 * @public
 */
export declare interface Http1Options {
    /**
     * Whether to keep the connection alive for future requests. This is generally recommended for better performance.
     *
     * Defaults to true.
     *
     * @defaultValue true
     */
    keepAlive?: boolean;
    /**
     * The delay (in milliseconds) before keep-alive probing.
     *
     * Defaults to 1000ms.
     *
     * @defaultValue 1000
     */
    keepAliveMS?: number;
    /**
     * Maximum number of sockets to allow per origin.
     *
     * Defaults to 256.
     *
     * @defaultValue 256
     */
    maxSockets?: number;
    /**
     * Maximum number of lingering sockets, waiting to be re-used for new requests.
     *
     * Defaults to Infinity.
     *
     * @defaultValue Infinity
     */
    maxFreeSockets?: number;
}

/* Excluded from this release type: HttpClient */

/* Excluded from this release type: HTTPClientOptions */

/* Excluded from this release type: HttpMethods */

/* Excluded from this release type: HttpMethodStrings */

/* Excluded from this release type: HTTPRequestInfo */

/**
 * Extracts the `_id` type from a given schema, or defaults to `SomeId` if uninferable
 *
 * @public
 */
export declare type IdOf<Doc> = Doc extends {
    _id?: infer Id extends SomeId;
} ? Id : SomeId;

/**
 * A shorthand function for `new InetAddress(addr, version?)`
 *
 * @public
 */
export declare const inet: (address: string, version?: 4 | 6) => InetAddress;

/**
 * Represents an `inet` column for Data API tables.
 *
 * You may use the {@link inet} function as a shorthand for creating a new `InetAddress`.
 *
 * See the official DataStax documentation for more information.
 *
 * @public
 */
export declare class InetAddress implements TableCodec<typeof InetAddress> {
    #private;
    /**
     * Implementation of `$SerializeForTable` for {@link TableCodec}
     */
    [$SerializeForTable](ctx: TableSerCtx): readonly [0, (string | undefined)?];
    /**
     * Implementation of `$DeserializeForTable` for {@link TableCodec}
     */
    static [$DeserializeForTable](value: any, ctx: TableDesCtx): readonly [0, (InetAddress | undefined)?];
    /**
     * Creates a new `InetAddress` instance from a vector-like value.
     *
     * If you pass a `version`, the value will be validated as an IPv4 or IPv6 address; otherwise, it'll be validated as
     * either, and the version will be inferred from the value.
     *
     * You can set `validate` to `false` to bypass any validation if you're confident the value is a valid inet address.
     *
     * @param address - The address to create the `InetAddress` from
     * @param version - The IP version to validate the address as
     * @param validate - Whether to actually validate the address
     *
     * @throws TypeError If the address is not a valid IPv4 or IPv6 address
     */
    constructor(address: string, version?: 4 | 6 | null, validate?: boolean);
    /**
     * Returns the IP version of the inet address.
     *
     * @returns The IP version of the inet address
     */
    get version(): 4 | 6;
    /**
     * Returns the string representation of the inet address.
     *
     * @returns The string representation of the inet address
     */
    toString(): string;
}

/**
 * The different possible types that a Table's schema may be inferred from using the {@link InferTableSchema}-like types,
 * when using {@link Db.createTable} or {@link Table.alter}.
 *
 * @see InferTableSchema
 * @see InferTablePrimaryKey
 *
 * @public
 */
export declare type InferrableTable = CreateTableDefinition | ((..._: any[]) => Promise<Table<SomeRow>>) | ((..._: any[]) => Table<SomeRow>) | Promise<Table<SomeRow>> | Table<SomeRow>;

declare type InferTablePKFromDefinition<FullDef extends CreateTableDefinition> = Normalize<MkPrimaryKeyType<FullDef, Cols2CqlTypes<FullDef['columns']>>>;

/**
 * Automagically extracts a table's primary key from some Table<Schema>-like type, most useful when performing a
 * {@link Db.createTable} (or {@link Table.alter}) operation.
 *
 * See {@link InferTableSchema} for more information & examples.
 *
 * @public
 */
export declare type InferTablePrimaryKey<T extends InferrableTable> = T extends CreateTableDefinition ? InferTablePKFromDefinition<T> : T extends (..._: any[]) => Promise<Table<any, infer PKey, any>> ? PKey : T extends (..._: any[]) => Table<any, infer PKey, any> ? PKey : T extends Promise<Table<any, infer PKey, any>> ? PKey : T extends Table<any, infer PKey, any> ? PKey : never;

/**
 * Automagically extracts a table's read-schema from some Table<Schema>-like type, most useful when performing a
 * {@link Db.createTable} (or {@link Table.alter}) operation.
 *
 * See {@link InferTableSchema} for more information & examples.
 *
 * @public
 */
export declare type InferTableReadSchema<T extends InferrableTable> = T extends CreateTableDefinition ? FoundRow<InferTableSchemaFromDefinition<T>> : T extends (..._: any[]) => Promise<Table<any, any, infer Schema>> ? Schema : T extends (..._: any[]) => Table<any, any, infer Schema> ? Schema : T extends Promise<Table<any, any, infer Schema>> ? Schema : T extends Table<any, any, infer Schema> ? Schema : never;

/**
 * Automagically extracts a table's schema from some Table<Schema>-like type, most useful when performing a
 * {@link Db.createTable} (or {@link Table.alter}) operation.
 *
 * You can think of it as similar to Zod or arktype's `infer<Schema>` types.
 *
 * Accepts various different (contextually) isomorphic types to account for differences in instantiation & usage:
 * - `CreateTableDefinition`
 * - `(...) => Promise<Table<infer Schema>>`
 * - `(...) => Table<infer Schema>`
 * - `Promise<Table<infer Schema>>`
 * - `Table<infer Schema>`
 *
 * A DB's type information is inferred by `db.createTable` by default. To override this
 * behavior, please provide the table's type explicitly to help with transpilation times (e.g.
 * `db.createTable<SomeRow>(...)`).
 *
 * @example
 * ```ts
 * const mkUserTable = () => db.createTable('users', {
 *   definition: {
 *     columns: {
 *       name: 'text',
 *       dob: {
 *         type: 'timestamp',
 *       },
 *       friends: {
 *         type: 'set',
 *         valueType: 'text',
 *       },
 *     },
 *     primaryKey: {
 *       partitionBy: ['name', 'height'],
 *       partitionSort: { dob: 1 },
 *     },
 *   },
 * });
 *
 * // Type inference is as simple as that
 * type User = InferTableSchema<typeof mkUserTable>;
 * type UserPK = InferTablePrimaryKey<typeof mkUserTable>;
 *
 * // Utility types for demonstration purposes
 * type Equal<X, Y> = (<T>() => T extends X ? 1 : 2) extends (<T>() => T extends Y ? 1 : 2) ? true : false;
 * type Expect<T extends true> = T;
 *
 * // User evaluates to this object representing its TS representation
 * // for the table's schema
 * type _Proof = Equal<User, {
 *   name: string,
 *   dob: DataAPITimestamp,
 *   friends: Set<string>,
 * }>;
 *
 * // UserPK evaluates to this object representing its TS representation
 * // for `insert*` operations' return types
 * type _ProofPK = Equal<UserPK, {
 *   name: string,
 *   height: TypeErr<'Field `height` not found as property in table definition'>,
 *   dob: DataAPITimestamp,
 * }>;
 *
 * // And now `User` can be used wherever.
 * const main = async () => {
 *   const table: Table<User> = await mkUserTable();
 *   const found: User | null = await table.findOne({});
 * };
 * ```
 *
 * @public
 */
export declare type InferTableSchema<T extends InferrableTable> = T extends CreateTableDefinition ? InferTableSchemaFromDefinition<T> : T extends (..._: any[]) => Promise<Table<infer Schema, any, any>> ? Schema : T extends (..._: any[]) => Table<infer Schema, any, any> ? Schema : T extends Promise<Table<infer Schema, any, any>> ? Schema : T extends Table<infer Schema, any, any> ? Schema : never;

declare type InferTableSchemaFromDefinition<FullDef extends CreateTableDefinition> = Normalize<MkColumnTypes<FullDef['columns'], MkPrimaryKeyType<FullDef, Cols2CqlTypes<FullDef['columns']>>>>;

/* Excluded from this release type: InternalRootClientOpts */

/**
 * An exception thrown when certain operations are attempted in a {@link DataAPIEnvironment} that is not valid.
 *
 * @field currentEnvironment - The environment that was attempted to be used
 * @field expectedEnvironments - The environments that are valid for the operation
 *
 * @public
 */
export declare class InvalidEnvironmentError extends Error {
    /**
     * The environment that was attempted to be used.
     */
    readonly currentEnvironment: string;
    /**
     * The environments that are valid for the operation.
     */
    readonly expectedEnvironments: string[];
    /* Excluded from this release type: __constructor */
}

/**
 * Checks if a type is any
 *
 * @public
 */
declare type IsAny<T> = true extends false & T ? true : false;

/**
 * Checks if a type can possibly be a date
 *
 * @example
 * ```typescript
 * IsDate<string | Date> === boolean
 * ```
 *
 * @public
 */
declare type IsDate<T> = IsAny<T> extends true ? true : T extends Date | {
    $date: number;
} ? true : false;

/**
 * Checks if a type can possibly be some number
 *
 * @example
 * ```typescript
 * IsNum<string | number> === true
 * ```
 *
 * @public
 */
declare type IsNum<T> = number extends T ? true : bigint extends T ? true : false;

/* Excluded from this release type: KeyspaceRef */

/**
 * Represents the replication options for a keyspace.
 *
 * Two replication strategies are available:
 *
 * - SimpleStrategy: Use only for a single datacenter and one rack. If you ever intend more than one datacenter, use the `NetworkTopologyStrategy`.
 *
 * - NetworkTopologyStrategy: Highly recommended for most deployments because it is much easier to expand to multiple datacenters when required by future expansion.
 *
 * If no replication options are provided, it will default to `'SimpleStrategy'` with a replication factor of `1`.
 *
 * @example
 * ```typescript
 * await dbAdmin.createKeyspace('my_keyspace');
 *
 * await dbAdmin.createKeyspace('my_keyspace', {
 *   replication: {
 *     class: 'SimpleStrategy',
 *     replicatonFactor: 3,
 *   },
 * });
 *
 * await dbAdmin.createKeyspace('my_keyspace', {
 *   replication: {
 *     class: 'NetworkTopologyStrategy',
 *     datacenter1: 3,
 *     datacenter1: 2,
 *   },
 * });
 * ```
 *
 * See the [datastax docs](https://docs.datastax.com/en/cassandra-oss/3.0/cassandra/architecture/archDataDistributeReplication.html) for more info.
 *
 * @public
 */
export declare type KeyspaceReplicationOptions = {
    class: 'SimpleStrategy';
    replicationFactor: number;
} | {
    class: 'NetworkTopologyStrategy';
    [datacenter: string]: number | 'NetworkTopologyStrategy';
};

/**
 * Represents the options for listing databases.
 *
 * @field include - Allows filtering so that databases in listed states are returned.
 * @field provider - Allows filtering so that databases from a given provider are returned.
 * @field limit - Specify the number of items for one page of data.
 * @field skip - Starting value for retrieving a specific page of results.
 *
 * @public
 */
export declare interface ListAstraDatabasesOptions extends WithTimeout<'databaseAdminTimeoutMs'> {
    /**
     * Allows filtering so that databases in listed states are returned.
     */
    include?: AstraDbStatusFilter;
    /**
     * Allows filtering so that databases from a given provider are returned.
     */
    provider?: AstraDbCloudProviderFilter;
    /**
     * Optional parameter for pagination purposes. Specify the number of items for one page of data.
     *
     * Should be between 1 and 100.
     *
     * Defaults to 25.
     *
     * @defaultValue 25
     */
    limit?: number;
    /**
     * Optional parameter for pagination purposes. Used as this value for starting retrieving a specific page of results.
     */
    skip?: number;
}

/**
 * Options for listing collections.
 *
 * @field nameOnly - If true, only the name of the collections is returned. If false, the full collections info is returned. Defaults to true.
 * @field keyspace - Overrides the keyspace to list collections from. If not provided, the default keyspace is used.
 * @field timeout - The timeout override for this method
 *
 * @see Db.listCollections
 *
 * @public
 */
export declare interface ListCollectionsOptions extends WithTimeout<'collectionAdminTimeoutMs'>, WithKeyspace {
    /**
     * If true, only the name of the collections is returned.
     *
     * If false, the full collections info is returned.
     *
     * Defaults to true.
     *
     * @example
     * ```typescript
     * const names = await db.listCollections({ nameOnly: true });
     * console.log(names); // [{ name: 'my_coll' }]
     *
     * const info = await db.listCollections({ nameOnly: false });
     * console.log(info); // [{ name: 'my_coll', options: { ... } }]
     * ```
     *
     * @defaultValue true
     */
    nameOnly?: boolean;
}

/**
 * @public
 */
export declare interface ListCreateTableColumnDefinition {
    type: 'list';
    valueType: TableScalarType;
}

declare interface ListIndexOptions extends WithTimeout<'tableAdminTimeoutMs'> {
    nameOnly?: boolean;
}

/**
 * @public
 */
export declare type ListTableColumnDefinitions = Record<string, ListTableKnownColumnDefinition | ListTableUnsupportedColumnDefinition>;

/**
 * @public
 */
export declare interface ListTableDefinition {
    columns: ListTableColumnDefinitions;
    primaryKey: ListTablePrimaryKeyDefinition;
}

/**
 * @public
 */
export declare type ListTableKnownColumnDefinition = StrictCreateTableColumnDefinition;

/**
 * @public
 */
export declare type ListTablePrimaryKeyDefinition = Required<FullCreateTablePrimaryKeyDefinition>;

/**
 * Options for listing tables.
 *
 * @field nameOnly - If true, only the name of the tables is returned. If false, the full tables info is returned. Defaults to true.
 * @field keyspace - Overrides the keyspace to list tables from. If not provided, the default keyspace is used.
 * @field timeout - The timeout override for this method
 *
 * @see Db.listTables
 *
 * @public
 */
export declare interface ListTablesOptions extends WithTimeout<'tableAdminTimeoutMs'>, WithKeyspace {
    /**
     * If true, only the name of the tables is returned.
     *
     * If false, the full tables info is returned.
     *
     * Defaults to true.
     *
     * @example
     * ```typescript
     * const names = await db.listTables({ nameOnly: true });
     * console.log(names); // [{ name: 'my_table' }]
     *
     * const info = await db.listTables({ nameOnly: false });
     * console.log(info); // [{ name: 'my_table', options: { ... } }]
     * ```
     *
     * @defaultValue true
     */
    nameOnly?: boolean;
}

/**
 * @public
 */
export declare interface ListTableUnsupportedColumnApiSupport {
    createTable: boolean;
    insert: boolean;
    read: boolean;
    cqlDefinition: string;
}

/**
 * @public
 */
export declare interface ListTableUnsupportedColumnDefinition {
    type: 'UNSUPPORTED';
    apiSupport: ListTableUnsupportedColumnApiSupport;
}

/* Excluded from this release type: Logger */

declare interface LongRunningRequestInfo {
    id: string | ((resp: DevopsAPIResponse) => string);
    target: string;
    legalStates: string[];
    defaultPollInterval: number;
    options: AstraAdminBlockingOptions | undefined;
    timeoutManager: TimeoutManager;
}

/**
 * @public
 */
export declare type LooseCreateTableColumnDefinition = TableScalarType | string;

/**
 * @public
 */
export declare interface MapCreateTableColumnDefinition {
    type: 'map';
    keyType: TableScalarType;
    valueType: TableScalarType;
}

/**
 * Allows the given type to include an `_id` or not, even if it's not declared in the type
 *
 * @public
 */
export declare type MaybeId<T> = NoId<T> & {
    _id?: IdOf<T>;
};

declare type Merge<Ts> = Expand<UnionToIntersection<Ts>>;

declare type MkColumnTypes<Cols extends CreateTableColumnDefinitions, PK extends Record<string, any>> = {
    -readonly [P in keyof Cols as P extends keyof PK ? P : never]-?: CqlType2TSType<PickCqlType<Cols[P]>, Cols[P]> & {};
} & {
    -readonly [P in keyof Cols as P extends keyof PK ? never : P]+?: CqlType2TSType<PickCqlType<Cols[P]>, Cols[P]>;
};

declare type MkPrimaryKeyType<FullDef extends CreateTableDefinition, Schema, PK extends FullCreateTablePrimaryKeyDefinition = NormalizePK<FullDef['primaryKey']>> = Normalize<{
    -readonly [P in PK['partitionBy'][number]]: P extends keyof Schema ? Schema[P] & {} : TypeErr<`Field \`${P}\` not found as property in table definition`>;
} & (PK['partitionSort'] extends object ? {
    -readonly [P in keyof PK['partitionSort']]: P extends keyof Schema ? Schema[P] & {} : TypeErr<`Field \`${P & string}\` not found as property in table definition`>;
} : EmptyObj)>;

/* Excluded from this release type: MkTimeoutError */

/**
 * @public
 */
export declare type NameCodec<Fns extends CodecSerDesFns> = {
    serialize?: Fns['serialize'];
    deserialize: Fns['deserialize'];
} & {
    codecType: 'name';
    name: string;
};

/**
 * Represents a doc that doesn't have an `_id`
 *
 * @public
 */
export declare type NoId<Doc> = Omit<Doc, '_id'>;

/**
 * A utility type to expand a type.
 *
 * @public
 */
export declare type Normalize<T> = {
    [K in keyof T]: T[K];
} & EmptyObj;

/* Excluded from this release type: NormalizedLoggingConfig */

declare type NormalizePK<PK extends CreateTablePrimaryKeyDefinition> = PK extends string ? {
    partitionBy: [PK];
} : PK;

/**
 * Represents the set of fields that are present in the result of some generic `update` command using the Data API where
 * no upsert occurred.
 *
 * @field upsertedCount - The number of records that were upserted.
 * @field upsertedId - This field is never present.
 *
 * @public
 */
export declare interface NoUpsertUpdateResult {
    /**
     * The number of records that were upserted. This will always be undefined, since none occurred.
     */
    upsertedCount: 0;
    /**
     * This field is never present.
     */
    upsertedId?: never;
}

/**
 * Shorthand type to represent some nullish value.
 *
 * @public
 */
export declare type nullish = null | undefined;

/**
 * Represents an ObjectId that can be used as an _id in the DataAPI.
 *
 * Provides methods for generating ObjectIds and getting the timestamp of an ObjectId.
 *
 * @example
 * ```typescript
 * const collections = await db.createCollection('myCollection'. {
 *   defaultId: {
 *     type: 'objectId',
 *   },
 * });
 *
 * await collections.insertOne({ album: 'Inhuman Rampage' });
 *
 * const doc = await collections.findOne({ album: 'Inhuman Rampage' });
 *
 * // Prints the ObjectId of the document
 * console.log(doc._id.toString());
 *
 * // Prints the timestamp when the document was created (server time)
 * console.log(doc._id.getTimestamp());
 * ```
 *
 * @example
 * ```typescript
 * await collections.insertOne({ _id: new ObjectId(), album: 'Sacrificium' });
 *
 * const doc = await collections.findOne({ album: 'Sacrificium' });
 *
 * // Prints the ObjectId of the document
 * console.log(doc._id.toString());
 *
 * // Prints the timestamp when the document was created (server time)
 * console.log(doc._id.getTimestamp());
 * ```
 *
 * @public
 */
export declare class ObjectId implements CollCodec<typeof ObjectId> {
    #private;
    /**
     * Implementation of `$SerializeForCollection` for {@link TableCodec}
     */
    [$SerializeForCollection](ctx: CollSerCtx): readonly [0, ({
        $objectId: string;
    } | undefined)?];
    /**
     * Implementation of `$DeserializeForCollection` for {@link TableCodec}
     */
    static [$DeserializeForCollection](_: string, value: any, ctx: CollDesCtx): readonly [0, (ObjectId | undefined)?];
    /**
     * Creates a new ObjectId instance.
     *
     * If `id` is provided, it must be a 24-character hex string. Otherwise, a new ObjectId is generated.
     *
     * @param id - The ObjectId string.
     * @param validate - Whether to validate the ObjectId string. Defaults to `true`.
     */
    constructor(id?: string | number | null, validate?: boolean);
    /**
     * Compares this ObjectId to another ObjectId.
     *
     * **The other ObjectId can be an ObjectId instance or a string.**
     *
     * An ObjectId is considered equal to another ObjectId if their string representations are equal.
     *
     * @param other - The ObjectId to compare to.
     *
     * @returns `true` if the ObjectIds are equal, `false` otherwise.
     */
    equals(other: unknown): boolean;
    /**
     * Returns the timestamp of the ObjectId.
     *
     * @returns The timestamp of the ObjectId.
     */
    getTimestamp(): Date;
    /**
     * Returns the string representation of the ObjectId.
     */
    toString(): string;
}

/**
 * A shorthand function for `new ObjectId(oid?)`
 *
 * @public
 */
export declare const oid: (id?: string | number | null) => ObjectId;

/**
 * Utility type to represent a value that can be either a single value or an array of values.
 *
 * @public
 */
export declare type OneOrMany<T> = T | readonly T[];

/* Excluded from this release type: Parser */

/**
 * @public
 */
export declare type PathCodec<Fns extends CodecSerDesFns> = {
    serialize?: Fns['serialize'];
    deserialize: Fns['deserialize'];
} & {
    codecType: 'path';
    path: string[];
};

declare type PickArrayTypes<Schema> = Extract<Schema, any[]> extends (infer E)[] ? E : unknown;

declare type PickCqlType<Def> = Def extends {
    type: infer Type;
} ? Type : Def;

/**
 * Specifies which fields should be included/excluded in the returned documents.
 *
 * **If you want stricter type-checking and full auto-complete, see {@link StrictProjection}.**
 *
 * Can use `1`/`0`, or `true`/`false`.
 *
 * There's a special field `'*'` that can be used to include/exclude all fields.
 *
 * @example
 * ```typescript
 * // Include _id, name, and address.state
 * const projection1: Projection = {
 *   _id: 0,
 *   name: 1,
 *   'address.state': 1,
 * }
 *
 * // Exclude the $vector
 * const projection2: Projection = {
 *   $vector: 0,
 * }
 *
 * // Return array indices 2, 3, 4, and 5
 * const projection3: Projection = {
 *   test_scores: { $slice: [2, 4] },
 * }
 * ```
 *
 * @public
 */
export declare type Projection = Record<string, 1 | 0 | boolean | ProjectionSlice>;

/**
 * Specifies the number of elements in an array to return in the query result.
 *
 * Has one of the following forms:
 * ```
 * // Return the first two elements
 * { $slice: 2 }
 *
 * // Return the last two elements
 * { $slice: -2 }
 *
 * // Skip 4 elements (from 0th index), return the next 2
 * { $slice: [4, 2] }
 *
 * // Skip backward 4 elements, return next 2 elements (forward)
 * { $slice: [-4, 2] }
 * ```
 *
 * @example
 * ```typescript
 * await collections.insertOne({ arr: [1, 2, 3, 4, 5] });
 *
 * // Return [1, 2]
 * await collections.findOne({}, {
 *   projection: {
 *     arr: { $slice: 2 },
 *   },
 * });
 *
 * // Return [3, 4]
 * await collections.findOne({}, {
 *   projection: {
 *     arr: { $slice: [-3, 2] },
 *   },
 * });
 * ```
 *
 * @public
 */
export declare interface ProjectionSlice {
    /**
     * Either of the following:
     * - A positive integer to return the first N elements
     * - A negative integer to return the last N elements
     * - A tuple of two integers to skip the first N elements and return the next M elements
     */
    $slice: number | [number, number];
}

/**
 * The response format of a 2XX-status Data API call
 *
 * @public
 */
export declare interface RawDataAPIResponse {
    /**
     * A response data holding documents that were returned as the result of a command.
     */
    status?: Record<string, any>;
    /**
     * Status objects, generally describe the side effects of commands, such as the number of updated or inserted documents.
     */
    errors?: any[];
    /**
     * Array of objects or null (Error)
     */
    data?: Record<string, any>;
}

/* Excluded from this release type: Ref */

/**
 * The default admin options as can be specified in the {@link DataAPIClientOptions}.
 *
 * See {@link AdminOptions} for more information on the available options.
 *
 * @public
 */
export declare type RootAdminOptions = Omit<AdminOptions, 'logging' | 'timeoutDefaults'>;

/**
 * The default db options as can be specified in the {@link DataAPIClientOptions}.
 *
 * See {@link DbOptions} for more information on the available options.
 *
 * @public
 */
export declare type RootDbOptions = Omit<DbOptions, 'logging' | 'timeoutDefaults'>;

/**
 * Options for executing some arbitrary command.
 *
 * @field collections - The collections to run the command on. If not provided, the command is run on the database.
 * @field keyspace - Overrides the keyspace to run the command in. If not provided, the default keyspace is used.
 *
 * @see Db.command
 *
 * @public
 */
export declare interface RunCommandOptions extends WithTimeout<'generalMethodTimeoutMs'> {
    /**
     * The collections to run the command on. If not provided, the command is run on the database.
     */
    collection?: string;
    table?: string;
    /**
     * The keyspace to use for the db operation.
     */
    keyspace?: string | null;
}

/**
 * @public
 */
export declare interface ScalarCreateTableColumnDefinition {
    type: TableScalarType;
}

/* Excluded from this release type: SerDes */

/**
 * @public
 */
export declare type SerDesFn<Ctx> = (key: string, value: any, ctx: Ctx) => readonly [0 | 1 | 2, any?, string?] | 'Return ctx.done(val?), ctx.recurse(val?), ctx.continue(), or void';

/**
 * @public
 */
export declare interface SetCreateTableColumnDefinition {
    type: 'set';
    valueType: TableScalarType;
}

/**
 * @public
 */
export declare type ShortCreateTablePrimaryKeyDefinition = string;

/**
 * Represents *some document*. It's not a base type, but rather more of a
 * bottom type which can represent any legal document, to give more dynamic
 * typing flexibility at the cost of enhanced typechecking/autocomplete.
 *
 * {@link Collection}s will default to this if no specific type is provided.
 *
 * @public
 */
export declare type SomeDoc = Record<string, any>;

/**
 * All possible types for a document ID. JSON scalar types, `Date`, `UUID`, and `ObjectId`.
 *
 * Note that the `_id` *can* technically be `null`. Trying to set the `_id` to `null` doesn't mean "auto-generate
 * an ID" like it may in some other databases; it quite literally means "set the ID to `null`".
 *
 * It's heavily recommended to properly type this in your Schema, so you know what to expect for your `_id` field.
 *
 * @public
 */
export declare type SomeId = string | number | bigint | boolean | Date | UUID | ObjectId | null;

/**
 * ##### Overview
 *
 * Represents *some row* in a table. This is a generic type that represents some (any) table row with any number & types
 * of columns. All it asks for is that the row be an object with string keys and any values.
 *
 * Equivalent to {@link SomeDoc} for collections.
 *
 * This can/will often be used as the "default", or "untyped" generic type when no specific/static type is provided/desired.
 * (e.g. `class Table<Schema extends SomeRow = SomeRow> { ... }`)
 *
 * ##### Disclaimer
 *
 * **Be careful when using this, as it is untyped and can lead to runtime errors if the row's structure is not as expected.**
 *
 * It can be an effective footgun (especially for tables, which are inherently typed), so it is recommended to use a
 * more specific type when possible.
 *
 * That is not to say it does not have its uses, from flexibility, to prototyping, to convenience, to working with
 * dynamic data, etc. Just be aware of the risks, especially for tables.
 *
 * @example
 * ```ts
 * const table = db.table<SomeRow>('my_table');
 *
 * await table.insertOne({
 *   'lets.you$insert': function () { return 'whatever you want' },
 * });
 * ```
 *
 * @see Table
 * @see SomeDoc
 * @see SomeTableKey
 *
 * @public
 */
export declare type SomeRow = Record<string, any>;

/**
 * Specifies the sort criteria for selecting documents.
 *
 * **If you want stricter type-checking and full auto-complete, see {@link StrictSort}.**
 *
 * Can use `1`/`-1` for ascending/descending, or `$vector` for sorting by vector distance.
 *
 * See {@link SortDirection} for all possible sort values.
 *
 * **NB. The order of the fields in the sort option is significant—fields are sorted in the order they are listed.**
 *
 * @example
 * ```typescript
 * // Sort by name in ascending order, then by age in descending order
 * const sort1: Sort = {
 *   name: 1,
 *   age: -1,
 * }
 *
 * // Sort by vector distance
 * const sort2: Sort = {
 *   $vector: [0.23, 0.38, 0.27, 0.91, 0.21],
 * }
 * ```
 *
 * @see SortDirection
 *
 * @public
 */
export declare type Sort = Record<string, SortDirection | number[] | DataAPIVector | string>;

/**
 * Allowed types to specify an ascending or descending sort.
 *
 * @public
 */
export declare type SortDirection = 1 | -1;

/**
 * The most basic token provider, which simply returns the token it was instantiated with.
 *
 * Generally, anywhere this can be used in the public `astra-db-ts` interfaces, you may also pass in a plain
 * string or null/undefined, which is transformed into a {@link StaticTokenProvider} under the hood.
 *
 * @example
 * ```typescript
 * const provider = new StaticTokenProvider('token');
 * const client = new DataAPIClient(provider);
 *
 * // or just
 *
 * const client = new DataAPIClient('token');
 * ```
 *
 * @see TokenProvider
 *
 * @public
 */
export declare class StaticTokenProvider extends TokenProvider {
    #private;
    /**
     * Constructs an instead of the {@link StaticTokenProvider}.
     *
     * @param token - The token to regurgitate in `getTokenAsString`
     */
    constructor(token: string);
    /**
     * Returns the string the token provider was instantiated with.
     *
     * @returns the string the token provider was instantiated with.
     */
    getToken(): string;
}

/**
 * @public
 */
export declare type StrictCreateTableColumnDefinition = ScalarCreateTableColumnDefinition | MapCreateTableColumnDefinition | ListCreateTableColumnDefinition | SetCreateTableColumnDefinition | VectorCreateTableColumnDefinition;

/**
 * #### Overview
 *
 * Represents the interface to a table in a Data-API-enabled database.
 *
 * **This shouldn't be directly instantiated, but rather created via {@link Db.createTable} or {@link Db.table}**.
 *
 * @example
 * ```ts
 * // Basic creation of a dynamically typed table
 * // (If you don't provide `SomeRow` explicitly, it will
 * // attempt to infer the Table's type from the definition)
 * const table = await db.createTable<SomeRow>('users', {
 *   definition: {
 *      columns: {
 *        id: 'text',
 *        name: 'text',
 *      },
 *      primaryKey: 'id',
 *   },
 * });
 *
 * // or (also dynamically typed)
 * const table = db.table('users');
 * ```
 *
 * #### Typing & Types
 *
 * **NOTE: For most intents & purposes (unless you're using custom ser/des), you can ignore the (generally negligible) difference between `WSchema` and `RSchema`, and treat `Table` as if it were typed as `Table<Schema, PKey>`**.
 *
 * A `Table` is typed as `Table<WSchema, PKey, RSchema>`, where:
 *  - `WSchema` is the type of the row as it's written to the table (the "write" schema)
 *    - This includes inserts, filters, sorts, etc.
 *  - `PKey` (optional) is the type of the primary key of the table as it's returned
 *  - `RSchema` is the type of the row as it's read from the table (the "read" schema)
 *    - This includes finds
 *    - Unless custom ser/des is used, it is nearly exactly the same as `WSchema`
 *    - It defaults to `FoundRow<WSchema>` (see {@link FoundRow})
 *
 * See {@link FoundRow} for more info about the differences, but again, for most intents & purposes, you can ignore this, and pretend they were
 *
 * ###### Custom datatypes
 *
 * Certain datatypes may be represented as TypeScript classes (some native, some provided by `astra-db-ts`), however.
 *
 * For example:
 *  - `'map<k, v>'` is represented by a native JS `Map<K, V>`
 *  - `'vector'` is represented by an `astra-db-ts` provided `DataAPIVector`
 *  - `'date'` is represented by an `astra-db-ts` provided `DataAPIDate`
 *
 * You may also provide your own datatypes by providing some custom serialization logic as well (see later section).
 *
 * @example
 * ```ts
 * interface User {
 *   id: string,
 *   friends: Map<string, UUID>, // UUID is also `astra-db-ts` provided
 *   vector: DataAPIVector,
 * }
 *
 * await db.table<User>('users').insertOne({
 *   id: '123',
 *   friends: new Map([['Alice', uuid(4)]]), // or UUID.v4()
 *   vector: vector([1, 2, 3]), // or new DataAPIVector([...])
 * });
 * ```
 *
 * ###### Big numbers disclaimer
 *
 * When `varint`s or `decimal`s are present in the schema, and when you're serializing `bigint`s and {@link BigNumber}s, it will automatically enable usage of a bignumber-friendly JSON library which is capable of serializing/deserializing these numbers without loss of precision, but is much slower than the native JSON library (but, realistically, the difference is likely negligible).
 *
 * ###### Typing the key
 *
 * The primary key of the table should be provided as a second type parameter to `Table`.
 *
 * This is a special type that is used to reconstruct the TS type of the primary key in insert operations. It should be an object with the same keys as the primary key columns, and the same types as the schema. Note that there is no distinction between partition and clustering keys in this type.
 *
 * @example
 * ```ts
 * interface User {
 *   id: string,   // Partition key
 *   dob: DataAPIDate, // Clustering (partition sort) key
 *   friends: Map<string, UUID>,
 * }
 *
 * type UserPK = Pick<User, 'id' | 'dob'>;
 *
 * // res.insertedId is of type { id: string }
 * const res = await db.table<User, UserPK>('users').insertOne({
 *   id: '123',
 *   dob: date(), // or new DataAPIDate(new Date())
 *   friends: new Map([['Alice', uuid(4)]]), // or UUID.v4()
 * });
 * ```
 *
 * ###### `db.createTable` type inference
 *
 * When creating a table through {@link Db.createTable}, and not using any custom datatypes (see next session), you can actually use the {@link InferTableSchema} & {@link InferTablePrimaryKey} utility types to infer the schema of the table from the table creation.
 *
 * @example
 * ```ts
 * // equivalent to:
 * // type User = {
 * //   id: string,
 * //   dob: DataAPIDate,
 * //   friends?: Map<string, UUID>, // Optional since it's not in the primary key
 * // }
 * type User = InferTableSchema<typeof mkTable>;
 *
 * // equivalent to:
 * // type UserPK = Pick<User, 'id' | 'dob'>;
 * type UserPK = InferTablePrimaryKey<typeof mkTable>;
 *
 * const mkTable = () => db.createTable('users', {
 *   definition: {
 *      columns: {
 *        id: 'text',
 *        dob: 'date',
 *        friends: { type: 'map', keyType: 'text', valueType: 'uuid' },
 *      },
 *      primaryKey: {
 *        partitionBy: ['id'],
 *        partitionSort: { dob: -1 }
 *      },
 *   },
 * });
 *
 * async function main() {
 *   const table: Table<User, UserPK> = await mkTable();
 *   // ... use table
 * }
 * ```
 *
 * ###### Custom datatypes
 *
 * You can plug in your own custom datatypes, as well as enable many other features by providing some custom serialization/deserialization logic through the `serdes` option in {@link TableOptions}, {@link DbOptions}, and/or {@link DataAPIClientOptions.dbOptions}.
 *
 * Note however that this is currently not entirely stable, and should be used with caution.
 *
 * See the official DataStax documentation for more info.
 *
 * ###### Disclaimer
 *
 * *It is on the user to ensure that the TS type of the `Table` corresponds with the actual CQL table schema, in its TS-deserialized form. Incorrect or dynamic tying could lead to surprising behaviours and easily-preventable errors.*
 *
 * See {@link Db.createTable}, {@link Db.table}, and {@link InferTableSchema} for much more information about typing.
 *
 * @see SomeRow
 * @see Db.createTable
 * @see Db.table
 * @see InferTableSchema
 * @see InferTablePrimaryKey
 * @see TableSerDesConfig
 * @see TableOptions
 *
 * @public
 */
export declare class Table<WSchema extends SomeRow, PKey extends SomeRow = Partial<FoundRow<WSchema>>, RSchema extends SomeRow = FoundRow<WSchema>> {
    #private;
    /**
     * The name of the table. Unique per keyspace.
     */
    readonly name: string;
    /**
     * The keyspace that the table resides in.
     */
    readonly keyspace: string;
    /* Excluded from this release type: __constructor */
    /**
     * ##### Overview
     *
     * Atomically upserts a single row into the table.
     *
     * @example
     * ```ts
     * import { UUID, vector, ... } from '@datastax/astra-db-ts';
     *
     * // Insert a row with a specific ID
     * await table.insertOne({ id: 'text-id', name: 'John Doe' });
     * await table.insertOne({ id: UUID.v7(), name: 'Dane Joe' }); // or uuid(7)
     *
     * // Insert a row with a vector
     * // DataAPIVector class enables faster ser/des
     * const vec = vector([.12, .52, .32]); // or new DataAPIVector([.12, .52, .32])
     * await table.insertOne({ id: 1, name: 'Jane Doe', vector: vec });
     *
     * // or if vectorize (auto-embedding-generation) is enabled for the column
     * await table.insertOne({ id: 1, name: 'Jane Doe', vector: "Hey there!" });
     * ```
     *
     * ##### Upsert behavior
     *
     * When inserting a row with a primary key that already exists, the new row will be merged with the existing row, with the new values taking precedence.
     *
     * If you want to delete old values, you must explicitly set them to `null` (not `undefined`).
     *
     * @example
     * ```ts
     * await table.insertOne({ id: '123', col1: 'i exist' });
     * await table.findOne({ id: '123' }); // { id: '123', col1: 'i exist' }
     *
     * await table.insertOne({ id: '123', col1: 'i am new' });
     * await table.findOne({ id: '123' }); // { id: '123', col1: 'i am new' }
     *
     * await table.insertOne({ id: '123', col2: 'me2' });
     * await table.findOne({ id: '123' }); // { id: '123', col1: 'i am new', col2: 'me2' }
     *
     * await table.insertOne({ id: '123', col1: null });
     * await table.findOne({ id: '123' }); // { id: '123', col2: 'me2' }
     * ```
     *
     * ##### The primary key
     *
     * The type of the primary key of the table is inferred from the second `PKey` type-param of the table.
     *
     * If not present, it defaults to `Partial<RSchema>` to keep the result type consistent.
     *
     * @example
     * ```ts
     * interface User {
     *   id: string,
     *   name: string,
     *   dob?: DataAPIDate,
     * }
     *
     * type UserPKey = Pick<User, 'id'>;
     *
     * const table = db.table<User, UserPKey>('table');
     *
     * // res.insertedId is of type { id: string }
     * const res = await table.insertOne({ id: '123', name: 'Alice' });
     * console.log(res.insertedId.id); // '123'
     * ```
     *
     * @param row - The row to insert.
     * @param timeout - The timeout for this operation.
     *
     * @returns The primary key of the inserted row.
     */
    insertOne(row: WSchema, timeout?: WithTimeout<'generalMethodTimeoutMs'>): Promise<TableInsertOneResult<PKey>>;
    /**
     * ##### Overview
     *
     * Upserts many rows into the table.
     *
     * @example
     * ```ts
     * import { uuid, vector, ... } from '@datastax/astra-db-ts';
     *
     * await table1.insertMany([
     *   { id: uuid(4), name: 'John Doe' }, // or UUID.v4()
     *   { id: uuid(7), name: 'Jane Doe' },
     * ]);
     *
     * // Insert a row with a vector
     * // DataAPIVector class enables faster ser/des
     * await table2.insertMany([
     *   { name: 'bob', vector: vector([.12, .52, .32]) }, // or new DataAPIVector([...])
     *   { name: 'alice', vector: vector([.12, .52, .32]), tags: new Set(['cool']) },
     * ], { ordered: true });
     * ```
     *
     * ##### Chunking
     *
     * **NOTE: This function paginates the insertion of rows in chunks to avoid running into insertion limits.** This means multiple requests may be made to the server.
     *
     * This operation is **not necessarily atomic**. Depending on the amount of inserted rows, and if it's ordered or not, it can keep running (in a blocking manner) for a macroscopic amount of time. In that case, new rows that are inserted from another concurrent process/application may be inserted during the execution of this method call, and if there are duplicate keys, it's not easy to predict which application will win the race.
     *
     * By default, it inserts rows in chunks of 50 at a time. You can fine-tune the parameter through the `chunkSize` option. Note that increasing chunk size won't necessarily increase performance depending on row size. Instead, increasing concurrency may help.
     *
     * You can set the `concurrency` option to control how many network requests are made in parallel on unordered insertions. Defaults to `8`.
     *
     * @example
     * ```ts
     * const rows = Array.from({ length: 100 }, (_, i) => ({ id: i }));
     * await table.insertMany(rows, { batchSize: 100 });
     * ```
     *
     * ##### Upsert behavior
     *
     * When inserting a row with a primary key that already exists, the new row will be merged with the existing row, with the new values taking precedence.
     *
     * If you want to delete old values, you must explicitly set them to `null` (not `undefined`).
     *
     * @example
     * ```ts
     * // Since insertion is ordered, the last unique value for each
     * // primary key will be the one that remains in the table.
     * await table.insertMany([
     *   { id: '123', col1: 'i exist' },
     *   { id: '123', col1: 'i am new' },
     *   { id: '123', col2: 'me2' },
     * ], { ordered: true });
     *
     * await table.findOne({ id: '123' }); // { id: '123', col1: 'i am new', col2: 'me2' }
     *
     * // Since insertion is unordered, it can not be 100% guaranteed
     * // which value will remain in the table for each primary key,
     * // as concurrent insertions may occur.
     * await table.insertMany([
     *   { id: '123', col1: null },
     *   { id: '123', col1: 'hi' },
     * ]);
     *
     * // coll1 may technically be either 'hi' or null
     * await table.findOne({ id: '123' }); // { id: '123', col1: ? }
     * ```
     *
     * ##### Ordered insertions
     *
     * You may set the `ordered` option to `true` to stop the operation after the first error; otherwise all rows may be parallelized and processed in arbitrary order, improving, perhaps vastly, performance.
     *
     * Setting the `ordered` operation disables any parallelization so insertions truly are stopped after the very first error.
     *
     * Setting `ordered` also guarantees the order of upsert behavior, as described above.
     *
     * ##### The primary key
     *
     * The type of the primary key of the table is inferred from the second `PKey` type-param of the table.
     *
     * If not present, it defaults to `Partial<RSchema>` to keep the result type consistent.
     *
     * @example
     * ```ts
     * interface User {
     *   id: string,
     *   name: string,
     *   dob?: DataAPIDate,
     * }
     *
     * type UserPKey = Pick<User, 'id'>;
     *
     * const table = db.table<User, UserPKey>('table');
     *
     * // res.insertedIds is of type { id: string }[]
     * const res = await table.insertMany([
     *   { id: '123', thing: 'Sunrise' },
     *   { id: '456', thing: 'Miso soup' },
     * ]);
     * console.log(res.insertedIds[0].id); // '123'
     * ```
     *
     * ##### `InsertManyError`
     *
     * If some rows can't be inserted, (e.g. they have the wrong data type for a column or lack the primary key), the Data API validation check will fail for those entire specific requests containing the faulty rows.
     *
     * Depending on concurrency & the `ordered` parameter, some rows may still have been inserted.
     *
     * In such cases, the operation will throw a {@link TableInsertManyError} containing the partial result.
     *
     * If a thrown exception is not due to an insertion error, e.g. a `5xx` error or network error, the operation will throw the underlying error.
     *
     * In case of an unordered request, if the error was a simple insertion error, the {@link TableInsertManyError} will be thrown after every row has been attempted to be inserted. If it was a `5xx` or similar, the error will be thrown immediately.
     *
     * @param rows - The rows to insert.
     * @param options - The options for this operation.
     *
     * @returns The primary keys of the inserted rows (and the count)
     *
     * @throws TableInsertManyError - If the operation fails.
     */
    insertMany(rows: readonly WSchema[], options?: TableInsertManyOptions): Promise<TableInsertManyResult<PKey>>;
    /**
     * ##### Overview
     *
     * Updates a single row in the table. Under certain conditions, it may insert or delete a row as well.
     *
     * @example
     * ```ts
     * await table.insertOne({ key: '123', name: 'Jerry' });
     * await table.updateOne({ key: '123' }, { $set: { name: 'Geraldine' } });
     * ```
     *
     * ##### Upserting
     *
     * If the row doesn't exist, *and you're `$set`-ing at least one row to a non-null value,* an upsert will occur.
     *
     * @example
     * ```ts
     * // No upsert will occur here since only nulls are being set
     * // (this is equivalent to `{ $unset: { name: '' } }`)
     * await table.updateOne({ key: '123' }, { $set: { name: null } });
     *
     * // An upsert will occur here since at least one non-null value is being set
     * await table.updateOne({ key: '123' }, { $set: { name: 'Eleanor', age: null } });
     * ```
     *
     * ##### Deleting
     *
     * If the row was only upserted in the first place, and now all (non-primary) rows are set to null (or unset), the row will be deleted.
     *
     * _If the row was inserted on, even if it was upserted first, it will not be deleted._
     *
     * Note that `$set`-ing a row to `null` is equivalent to `$unset`-ing it. The following example would be the exact same using `$unset`s.
     *
     * @example
     * ```ts
     * // Upserts row { key: '123', name: 'Michael', age: 3 } into the table
     * await table.updateOne({ key: '123' }, { $set: { name: 'Michael', age: 3 } });
     *
     * // Sets row to { key: '123', name: 'Michael', age: null }
     * await table.updateOne({ key: '123' }, { $set: { age: null } });
     *
     * // Deletes row from the table as all non-primary keys are set to null
     * await table.updateOne({ key: '123' }, { $set: { name: null } });
     * ```
     *
     * ##### Filtering
     *
     * The filter must contain an exact primary key to update just one row.
     *
     * Attempting to pass an empty filter, filtering by only part of the primary key, or filtering by a non-primary key column will result in an error.
     *
     * ##### Update operators
     *
     * Updates may perform either `$set` or`$unset` operations on the row. (`$set`-ing a row to `null` is equivalent to `$unset`-ing it.)
     *
     * ##### On returning `void`
     *
     * The `updateOne` operation, as returned from the Data API, is always `{ matchedCount: 1, modifiedCount: 1 }`, regardless of how many things are actually matched/modified, and if a row is upserted or not.
     *
     * In that sense, returning constantly that one type is isomorphic to just returning `void`, as both realistically contain the same amount of information (i.e. none)
     *
     * @param filter - A filter to select the row to update.
     * @param update - The update to apply to the selected row.
     * @param timeout - The timeout for this operation.
     *
     * @returns A promise which resolves once the operation is completed.
     */
    updateOne(filter: TableFilter<WSchema>, update: TableUpdateFilter<WSchema>, timeout?: WithTimeout<'generalMethodTimeoutMs'>): Promise<void>;
    /**
     * ##### Overview
     *
     * Deletes a single row from the table.
     *
     * @example
     * ```ts
     * await table.insertOne({ pk: 'abc', ck: 3 });
     * await table.deleteOne({ pk: 'abc', ck: 3 });
     * ```
     *
     * ##### Filtering
     *
     * The filter must contain an exact primary key to delete just one row.
     *
     * Attempting to pass an empty filter, filtering by only part of the primary key, or filtering by a non-primary key column will result in an error.
     *
     * ##### On returning `void`
     *
     * The `deleteOne` operation, as returned from the Data API, is always `{ deletedCount: -1 }`, regardless of how many things are actually matched/modified.
     *
     * In that sense, returning constantly that one type is isomorphic to just returning `void`, as both realistically contain the same amount of information (i.e. none)
     *
     * @param filter - A filter to select the row to delete.
     * @param timeout - The timeout for this operation.
     *
     * @returns A promise which resolves once the operation is completed.
     */
    deleteOne(filter: TableFilter<WSchema>, timeout?: WithTimeout<'generalMethodTimeoutMs'>): Promise<void>;
    /**
     * ##### Overview
     *
     * Deletes many rows from the table.
     *
     * @example
     * ```ts
     * await table.insertOne({ pk: 'abc', ck: 3 });
     * await table.insertOne({ pk: 'abc', ck: 4 });
     * await table.deleteMany({ pk: 'abc' });
     * ```
     *
     * ##### Filtering
     *
     * There are different forms of accepted filters:
     * - Providing the full primary key to delete a single row
     * - With some or all of the `partitionSort` columns not provided
     *   - The least significant of them can also use an inequality/range predicate
     * - Using an empty filter to truncate the entire table
     *
     * ##### On returning `void`
     *
     * The `deleteMany` operation, as returned from the Data API, is always `{ deletedCount: -1 }`, regardless of how many things are actually matched/modified.
     *
     * In that sense, returning constantly that one type is isomorphic to just returning `void`, as both realistically contain the same amount of information (i.e. none)
     *
     * @param filter - A filter to select the row(s) to delete.
     * @param timeout - The timeout for this operation.
     *
     * @returns A promise which resolves once the operation is completed.
     */
    deleteMany(filter: TableFilter<WSchema>, timeout?: WithTimeout<'generalMethodTimeoutMs'>): Promise<void>;
    /**
     * ##### Overview
     *
     * Find rows in the table, optionally matching the provided filter.
     *
     * @example
     * ```ts
     * const cursor = await table.find({ name: 'John Doe' });
     * const docs = await cursor.toArray();
     * ```
     *
     * ##### Projection
     *
     * This overload of {@link Table.find} is used for when no projection is provided, and it is safe to assume the returned rows are going to be of type `Schema`.
     *
     * If it can not be inferred that a projection is definitely not provided, the `Schema` is forced to be `Partial<Schema>` if the user does not provide their own, in order to prevent type errors and ensure the user is aware that the row may not be of the same type as `Schema`.
     *
     * ##### Filtering
     *
     * The filter can contain a variety of operators & combinators to select the rows. See {@link TableFilter} for much more information.
     *
     * If the filter is empty, all rows in the table will be returned (up to any provided/implied limit).
     *
     * ##### Find by vector search
     *
     * If the table has vector search enabled, you can find the most relevant rows by providing a vector in the sort option.
     *
     * Vector ANN searches cannot return more than a set number of rows, which, at the time of writing, is 1000 items.
     *
     * @example
     * ```ts
     * await table.insertMany([
     *   { name: 'John Doe', vector: [.12, .52, .32] },
     *   { name: 'Jane Doe', vector: [.32, .52, .12] },
     *   { name: 'Dane Joe', vector: [.52, .32, .12] },
     * ]);
     *
     * const cursor = table.find({}, {
     *   sort: { vector: [.12, .52, .32] },
     * });
     *
     * // Returns 'John Doe'
     * console.log(await cursor.next());
     * ```
     *
     * ##### Sorting
     *
     * The sort option can be used to sort the rows returned by the cursor. See {@link Sort} for more information.
     *
     * The [DataStax documentation site](https://docs.datastax.com/en/astra-db-serverless/index.html) also contains further information on the available sort operators.
     *
     * If the sort option is not provided, there is no guarantee as to the order of the rows returned.
     *
     * When providing a non-vector sort, the Data API will return a smaller number of rows, set to 20 at the time of writing, and stop there. The returned rows are the top results across the whole table according to the requested criterion.
     *
     * @example
     * ```ts
     * await table.insertMany([
     *   { name: 'John Doe', age: 1, height: 168 },
     *   { name: 'John Doe', age: 2, height: 42 },
     * ]);
     *
     * const cursor = table.find({}, {
     *   sort: { age: 1, height: -1 },
     * });
     *
     * // Returns 'John Doe' (age 2, height 42), 'John Doe' (age 1, height 168)
     * console.log(await cursor.toArray());
     * ```
     *
     * ##### Other options
     *
     * Other available options include `skip`, `limit`, `includeSimilarity`, and `includeSortVector`. See {@link TableFindOptions} and {@link FindCursor} for more information.
     *
     * If you prefer, you may also set these options using a fluent interface on the {@link FindCursor} itself.
     *
     * @example
     * ```ts
     * // cursor :: FindCursor<string>
     * const cursor = table.find({})
     *   .sort({ vector: [.12, .52, .32] })
     *   .projection<{ name: string, age: number }>({ name: 1, age: 1 })
     *   .includeSimilarity(true)
     *   .map(doc => `${doc.name} (${doc.age})`);
     * ```
     *
     * @remarks
     * When not specifying sorting criteria at all (by vector or otherwise),
     * the cursor can scroll through an arbitrary number of rows as
     * the Data API and the client periodically exchange new chunks of rows.
     *
     * --
     *
     * It should be noted that the behavior of the cursor in the case rows
     * have been added/removed after the `find` was started depends on database
     * internals, and it is not guaranteed, nor excluded, that such "real-time"
     * changes in the data would be picked up by the cursor.
     *
     * @param filter - A filter to select the rows to find. If not provided, all rows will be returned.
     * @param options - The options for this operation.
     *
     * @returns a {@link FindCursor} which can be iterated over.
     */
    find(filter: TableFilter<WSchema>, options?: TableFindOptions & {
        projection?: never;
    }): TableFindCursor<WithSim<RSchema>, WithSim<RSchema>>;
    /**
     * ##### Overview
     *
     * Find rows in the table, optionally matching the provided filter.
     *
     * @example
     * ```ts
     * const cursor = await table.find({ name: 'John Doe' });
     * const docs = await cursor.toArray();
     * ```
     *
     * ##### Projection
     *
     * This overload of {@link Table.find} is used for when a projection is provided (or at the very least, it can not be inferred that a projection is NOT provided).
     *
     * In this case, the user must provide an explicit projection type, or the type of the rows will be `Partial<Schema>`, to prevent type-mismatches when the schema is strictly provided.
     *
     * @example
     * ```ts
     * interface User {
     *   name: string,
     *   car: { make: string, model: string },
     * }
     *
     * const table = db.table<User>('users');
     *
     * // Defaulting to `Partial<User>` when projection is not provided
     * const cursor = await table.find({}, {
     *   projection: { car: 1 },
     * });
     *
     * // next :: { car?: { make?: string, model?: string } }
     * const next = await cursor.next();
     * console.log(next.car?.make);
     *
     * // Explicitly providing the projection type
     * const cursor = await table.find<Pick<User, 'car'>>({}, {
     *   projection: { car: 1 },
     * });
     *
     * // next :: { car: { make: string, model: string } }
     * const next = await cursor.next();
     * console.log(next.car.make);
     *
     * // Projection existence can not be inferred
     * function mkFind(projection?: Projection) {
     *   return table.find({}, { projection });
     * }
     *
     * // next :: Partial<User>
     * const next = await mkFind({ car: 1 }).next();
     * console.log(next.car?.make);
     * ```
     *
     * ##### Filtering
     *
     * The filter can contain a variety of operators & combinators to select the rows. See {@link TableFilter} for much more information.
     *
     * If the filter is empty, all rows in the table will be returned (up to any provided/implied limit).
     *
     * ##### Find by vector search
     *
     * If the table has vector search enabled, you can find the most relevant rows by providing a vector in the sort option.
     *
     * Vector ANN searches cannot return more than a set number of rows, which, at the time of writing, is 1000 items.
     *
     * @example
     * ```ts
     * await table.insertMany([
     *   { name: 'John Doe', vector: [.12, .52, .32] },
     *   { name: 'Jane Doe', vector: [.32, .52, .12] },
     *   { name: 'Dane Joe', vector: [.52, .32, .12] },
     * ]);
     *
     * const cursor = table.find({}, {
     *   sort: { vector: [.12, .52, .32] },
     * });
     *
     * // Returns 'John Doe'
     * console.log(await cursor.next());
     * ```
     *
     * ##### Sorting
     *
     * The sort option can be used to sort the rows returned by the cursor. See {@link Sort} for more information.
     *
     * The [DataStax documentation site](https://docs.datastax.com/en/astra-db-serverless/index.html) also contains further information on the available sort operators.
     *
     * If the sort option is not provided, there is no guarantee as to the order of the rows returned.
     *
     * When providing a non-vector sort, the Data API will return a smaller number of rows, set to 20 at the time of writing, and stop there. The returned rows are the top results across the whole table according to the requested criterion.
     *
     * @example
     * ```ts
     * await table.insertMany([
     *   { name: 'John Doe', age: 1, height: 168 },
     *   { name: 'John Doe', age: 2, height: 42 },
     * ]);
     *
     * const cursor = table.find({}, {
     *   sort: { age: 1, height: -1 },
     * });
     *
     * // Returns 'John Doe' (age 2, height 42), 'John Doe' (age 1, height 168)
     * console.log(await cursor.toArray());
     * ```
     *
     * ##### Other options
     *
     * Other available options include `skip`, `limit`, `includeSimilarity`, and `includeSortVector`. See {@link TableFindOptions} and {@link FindCursor} for more information.
     *
     * If you prefer, you may also set these options using a fluent interface on the {@link FindCursor} itself.
     *
     * @example
     * ```ts
     * // cursor :: FindCursor<string>
     * const cursor = table.find({})
     *   .sort({ vector: [.12, .52, .32] })
     *   .projection<{ name: string, age: number }>({ name: 1, age: 1 })
     *   .includeSimilarity(true)
     *   .map(doc => `${doc.name} (${doc.age})`);
     * ```
     *
     * @remarks
     * When not specifying sorting criteria at all (by vector or otherwise),
     * the cursor can scroll through an arbitrary number of rows as
     * the Data API and the client periodically exchange new chunks of rows.
     *
     * --
     *
     * It should be noted that the behavior of the cursor in the case rows
     * have been added/removed after the `find` was started depends on database
     * internals, and it is not guaranteed, nor excluded, that such "real-time"
     * changes in the data would be picked up by the cursor.
     *
     * @param filter - A filter to select the rows to find. If not provided, all rows will be returned.
     * @param options - The options for this operation.
     *
     * @returns a {@link FindCursor} which can be iterated over.
     */
    find<TRaw extends SomeRow = Partial<RSchema>>(filter: TableFilter<WSchema>, options: TableFindOptions): TableFindCursor<TRaw, TRaw>;
    /**
     * ##### Overview
     *
     * Find a single row in the table, optionally matching the provided filter.
     *
     * @example
     * ```ts
     * const doc = await table.findOne({ name: 'John Doe' });
     * ```
     *
     * ##### Projection
     *
     * This overload of {@link Table.findOne} is used for when no projection is provided, and it is safe to assume the returned row is going to be of type `Schema`.
     *
     * If it can not be inferred that a projection is definitely not provided, the `Schema` is forced to be `Partial<Schema>` if the user does not provide their own, in order to prevent type errors and ensure the user is aware that the row may not be of the same type as `Schema`.
     *
     * ##### Filtering
     *
     * The filter can contain a variety of operators & combinators to select the row. See {@link TableFilter} for much more information.
     *
     * If the filter is empty, and no {@link Sort} is present, it's undefined as to which row is selected.
     *
     * ##### Find by vector search
     *
     * If the table has vector search enabled, you can find the most relevant row by providing a vector in the sort option.
     *
     * @example
     * ```ts
     * await table.insertMany([
     *   { name: 'John Doe', vector: [.12, .52, .32] },
     *   { name: 'Jane Doe', vector: [.32, .52, .12] },
     *   { name: 'Dane Joe', vector: [.52, .32, .12] },
     * ]);
     *
     * const doc = table.findOne({}, {
     *   sort: { vector: [.12, .52, .32] },
     * });
     *
     * // 'John Doe'
     * console.log(doc.name);
     * ```
     *
     * ##### Sorting
     *
     * The sort option can be used to pick the most relevant row. See {@link Sort} for more information.
     *
     * The [DataStax documentation site](https://docs.datastax.com/en/astra-db-serverless/index.html) also contains further information on the available sort operators.
     *
     * If the sort option is not provided, there is no guarantee as to which of the rows which matches the filter is returned.
     *
     * @example
     * ```ts
     * await table.insertMany([
     *   { name: 'John Doe', age: 1, height: 168 },
     *   { name: 'John Doe', age: 2, height: 42 },
     * ]);
     *
     * const doc = table.findOne({}, {
     *   sort: { age: 1, height: -1 },
     * });
     *
     * // 'John Doe' (age 2, height 42)
     * console.log(doc.name);
     * ```
     *
     * ##### Other options
     *
     * Other available options include `includeSimilarity`. See {@link TableFindOneOptions} for more information.
     *
     * If you want to get `skip` or `includeSortVector` as well, use {@link Table.find} with a `limit: 1` instead.
     *
     * @example
     * ```ts
     * const doc = await cursor.findOne({}, {
     *   sort: { vector: [.12, .52, .32] },
     *   includeSimilarity: true,
     * });
     * ```
     *
     * @param filter - A filter to select the rows to find. If not provided, all rows will be returned.
     * @param options - The options for this operation.
     *
     * @returns A row matching the criterion, or `null` if no such row exists.
     */
    findOne(filter: TableFilter<WSchema>, options?: TableFindOneOptions & {
        projection?: never;
    }): Promise<WithSim<RSchema> | null>;
    /**
     * ##### Overview
     *
     * Find a single row in the table, optionally matching the provided filter.
     *
     * @example
     * ```ts
     * const doc = await table.findOne({ name: 'John Doe' });
     * ```
     *
     * ##### Projection
     *
     * This overload of {@link Table.findOne} is used for when a projection is provided (or at the very least, it can not be inferred that a projection is NOT provided).
     *
     * In this case, the user must provide an explicit projection type, or the type of the returned row will be as `Partial<Schema>`, to prevent type-mismatches when the schema is strictly provided.
     *
     * @example
     * ```ts
     * interface User {
     *   name: string,
     *   car: { make: string, model: string },
     * }
     *
     * const table = db.table<User>('users');
     *
     * // Defaulting to `Partial<User>` when projection is not provided
     * const doc = await table.findOne({}, {
     *   projection: { car: 1 },
     * });
     *
     * // doc :: { car?: { make?: string, model?: string } }
     * console.log(doc.car?.make);
     *
     * // Explicitly providing the projection type
     * const doc = await table.findOne<Pick<User, 'car'>>({}, {
     *   projection: { car: 1 },
     * });
     *
     * // doc :: { car: { make: string, model: string } }
     * console.log(doc.car.make);
     *
     * // Projection existence can not be inferred
     * function findOne(projection?: Projection) {
     *   return table.findOne({}, { projection });
     * }
     *
     * // doc :: Partial<User>
     * const doc = await findOne({ car: 1 }).next();
     * console.log(doc.car?.make);
     * ```
     *
     * ##### Filtering
     *
     * The filter can contain a variety of operators & combinators to select the row. See {@link TableFilter} for much more information.
     *
     * If the filter is empty, and no {@link Sort} is present, it's undefined as to which row is selected.
     *
     * ##### Find by vector search
     *
     * If the table has vector search enabled, you can find the most relevant row by providing a vector in the sort option.
     *
     * @example
     * ```ts
     * await table.insertMany([
     *   { name: 'John Doe', vector: [.12, .52, .32] },
     *   { name: 'Jane Doe', vector: [.32, .52, .12] },
     *   { name: 'Dane Joe', vector: [.52, .32, .12] },
     * ]);
     *
     * const doc = table.findOne({}, {
     *   sort: { vector: [.12, .52, .32] },
     * });
     *
     * // 'John Doe'
     * console.log(doc.name);
     * ```
     *
     * ##### Sorting
     *
     * The sort option can be used to pick the most relevant row. See {@link Sort} for more information.
     *
     * The [DataStax documentation site](https://docs.datastax.com/en/astra-db-serverless/index.html) also contains further information on the available sort operators.
     *
     * If the sort option is not provided, there is no guarantee as to which of the rows which matches the filter is returned.
     *
     * @example
     * ```ts
     * await table.insertMany([
     *   { name: 'John Doe', age: 1, height: 168 },
     *   { name: 'John Doe', age: 2, height: 42 },
     * ]);
     *
     * const doc = table.findOne({}, {
     *   sort: { age: 1, height: -1 },
     * });
     *
     * // 'John Doe' (age 2, height 42)
     * console.log(doc.name);
     * ```
     *
     * ##### Other options
     *
     * Other available options include `includeSimilarity`. See {@link TableFindOneOptions} for more information.
     *
     * If you want to get `skip` or `includeSortVector` as well, use {@link Table.find} with a `limit: 1` instead.
     *
     * @example
     * ```ts
     * const doc = await cursor.findOne({}, {
     *   sort: { vector: [.12, .52, .32] },
     *   includeSimilarity: true,
     * });
     * ```
     *
     * @param filter - A filter to select the rows to find. If not provided, all rows will be returned.
     * @param options - The options for this operation.
     *
     * @returns A row matching the criterion, or `null` if no such row exists.
     */
    findOne<TRaw extends SomeRow = Partial<RSchema>>(filter: TableFilter<WSchema>, options: TableFindOneOptions): Promise<TRaw | null>;
    /**
     * ##### Overview
     *
     * Performs one of the four available table-alteration operations:
     * - `add` (adds columns to the table)
     * - `drop` (removes columns from the table)
     * - `addVectorize` (enabled auto-embedding-generation on existing vector columns)
     * - `dropVectorize` (disables vectorize on existing enabled columns)
     *
     * @example
     * ```ts
     * interface User {
     *   id: UUID,
     *   vector: DataAPIVector,
     * }
     * const table = db.table<User>('users');
     *
     * // Add a column to the table
     * type NewUser = User & { name: string };
     *
     * const newTable = await table.alter<NewUser>({
     *  operation: {
     *    add: {
     *      columns: { name: 'text' },
     *    },
     *  },
     * });
     *
     * // Drop a column from the table (resets it to how it was originally)
     * const oldTable = await newTable.alter<User>({
     *   operation: {
     *     drop: {
     *       columns: ['name'],
     *     },
     *   },
     * });
     * ```
     *
     * ##### On returning `Table`
     *
     * The `alter` operation returns the table itself, with the new schema type.
     *
     * It is heavily recommended to store the result of the `alter` operation in a new variable, as the old table will not have the new schema type.
     *
     * You should provide the exact new type of the schema, or it'll just default to `SomeRow`.
     *
     * @param options - The options for this operation.
     *
     * @returns The table with the new schema type.
     */
    alter<NewWSchema extends SomeRow, NewRSchema extends SomeRow = FoundRow<NewWSchema>>(options: AlterTableOptions<SomeRow>): Promise<Table<NewWSchema, PKey, NewRSchema>>;
    /**
     * Lists the index names for this table.
     *
     * If you want to include the index definitions in the response, set `nameOnly` to `false` (or omit it completely),
     * using the other overload.
     *
     * @example
     * ```typescript
     * // ['my_vector_index', ...]
     * console.log(await table.listIndexes({ nameOnly: true }));
     * ```
     *
     * @param options - Options for this operation.
     *
     * @returns A promise that resolves to an array of index names.
     */
    listIndexes(options: ListIndexOptions & {
        nameOnly: true;
    }): Promise<string[]>;
    /**
     * Lists the indexes for this table.
     *
     * If you want to use only the index names, set `nameOnly` to `true`, using the other overload.
     *
     * @example
     * ```typescript
     * // [{ name: 'm_vector_index', definition: { ... } }, ...]
     * console.log(await db.listTables());
     * ```
     *
     * @param options - Options for this operation.
     *
     * @returns A promise that resolves to an array of index info.
     */
    listIndexes(options?: ListIndexOptions & {
        nameOnly?: false;
    }): Promise<TableIndexDescriptor[]>;
    /**
     * ##### Overview
     *
     * Creates a secondary non-vector index on the table.
     *
     * The operation blocks until the index is created and ready to use.
     *
     * See {@link Table.createVectorIndex} for creating vector indexes.
     *
     * ##### Text indexes
     *
     * `text` and `ascii`-based indexes have access to a few additional options:
     * - `caseSensitive` (default: `true`)
     *   - Allows searches to be case-insensitive, if false
     * - `normalize` (default: `true`)
     *   - Normalize Unicode characters and diacritics before indexing, if true
     * - `ascii` (default: `false`)
     *   - Converts non-ASCII characters to their US-ASCII equivalent before indexing, if true
     *
     * @param name - The name of the index
     * @param column - The column to index
     * @param options - Options for this operation
     *
     * @returns A promise which resolves once the index is created.
     */
    createIndex(name: string, column: WSchema | string, options?: CreateTableIndexOptions): Promise<void>;
    /**
     * Creates an index on an existing vector column in the table.
     *
     * The operation blocks until the index is created and ready to use.
     *
     * See {@link Table.createIndex} for creating non-vector indexes.
     *
     * @param name - The name of the index
     * @param column - The vector column to index
     * @param options - Options for this operation
     *
     * @returns A promise which resolves once the index is created.
     */
    createVectorIndex(name: string, column: WSchema | string, options?: CreateTableVectorIndexOptions): Promise<void>;
    /**
     * ##### Overview
     *
     * Get the table definition, i.e. it's columns and primary key definition.
     *
     * The method issues a request to the Data API each time it is invoked, without caching mechanisms;
     * this ensures up-to-date information for usages such as real-time collection validation by the application.
     *
     * @example
     * ```ts
     * const definition = await table.definition();
     * console.log(definition.columns);
     * ```
     *
     * @param options - The options for this operation.
     *
     * @returns The definition of the table.
     */
    definition(options?: WithTimeout<'tableAdminTimeoutMs'>): Promise<ListTableDefinition>;
    /**
     * ##### Overview
     *
     * Drops the table from the database, including all the rows it contains.
     *
     * @example
     * ```typescript
     * const table = await db.table('my_table');
     * await table.drop();
     * ```
     *
     * ##### Disclaimer
     *
     * Once the table is dropped, this object is still technically "usable", but any further operations on it
     * will fail at the Data API level; thus, it's the user's responsibility to make sure that the table object
     * is no longer used.
     *
     * @param options - The options for this operation.
     *
     * @returns A promise which resolves when the table has been dropped.
     *
     * @remarks Use with caution. Wear your safety goggles. Don't say I didn't warn you.
     */
    drop(options?: Omit<DropTableOptions, 'keyspace'>): Promise<void>;
    /**
     * Backdoor to the HTTP client for if it's absolutely necessary. Which it almost never (if even ever) is.
     */
    get _httpClient(): DataAPIHttpClient<"normal">;
}

/**
 * @public
 */
export declare type TableCodec<_Class extends TableCodecClass> = EmptyObj;

/**
 * @public
 */
export declare interface TableCodecClass {
    new (...args: any[]): {
        [$SerializeForTable]: (ctx: TableSerCtx) => ReturnType<SerDesFn<any>>;
    };
    [$DeserializeForTable]: TableCodecSerDesFns['deserialize'];
}

/**
 * @public
 */
export declare class TableCodecs implements CodecHolder<TableCodecSerDesFns> {
    /* Excluded from this release type: get */
    /* Excluded from this release type: __constructor */
    static Defaults: {
        bigint: TableCodecs;
        blob: TableCodecs;
        date: TableCodecs;
        decimal: TableCodecs;
        double: TableCodecs;
        duration: TableCodecs;
        float: TableCodecs;
        int: TableCodecs;
        inet: TableCodecs;
        smallint: TableCodecs;
        time: TableCodecs;
        timestamp: TableCodecs;
        timeuuid: TableCodecs;
        tinyint: TableCodecs;
        uuid: TableCodecs;
        vector: TableCodecs;
        varint: TableCodecs;
        map: TableCodecs;
        list: TableCodecs;
        set: TableCodecs;
    };
    static Overrides: {};
    static forPath(path: string[], clazz: TableCodecClass): TableCodecs;
    static forPath(path: string[], opts: TableCodecSerDesFns): TableCodecs;
    static forName(name: string, clazz: TableCodecClass): TableCodecs;
    static forName(name: string, opts: TableCodecSerDesFns): TableCodecs;
    static forType(type: string, clazz: TableCodecClass): TableCodecs;
    static forType(type: string, opts: TableCodecSerDesFns & {
        serializeGuard: (value: unknown, ctx: TableSerCtx) => boolean;
    }): TableCodecs;
    static forType(type: string, opts: TableCodecSerDesFns & {
        serializeClass: new (...args: any[]) => any;
    }): TableCodecs;
    static forType(type: string, opts: Pick<TableCodecSerDesFns, 'deserialize'> & {
        deserializeOnly: true;
    }): TableCodecs;
}

/**
 * @public
 */
export declare interface TableCodecSerDesFns {
    serialize: SerDesFn<TableSerCtx>;
    deserialize: (val: any, ctx: TableDesCtx, definition: SomeDoc) => ReturnType<SerDesFn<any>>;
}

/**
 * @public
 */
export declare type TableColumnTypeParser = (val: any, ctx: TableDesCtx, definition: SomeDoc) => any;

/**
 * Information about a table, used when `nameOnly` is false in {@link ListTablesOptions}.
 *
 * @field name - The name of the tables.
 * @field options - The creation options for the tables.
 *
 * @see ListTablesOptions
 * @see Db.listTables
 *
 * @public
 */
export declare interface TableDescriptor {
    /**
     * The name of the tables.
     */
    name: string;
    /**
     * The definition of the table (i.e. the `columns` and `primaryKey` fields).
     */
    definition: ListTableDefinition;
}

/**
 * @public
 */
export declare interface TableDesCtx extends BaseDesCtx<TableCodecSerDesFns> {
    tableSchema: ListTableColumnDefinitions;
    populateSparseData: boolean;
    recurse: never;
}

/**
 * Options for dropping an index via {@link Table.dropIndex}
 *
 * @public
 */
export declare interface TableDropIndexOptions extends WithKeyspace, WithTimeout<'tableAdminTimeoutMs'> {
    /**
     * If `true`, an error will not be thrown if the index attempting to be dropped does not exist.
     */
    ifExists?: boolean;
}

/**
 * Represents some filter operation for a given document schema.
 *
 * @example
 * ```typescript
 * interface BasicSchema {
 *   arr: string[],
 *   num: number,
 * }
 *
 * db.Tables<BasicSchema>('coll_name').findOne({
 *   $and: [
 *     { _id: { $in: ['abc', 'def'] } },
 *     { $not: { arr: { $size: 0 } } },
 *   ]
 * });
 * ```
 *
 * @public
 */
export declare type TableFilter<Schema extends SomeRow> = {
    [K in keyof Schema]?: TableFilterExpr<Schema[K]>;
} & {
    $and?: TableFilter<Schema>[];
    $or?: TableFilter<Schema>[];
    $not?: TableFilter<Schema>;
    [key: string]: any;
};

/**
 * Represents an expression in a filter statement, such as an exact value, or a filter operator
 *
 * @public
 */
export declare type TableFilterExpr<Elem> = Elem | TableFilterOps<Elem>;

/**
 * Represents filter operators such as `$eq` and `$in` (but not statements like `$and`)
 *
 * @public
 */
export declare type TableFilterOps<Elem> = {
    $eq?: Elem;
    $ne?: Elem;
    $in?: Elem[];
    $nin?: Elem[];
    $exists?: boolean;
    $lt?: Elem;
    $lte?: Elem;
    $gt?: Elem;
    $gte?: Elem;
};

/**
 * A subclass of `FindCursor` which is identical to its parent; it just adds some more specific typing for
 * a couple of properties/functions.
 *
 * See {@link FindCursor} directly for information on the cursor itself.
 *
 * @public
 */
export declare class TableFindCursor<T, TRaw extends SomeDoc = SomeDoc> extends FindCursor<T, TRaw> {
    /**
     * The table which spawned this cursor.
     *
     * @returns The table which spawned this cursor.
     */
    get dataSource(): Table<SomeRow>;
    /**
     * Sets the filter for the cursor, overwriting any previous filter.
     *
     * *NB. This method does **NOT** mutate the cursor, and may be called even after the cursor is started; it simply
     * returns a new, uninitialized cursor with the given new filter set.*
     *
     * @param filter - A filter to select which records to return.
     *
     * @returns A new cursor with the new filter set.
     */
    filter(filter: TableFilter<TRaw>): FindCursor<T, TRaw>;
}

/**
 * Represents the options for the table `findOne` command.
 *
 * @field sort - The sort order to pick which document to return if the filter selects multiple documents.
 * @field projection - Specifies which fields should be included/excluded in the returned documents.
 * @field includeSimilarity - If true, include the similarity score in the result via the `$similarity` field.
 * @field timeout - The timeout override for this method
 *
 * @public
 */
export declare type TableFindOneOptions = GenericFindOneOptions;

/**
 * Options for the table `find` method.
 *
 * @field sort - The sort order to pick which document to return if the filter selects multiple documents.
 * @field projection - Specifies which fields should be included/excluded in the returned documents.
 * @field limit - Max number of documents to return in the lifetime of the cursor.
 * @field skip - Number of documents to skip if using a sort.
 * @field includeSimilarity - If true, include the similarity score in the result via the `$similarity` field.
 *
 * @see Table.find
 *
 * @public
 */
export declare type TableFindOptions = GenericFindOptions;

declare interface TableIndexDescriptor {
    name: string;
    definition: TableNormalIndexDescriptor | TableVectorIndexDescriptor | TableUnknownIndex;
}

/**
 * Options available for `text` and `ascii` indexes
 *
 * @public
 */
export declare interface TableIndexOptions {
    /**
     * If `false`, enables searches on the column to be case-insensitive.
     *
     * Defaults to `true`.
     */
    caseSensitive?: boolean;
    /**
     * Whether to normalize Unicode characters and diacritics before indexing.
     *
     * Defaults to `false`.
     */
    normalize?: boolean;
    /**
     * Whether to convert non-ASCII characters to their US-ASCII equivalent before indexing.
     *
     * Defaults to `false`.
     */
    ascii?: boolean;
}

declare interface TableIndexUnsupportedColumnApiSupport {
    createIndex: boolean;
    filter: boolean;
    cqlDefinition: string;
}

/**
 * Represents an error that occurred during an `insertMany` operation (which is, generally, paginated).
 *
 * Contains the inserted IDs of the documents that were successfully inserted, as well as the cumulative errors
 * that occurred during the operation.
 *
 * If the operation was ordered, the `insertedIds` will be in the same order as the documents that were attempted to
 * be inserted.
 *
 * @field message - A human-readable message describing the *first* error
 * @field errorDescriptors - A list of error descriptors representing the individual errors returned by the API
 * @field detailedErrorDescriptors - A list of errors 1:1 with the number of errorful API requests made to the server.
 * @field partialResult - The partial result of the `InsertMany` operation that was performed
 *
 * @public
 */
export declare class TableInsertManyError extends CumulativeOperationError {
    /**
     * The name of the error. This is always 'InsertManyError'.
     */
    name: string;
    /**
     * The partial result of the `InsertMany` operation that was performed. This is *always* defined, and is the result
     * of all successful insertions.
     */
    readonly partialResult: TableInsertManyResult<SomeDoc>;
}

/**
 * Options for an `insertMany` command on a table.
 *
 * The parameters depend on the `ordered` option. If `ordered` is `true`, the `parallel` option is not allowed.
 *
 * @field ordered - If `true`, the rows are inserted sequentially; else, they're arbitrary inserted in parallel.
 * @field concurrency - The maximum number of concurrent requests to make at once.
 * @field chunkSize - The number of rows to upload per request. Defaults to 50.
 * @field timeout - The timeout override for this method
 *
 * @see Table.insertMany
 *
 * @public
 */
export declare type TableInsertManyOptions = GenericInsertManyOptions;

/**
 * Represents the result of an `insertMany` command on a table.
 *
 * @field insertedIds - The primary keys of the inserted rows.
 * @field insertedCount - The number of inserted rows.
 *
 * @see Table.insertMany
 *
 * @public
 */
export declare interface TableInsertManyResult<PKey extends SomeRow> {
    /**
     * The primary keys of the inserted rows.
     */
    insertedIds: PKey[];
    /**
     * The number of inserted rows (equals `insertedIds.length`).
     */
    insertedCount: number;
}

/**
 * ##### Overview
 *
 * Represents the result of an `insertOne` command on a table.
 *
 * ##### Primary Key Inference
 *
 * The type of the primary key of the table is inferred from the second `PKey` type-param of the table.
 *
 * If not present, it defaults to `Partial<RSchema>` to keep the result type consistent.
 *
 * @example
 * ```ts
 * interface User {
 *   id: string,
 *   name: string,
 *   dob?: DataAPIDate,
 * }
 *
 * type UserPKey = Pick<User, 'id'>;
 *
 * const table = db.table<User, UserPKey>('table');
 *
 * // res.insertedId is of type { id: string }
 * const res = await table.insertOne({ id: '123', name: 'Alice' });
 * console.log(res.insertedId.id); // '123'
 * ```
 *
 * @example
 * ```ts
 * const table = db.table<User>('table');
 *
 * // res.insertedId is of type Partial<User>
 * const res = await table.insertOne({ id: '123', name: 'Alice' });
 * console.log(res.insertedId.id); // '123'
 * console.log(res.insertedId.key); // undefined
 * ```
 *
 * @field insertedId - The primary key of the inserted document.
 *
 * @see Table.insertOne
 *
 * @public
 */
export declare interface TableInsertOneResult<PKey extends SomeRow> {
    /**
     * The primary key of the inserted document.
     *
     * See {@link TableInsertOneResult} for more info about this type and how it's inferred.
     */
    insertedId: PKey;
}

declare interface TableNormalIndexDescriptor {
    column: string;
    options: TableIndexOptions;
}

/**
 * Options for spawning a new `Table` instance through {@link db.table} or {@link db.createTable}.
 *
 * Note that these are not all the options available for when you're actually creating a table—see {@link CreateTableOptions} for that.
 *
 * @field embeddingApiKey - The embedding service's API-key/headers (for $vectorize)
 * @field timeoutDefaults - Default timeouts for all table operations
 * @field logging - Logging configuration overrides
 * @field serdes - Additional serialization/deserialization configuration
 *
 * @public
 */
export declare interface TableOptions extends WithKeyspace {
    /**
     * The API key for the embedding service to use, or the {@link EmbeddingHeadersProvider} if using
     * a provider that requires it (e.g. AWS bedrock).
     */
    embeddingApiKey?: string | EmbeddingHeadersProvider | null;
    /**
     * The configuration for logging events emitted by the {@link DataAPIClient}.
     *
     * This can be set at any level of the major class hierarchy, and will be inherited by all child classes.
     *
     * See {@link DataAPILoggingConfig} for *much* more information on configuration, outputs, and inheritance.
     */
    logging?: DataAPILoggingConfig;
    /**
     * Advanced & currently somewhat unstable features related to customizing the table's ser/des behavior at a lower level.
     *
     * Use with caution. See official DataStax documentation for more info.
     *
     * @beta
     */
    serdes?: TableSerDesConfig;
    /**
     * ##### Overview
     *
     * The default timeout options for any operation performed on this {@link Table} instance.
     *
     * See {@link TimeoutDescriptor} for much more information about timeouts.
     *
     * @example
     * ```ts
     * // The request timeout for all operations is set to 1000ms.
     * const client = new DataAPIClient('...', {
     *   timeoutDefaults: { requestTimeoutMs: 1000 },
     * });
     *
     * // The request timeout for all operations borne from this Db is set to 2000ms.
     * const db = client.db('...', {
     *   timeoutDefaults: { requestTimeoutMs: 2000 },
     * });
     * ```
     *
     * ##### Inheritance
     *
     * The timeout options are inherited by all child classes, and can be overridden at any level, including the individual method level.
     *
     * Individual-method-level overrides can vary in behavior depending on the method; again, see {@link TimeoutDescriptor}.
     *
     * ##### Defaults
     *
     * The default timeout options are as follows:
     * - `requestTimeoutMs`: 10000
     * - `generalMethodTimeoutMs`: 30000
     * - `collectionAdminTimeoutMs`: 60000
     * - `tableAdminTimeoutMs`: 30000
     * - `databaseAdminTimeoutMs`: 600000
     * - `keyspaceAdminTimeoutMs`: 30000
     *
     * @see TimeoutDescriptor
     */
    timeoutDefaults?: Partial<TimeoutDescriptor>;
}

/**
 * @public
 */
export declare type TableScalarType = 'ascii' | 'bigint' | 'blob' | 'boolean' | 'date' | 'decimal' | 'double' | 'duration' | 'float' | 'int' | 'inet' | 'smallint' | 'text' | 'time' | 'timestamp' | 'tinyint' | 'uuid' | 'varint';

/**
 * @public
 */
export declare interface TableSerCtx extends BaseSerCtx<TableCodecSerDesFns> {
    bigNumsPresent: boolean;
}

/**
 * @public
 */
export declare interface TableSerDesConfig extends BaseSerDesConfig<TableCodecs, TableCodecSerDesFns, TableSerCtx, TableDesCtx> {
    codecs?: TableCodecs[];
    sparseData?: boolean;
}

declare interface TableUnknownIndex {
    column: 'UNKNOWN';
    apiSupport: TableIndexUnsupportedColumnApiSupport;
}

/**
 * Represents the update filter to specify how to update a document.
 *
 * @example
 * ```typescript
 * const updateFilter: TableUpdateFilter<SomeDoc> = {
 *   $set: {
 *     'customer': 'Jim B.'
 *   },
 *   $unset: {
 *     'customer': ''
 *   },
 * }
 * ```
 *
 * @field $set - Set the value of a field in the document.
 * @field $unset - Remove the field from the document.
 *
 * @public
 */
export declare interface TableUpdateFilter<Schema extends SomeRow> {
    /**
     * Set the value of a field in the document.
     *
     * @example
     * ```typescript
     * const updateFilter: UpdateFilter<SomeDoc> = {
     *   $set: {
     *     'customer.name': 'Jim B.'
     *   }
     * }
     * ```
     */
    $set?: Partial<Schema> & SomeRow;
    /**
     * Remove the field from the document.
     *
     * @example
     * ```typescript
     * const updateFilter: UpdateFilter<SomeDoc> = {
     *   $unset: {
     *     'customer.phone': ''
     *   }
     * }
     * ```
     */
    $unset?: Record<string, '' | true | 1>;
}

declare interface TableVectorIndexDescriptor {
    column: string;
    options: TableVectorIndexOptions;
}

/**
 * Options aviailable for the vector index
 *
 * @public
 */
export declare interface TableVectorIndexOptions {
    /**
     * The similarity metric to use for the index.
     */
    metric?: 'cosine' | 'euclidean' | 'dot_product';
    /**
     * Enable certain vector optimizations on the index by specifying the source model for your vectors, such as (not exhaustive) `'openai_v3_large'`, `'openai_v3_small'`, `'ada002'`, `'gecko'`, `'bert'`, or `'other'` (default).
     */
    sourceModel?: string | 'other';
}

/**
 * A shorthand function for `new DataAPITime(time?)`
 *
 * If no time is provided, it defaults to the current time.
 *
 * @public
 */
export declare const time: (time?: string | Date | DataAPITimeComponents) => DataAPITime;

/**
 * The timeout categories that caused the timeout.
 *
 * If the timeout was caused by:
 * - a single timeout category, the category name is returned.
 * - multiple categories, an array of category names is returned.
 * - a plain-number-timeout provided by the user in a single-call method, the string `'provided'` is returned.
 *
 * @public
 */
export declare type TimedOutCategories = OneOrMany<keyof TimeoutDescriptor> | 'provided';

/**
 * #### Overview
 *
 * The generic timeout descriptor that is used to define the timeout for all the various operations supported by
 * the {@link DataAPIClient} and its children.
 *
 * ###### Inheritance
 *
 * The {@link TimeoutDescriptor}, or a subset of it, may be specified at any level of the client hierarchy, all the
 * way from the {@link DataAPIClient} down to the individual methods. The timeout specified at a lower level will
 * override the timeout specified at a higher level (through a typical object merge).
 *
 * @example
 * ```ts
 * // The request timeout for all operations is set to 1000ms.
 * const client = new DataAPIClient('...', {
 *   timeoutDefaults: { requestTimeoutMs: 1000 },
 * });
 *
 * // The request timeout for all operations borne from this Db is set to 2000ms.
 * const db = client.db('...', {
 *   timeoutDefaults: { requestTimeoutMs: 2000 },
 * });
 * ```
 *
 * ###### The `WithTimeout` interface
 *
 * The {@link WithTimeout} interface lets you specify timeouts for individual methods, in two different formats:
 * - A subtype of {@link TimeoutDescriptor}, which lets you specify the timeout for specific categories.
 * - A number, which specifies the "happy path" timeout for the method.
 *   - In single-call methods, this sets both the request & overall method timeouts.
 *   - In multi-call methods, this sets the overall method timeout (request timeouts are kept as default).
 *
 * @example
 * ```ts
 * // Both `requestTimeoutMs` and `generalMethodTimeoutMs` are set to 1000ms.
 * await coll.insertOne({ ... }, { timeout: 1000 });
 *
 * // `requestTimeoutMs` is left as default, `generalMethodTimeoutMs` is set to 2000ms.
 * await coll.insertOne({ ... }, { timeout: { generalMethodTimeoutMs: 2000 } });
 *
 * // Both `requestTimeoutMs` and `generalMethodTimeoutMs` are set to 2000ms.
 * await coll.insertMany([...], {
 *   timeout: { requestTimeoutMs: 2000, generalMethodTimeoutMs: 2000 },
 * });
 * ```
 *
 * @example
 * ```ts
 * // `requestTimeoutMs` is left as default, `generalMethodTimeoutMs` is set to 2000ms.
 * await coll.insertMany([...], { timeout: 2000 });
 *
 * // `requestTimeoutMs` is left as default, `generalMethodTimeoutMs` is set to 2000ms.
 * await coll.insertMany([...], { timeout: { generalMethodTimeoutMs: 2000 } });
 *
 * // Both `requestTimeoutMs` and `generalMethodTimeoutMs` are set to 2000ms.
 * await coll.insertMany([...], {
 *   timeout: { requestTimeoutMs: 2000, generalMethodTimeoutMs: 2000 },
 * });
 * ```
 *
 * #### Timeout types
 *
 * There are 6 generalized categories of timeouts, each with its own default values.
 *
 * In general though, two types of timeouts are always in play:
 * - `requestTimeoutMs`, which is the maximum time the client will wait for a response from the server.
 * - The overall method timeout, which is the maximum time the client will wait for the entire method to complete.
 *
 * Timeout behavior depends on the type of method being called:
 * - In single-call methods, the minimum of these two values is used as the timeout.
 * - In multi-call methods, the `requestTimeoutMs` is used as the timeout for each individual call, and the overall method timeout is used as the timeout for the entire method.
 *
 * This two-part timeout system is used in all methods but, but for a special few, where the overall method timeout is the only one used (only `createCollection`, at the moment). This is because the method is a single call, but it takes a long time for the server to complete.
 *
 * If any timeout is set to `0`, that category is effectively disabled.
 *
 * ###### Timeout categories
 *
 * See each individual field for more information, but in general, the timeouts are as follows:
 * - `requestTimeoutMs`:
 *   - The maximum time the client will wait for a response from the server.
 *   - Default: 10 seconds
 * - `generalMethodTimeoutMs`:
 *   - The overall method timeout for methods that don't have a specific overall method timeout.
 *   - (mostly applies to document/row-level operations)
 *   - Default: 30 seconds
 * - `collectionAdminTimeoutMs`:
 *   - The overall method timeout for collection admin operations.
 *   - (create, drop, list, etc.)
 *   - Default: 1 minute
 * - `tableAdminTimeoutMs`:
 *   - The overall method timeout for table admin operations.
 *   - (create, drop, list, alter, create/dropIndex, etc.)
 *   - Default: 30 seconds
 * - `databaseAdminTimeoutMs`:
 *   - The overall method timeout for database admin operations.
 *   - (create, drop, list, info, findEmbeddingProviders, etc.)
 *   - Default: 10 minutes
 * - `keyspaceAdminTimeoutMs`:
 *   - The overall method timeout for keyspace admin operations.
 *   - (create, drop, list)
 *   - Default: 30 seconds
 *
 * @see WithTimeout
 *
 * @public
 */
export declare interface TimeoutDescriptor {
    /**
     * The maximum time the client will wait for a response from the server.
     *
     * Note that it is technically possible for a request to time out, but still have the request be processed, and even succeed, on the server.
     *
     * Every HTTP call will use a `requestTimeout`, except for very special cases (at the moment, only `createCollection`, where the request may take a long time to return).
     *
     * Default: 10 seconds
     */
    requestTimeoutMs: number;
    /**
     * The overall method timeout for methods that don't have a specific overall method timeout.
     *
     * Mostly applies to document/row-level operations. DDL-esque operations (working with collections, tables, databases, keyspaces, indexes, etc.) have their own overall method timeouts.
     *
     * In single-call methods, such as `insertOne`, the minimum of `requestTimeoutMs` and `generalMethodTimeoutMs` is used as the timeout.
     *
     * In multi-call methods, such as `insertMany`, the `requestTimeoutMs` is used as the timeout for each individual call, and the `generalMethodTimeoutMs` is used as the timeout for the entire method.
     *
     * Default: 30 seconds
     */
    generalMethodTimeoutMs: number;
    /**
     * The overall method timeout for collection admin operations.
     *
     * Such methods include (but may not be limited to):
     * - `db.createCollection()`
     * - `db.dropCollection()`
     * - `db.listCollections()`
     * - `collection.options()`
     *
     * Default: 1 minute
     */
    collectionAdminTimeoutMs: number;
    /**
     * The overall method timeout for table admin operations.
     *
     * Such methods include (but may not be limited to):
     * - `db.createTable()`
     * - `db.dropTable()`
     * - `db.listTables()`
     * - `table.alter()`
     * - `table.createIndex()`
     * - `db.dropTableIndex()`
     * - `table.definition()`
     *
     *
     * Default: 30 seconds
     */
    tableAdminTimeoutMs: number;
    /**
     * The overall method timeout for database admin operations.
     *
     * Such methods include (but may not be limited to):
     * - `admin.createDatabase()`
     * - `admin.dropDatabase()`
     * - `admin.listDatabases()`
     * - `dbAdmin.info()`
     * - `dbAdmin.findEmbeddingProviders()`
     *
     * Default: 10 minutes
     */
    databaseAdminTimeoutMs: number;
    /**
     * The overall method timeout for keyspace admin operations.
     *
     * Such methods include (but may not be limited to):
     * - `admin.createKeyspace()`
     * - `admin.dropKeyspace()`
     * - `admin.listKeyspaces()`
     *
     * Default: 30 seconds
     */
    keyspaceAdminTimeoutMs: number;
}

/* Excluded from this release type: TimeoutManager */

/* Excluded from this release type: Timeouts */

/**
 * A shorthand function for `new DataAPITimestamp(timestamp?)`
 *
 * If no timestamp is provided, it defaults to the current timestamp.
 *
 * @public
 */
export declare const timestamp: (timestamp?: string | Date | DataAPITimestampComponents) => DataAPITimestamp;

/**
 * Converts some `Schema` into a type representing its dot notation (object paths).
 *
 * If a value is any or SomeDoc, it'll be allowed to be any old object.
 *
 * *Note that this does NOT support indexing into arrays beyond the initial array index itself. Meaning,
 * `arr.0` is supported, but `arr.0.property` is not. Use a more flexible type (such as `any` or `SomeDoc`)
 * to support that.*
 *
 * @example
 * ```typescript
 * interface BasicSchema {
 *   num: number,
 *   arr: string[],
 *   obj: {
 *     nested: string,
 *     someDoc: SomeDoc,
 *   }
 * }
 *
 * interface BasicSchemaInDotNotation {
 *   'num': number,
 *   'arr': string[],
 *   [`arr.${number}`]: string,
 *   'obj': { nested: string, someDoc: SomeDoc }
 *   'obj.nested': string,
 *   'obj.someDoc': SomeDoc,
 *   [`obj.someDoc.${string}`]: any,
 * }
 * ```
 *
 * @public
 */
export declare type ToDotNotation<Schema extends SomeDoc> = Merge<_ToDotNotation<Schema, ''>>;

declare type _ToDotNotation<_Elem extends SomeDoc, Prefix extends string, Elem = Required<_Elem>> = {
    [Key in keyof Elem]: SomeDoc extends Elem ? ((Prefix extends '' ? never : {
        [Path in CropTrailingDot<Prefix>]: Elem;
    }) | {
        [Path in `${Prefix}${string}`]: any;
    }) : true extends false & Elem[Key] ? ({
        [Path in `${Prefix}${Key & string}`]: Elem[Key];
    } | {
        [Path in `${Prefix}${Key & string}.${string}`]: Elem[Key];
    }) : Elem[Key] extends any[] ? ({
        [Path in `${Prefix}${Key & string}`]: Elem[Key];
    } | {
        [Path in `${Prefix}${Key & string}.${number}`]: Elem[Key][number];
    }) : Elem[Key] extends UUID | ObjectId ? {
        [Path in `${Prefix}${Key & string}`]: Elem[Key];
    } : Elem[Key] extends Date ? {
        [Path in `${Prefix}${Key & string}`]: Date | {
            $date: number;
        };
    } : Elem[Key] extends SomeDoc ? ({
        [Path in `${Prefix}${Key & string}`]: Elem[Key];
    } | _ToDotNotation<Elem[Key], `${Prefix}${Key & string}.`>) : {
        [Path in `${Prefix}${Key & string}`]: Elem[Key];
    };
}[keyof Elem] extends infer Value ? Value : never;

/**
 * The base class for some "token provider", a general concept for anything that provides some token to the client,
 * whether it be a static token, or if the token is dynamically fetched at runtime, or periodically refreshed.
 *
 * The {@link TokenProvider.getToken} function is called any time the token is required, whether it be
 * for the Data API, or the DevOps API.
 *
 * `astra-db-ts` provides all the main token providers you may ever need to use, but you're able to extend this
 * class to create your own if you find it necessary.
 *
 * Generally, where you can pass in a `TokenProvider`, you may also pass in a plain string which is translated
 * into a {@link StaticTokenProvider} under the hood.
 *
 * @example
 * ```typescript
 * const provider = new UsernamePasswordTokenProvider('username', 'password');
 * const client = new DataAPIClient(provider);
 * ```
 *
 * @see StaticTokenProvider
 * @see UsernamePasswordTokenProvider
 *
 * @public
 */
export declare abstract class TokenProvider {
    /**
     * The function which provides the token. It may do any I/O as it wishes to obtain/refresh the token, as it's called
     * every time the token is required for use, whether it be for the Data API, or the DevOps API.
     */
    abstract getToken(): string | nullish | Promise<string | nullish>;
    /* Excluded from this release type: mergeTokens */
}

/**
 * Caused by a `countDocuments` operation that failed because the resulting number of documents exceeded *either*
 * the upper bound set by the caller, or the hard limit imposed by the Data API.
 *
 * @example
 * ```typescript
 * await collections.insertMany('<100_length_array>');
 *
 * try {
 *   await collections.countDocuments({}, 50);
 * } catch (e) {
 *   if (e instanceof TooManyDocumentsToCountError) {
 *     console.log(e.limit); // 50
 *     console.log(e.hitServerLimit); // false
 *   }
 * }
 * ```
 *
 * @field limit - The limit that was set by the caller
 * @field hitServerLimit - Whether the server-imposed limit was hit
 *
 * @public
 */
export declare class TooManyDocumentsToCountError extends DataAPIError {
    /**
     * The limit that was specified by the caller, or the server-imposed limit if the caller's limit was too high.
     */
    readonly limit: number;
    /**
     * Specifies if the server-imposed limit was hit. If this is `true`, the `limit` field will contain the server's
     * limit; otherwise it will contain the caller's limit.
     */
    readonly hitServerLimit: boolean;
    /* Excluded from this release type: __constructor */
}

/**
 * Caused by a `countRows` operation that failed because the resulting number of documents exceeded *either*
 * the upper bound set by the caller, or the hard limit imposed by the Data API.
 *
 * @example
 * ```typescript
 * await table.insertMany('<100_length_array>');
 *
 * try {
 *   await table.countRows({}, 50);
 * } catch (e) {
 *   if (e instanceof TooManyRowsToCountError) {
 *     console.log(e.limit); // 50
 *     console.log(e.hitServerLimit); // false
 *   }
 * }
 * ```
 *
 * @field limit - The limit that was set by the caller
 * @field hitServerLimit - Whether the server-imposed limit was hit
 *
 * @public
 */
export declare class TooManyRowsToCountError extends DataAPIError {
    /**
     * The limit that was specified by the caller, or the server-imposed limit if the caller's limit was too high.
     */
    readonly limit: number;
    /**
     * Specifies if the server-imposed limit was hit. If this is `true`, the `limit` field will contain the server's
     * limit; otherwise it will contain the caller's limit.
     */
    readonly hitServerLimit: boolean;
    /* Excluded from this release type: __constructor */
}

/**
 * @public
 */
export declare type TypeCodec<Fns extends CodecSerDesFns> = Pick<Fns, 'deserialize'> & {
    codecType: 'type';
    type: string;
};

/**
 * Represents some type-level error which forces immediate attention rather than failing at runtime.
 *
 * More inflexable type than `never`, and gives contextual error messages.
 *
 * @example
 * ```typescript
 * function unsupported(): TypeErr<'Unsupported operation'> {
 *   throw new Error('Unsupported operation');
 * }
 *
 * // Doesn't compile with error:
 * // Type TypeErr<'Unsupported operation'> is not assignable to type string
 * const result: string = unsupported();
 * ```
 *
 * @public
 */
declare type TypeErr<S> = {
    [$ERROR]: S;
};

declare type UnionToIntersection<U> = (U extends any ? (arg: U) => any : never) extends ((arg: infer I) => void) ? I : never;

/**
 * Represents a generic update filter type.
 *
 * See {@link CollectionUpdateFilter} & {@link TableUpdateFilter} for the more specific filter types.
 *
 * @public
 */
export declare type UpdateFilter = Record<string, any>;

/**
 * Represents the set of fields that are present in the result of some generic `update` command using the Data API when
 * the `upsert` option is true, and an upsert occurred.
 *
 * @field upsertedId - The identifier of the upserted record.
 * @field upsertedCount - The number of records that were upserted.
 *
 * @public
 */
export declare interface UpsertedUpdateResult<ID> {
    /**
     * The identifier of the upserted record.
     */
    upsertedId: ID;
    /**
     * The number of records that were upserted.
     */
    upsertedCount: 1;
}

/**
 * A token provider which translates a username-password pair into the appropriate authentication token for DSE, HCD.
 *
 * Uses the format `Cassandra:b64(username):password(username)`
 *
 * @example
 * ```typescript
 * const provider = new UsernamePasswordTokenProvider('username', 'password');
 * const client = new DataAPIClient(provider, { environment: 'dse' });
 * ```
 *
 * @see TokenProvider
 *
 * @public
 */
export declare class UsernamePasswordTokenProvider extends TokenProvider {
    #private;
    /**
     * Constructs an instead of the {@link TokenProvider}.
     *
     * @param username - The username for the DSE instance
     * @param password - The password for the DSE instance
     */
    constructor(username: string, password: string);
    /**
     * Returns the token in the format `cassandra:[username_b64]:[password_b64]`
     *
     * @returns the token in the format `cassandra:[username_b64]:[password_b64]`
     */
    getToken(): string;
}

/**
 * Represents a UUID that can be used as an _id in the DataAPI.
 *
 * Provides methods for creating v4 and v7 UUIDs, and for parsing timestamps from v7 UUIDs.
 *
 * @example
 * ```typescript
 * const collections = await db.createCollection('myCollection'. {
 *   defaultId: {
 *     type: 'uuidv7',
 *   },
 * });
 *
 * await collections.insertOne({ type: 'Jomsvikings' });
 *
 * const doc = await collections.findOne({ type: 'Jomsvikings' });
 *
 * // Prints the UUID of the document
 * console.log(doc._id.toString());
 *
 * // Prints the timestamp when the document was created (server time)
 * console.log(doc._id.getTimestamp());
 * ```
 *
 * @example
 * ```typescript
 * await collections.insertOne({ _id: UUID.v4(), car: 'toon' });
 *
 * const doc = await collections.findOne({ car: 'toon' });
 *
 * // Prints the UUID of the document
 * console.log(doc._id.toString());
 *
 * // Undefined, as the document was created with a v4 UUID
 * console.log(doc._id.getTimestamp());
 * ```
 *
 * @see ObjectId
 *
 * @public
 */
export declare class UUID implements CollCodec<typeof UUID>, TableCodec<typeof UUID> {
    #private;
    /**
     * The version of the UUID.
     */
    readonly version: number;
    /**
     * Implementation of `$SerializeForTable` for {@link TableCodec}
     */
    [$SerializeForTable](ctx: TableSerCtx): readonly [0, (string | undefined)?];
    /**
     * Implementation of `$SerializeForCollection` for {@link TableCodec}
     */
    [$SerializeForCollection](ctx: CollSerCtx): readonly [0, ({
        $uuid: string;
    } | undefined)?];
    /**
     * Implementation of `$DeserializeForTable` for {@link TableCodec}
     */
    static [$DeserializeForTable](value: any, ctx: TableDesCtx): readonly [0, (UUID | undefined)?];
    /**
     * Implementation of `$DeserializeForCollection` for {@link TableCodec}
     */
    static [$DeserializeForCollection](_: string, value: any, ctx: CollDesCtx): readonly [0, (UUID | undefined)?];
    /**
     * Creates a new UUID instance.
     *
     * Use `UUID.v4()` or `UUID.v7()` to generate random new UUIDs.
     *
     * @param uuid - The UUID string.
     * @param validate - Whether to validate the UUID string. Defaults to `true`.
     */
    constructor(uuid: string, validate?: boolean);
    /**
     * Compares this UUID to another UUID.
     *
     * **The other UUID can be a UUID instance or a string.**
     *
     * A UUID is considered equal to another UUID if their lowercase string representations are equal.
     *
     * @param other - The UUID to compare to.
     *
     * @returns `true` if the UUIDs are equal, `false` otherwise.
     */
    equals(other: unknown): boolean;
    /**
     * Returns the timestamp of a v7 UUID. If the UUID is not a v7 UUID, this method returns `undefined`.
     *
     * @returns The timestamp of the UUID, or `undefined` if the UUID is not a v7 UUID.
     */
    getTimestamp(): Date | undefined;
    /**
     * Returns the string representation of the UUID in lowercase.
     */
    toString(): string;
    /**
     * Creates a new v4 UUID.
     */
    static v4(): UUID;
    /**
     * Creates a new v7 UUID.
     */
    static v7(): UUID;
}

/**
 * A shorthand function for `new UUID(uuid)`
 *
 * `uuid(4)` and `uuid(7)` are equivalent to `UUID.v4()` and `UUID.v7()`, respectively.
 *
 * @public
 */
export declare const uuid: (uuid: string | 4 | 7) => UUID;

/**
 * A shorthand function for `new DataAPIVector(vector)`
 *
 * @public
 */
export declare const vector: (v: DataAPIVectorLike) => DataAPIVector;

/**
 * @public
 */
export declare interface VectorCreateTableColumnDefinition {
    type: 'vector';
    dimension?: number;
    service?: VectorizeServiceOptions;
}

/**
 * Utility type for a document that wishes to leverage raw vector capabilities.
 *
 * @example
 * ```typescript
 * export interface Idea extends VectorDoc {
 *   category: string,
 *   idea: string,
 * }
 *
 * db.collections<Idea>('ideas').insertOne({
 *   category: 'doors',
 *   idea: 'Upside down doors',
 *   $vector: [.23, .05, .95, .83, .42],
 * });
 * ```
 *
 * @public
 */
export declare interface VectorDoc {
    /**
     * A raw vector
     */
    $vector?: DataAPIVector;
}

/**
 * Utility type for a document that wishes to leverage automatic vectorization (assuming the collections is vectorize-enabled).
 *
 * @example
 * ```typescript
 * export interface Idea extends VectorizeDoc {
 *   category: string,
 * }
 *
 * db.collections<Idea>('ideas').insertOne({
 *   category: 'doors',
 *   $vectorize: 'Upside down doors',
 * });
 * ```
 *
 * @public
 */
export declare interface VectorizeDoc extends VectorDoc {
    /**
     * A string field to be automatically vectorized
     */
    $vectorize?: string;
}

/**
 * The options for defining the embedding service used for vectorize, to automatically transform your
 * text into a vector ready for semantic vector searching.
 *
 * You can find out more information about each provider/model in the [DataStax docs](https://docs.datastax.com/en/astra-db-serverless/databases/embedding-generation.html),
 * or through {@link DbAdmin.findEmbeddingProviders}.
 *
 * @field provider - The name of the embedding provider which provides the model to use
 * @field model - The specific model to use for embedding, or undefined if it's an endpoint-defined model
 * @field authentication - Object containing any necessary collections-bound authentication, if any
 * @field parameters - Object allowing arbitrary parameters that may be necessary on a per-model basis
 *
 * @public
 */
export declare interface VectorizeServiceOptions {
    /**
     * The name of the embedding provider which provides the model to use.
     *
     * You can find out more information about each provider in the [DataStax docs](https://docs.datastax.com/en/astra-db-serverless/databases/embedding-generation.html),
     * or through  {@link DbAdmin.findEmbeddingProviders}.
     */
    provider: string;
    /**
     * The name of the embedding model to use.
     *
     * You can find out more information about each model in the [DataStax docs](https://docs.datastax.com/en/astra-db-serverless/databases/embedding-generation.html),
     * or through {@link DbAdmin.findEmbeddingProviders}.
     */
    modelName: string | nullish;
    /**
     * Object containing any necessary collections-bound authentication, if any.
     *
     * Most commonly, `providerKey: '*SHARED_SECRET_NAME*'` may be used here to reference an API key from the Astra KMS.
     *
     * {@link Db.createCollection} and {@link Db.collection} both offer an `embeddingApiKey` parameter which utilizes
     * header-based auth to pass the provider's token/api-key to the Data API on a per-request basis instead, if that
     * is preferred (or necessary).
     */
    authentication?: Record<string, string | undefined>;
    /**
     * Object allowing arbitrary parameters that may be necessary on a per-model/per-provider basis.
     *
     * Not all providers need this, but some, such as `huggingfaceDedicated` have required parameters, others have
     * optional parameters (e.g. `openAi`), and some don't require any at all.
     *
     * You can find out more information about each provider/model in the [DataStax docs](https://docs.datastax.com/en/astra-db-serverless/databases/embedding-generation.html),
     * or through {@link DbAdmin.findEmbeddingProviders}.
     */
    parameters?: Record<string, unknown>;
}

/**
 * Includes an `_id` in the given type, even if it's not declared in the type
 *
 * @public
 */
export declare type WithId<T> = T & {
    _id: IdOf<T>;
};

/**
 * Allows you to override the keyspace to use for some db operation. If not specified,
 * the db operation will use either the keyspace provided when creating the Db instance, the keyspace
 * provided when creating the DataAPIClient instance, or the default keyspace `'default_keyspace'`.
 * (in that order)
 *
 * @example
 * ```typescript
 * const client = new DataAPIClient('AstraCS:...');
 *
 * // Using 'default_keyspace' as the keyspace
 * const db1 = client.db('https://<db_id>-<region>.apps.astra.datastax.com');
 *
 * // Using 'my_keyspace' as the keyspace
 * const db2 = client.db('https://<db_id>-<region>.apps.astra.datastax.com', {
 *   keyspace: 'my_keyspace',
 * });
 *
 * // Finds 'my_collection' in 'default_keyspace'
 * const coll1 = db1.collection('my_collection');
 *
 * // Finds 'my_collection' in 'my_keyspace'
 * const coll2 = db1.collection('my_collection', {
 *   keyspace: 'my_keyspace',
 * });
 * ```
 *
 * @field keyspace - The keyspace to use for the db operation.
 *
 * @public
 */
export declare interface WithKeyspace {
    /**
     * The keyspace to use for the operation.
     */
    keyspace?: string;
}

/**
 * Adds `$similarity?: number` to the given type, representing the vector similarity score of the document if a vector search was performed.
 *
 * @public
 */
export declare type WithSim<Schema extends SomeDoc> = Schema & {
    $similarity?: number;
};

/**
 * ##### Overview
 *
 * Lets you specify timeouts for individual methods, in two different formats:
 * - A subtype of {@link TimeoutDescriptor}, which lets you specify the timeout for specific categories.
 * - A number, which specifies the "happy path" timeout for the method.
 *   - In single-call methods, this sets both the request & overall method timeouts.
 *   - In multi-call methods, this sets the overall method timeout (request timeouts are kept as default).
 *
 * @example
 * ```ts
 * // Both `requestTimeoutMs` and `generalMethodTimeoutMs` are set to 1000ms.
 * await coll.insertOne({ ... }, { timeout: 1000 });
 *
 * // `requestTimeoutMs` is left as default, `generalMethodTimeoutMs` is set to 2000ms.
 * await coll.insertOne({ ... }, { timeout: { generalMethodTimeoutMs: 2000 } });
 *
 * // Both `requestTimeoutMs` and `generalMethodTimeoutMs` are set to 2000ms.
 * await coll.insertMany([...], {
 *   timeout: { requestTimeoutMs: 2000, generalMethodTimeoutMs: 2000 },
 * });
 * ```
 *
 * @example
 * ```ts
 * // `requestTimeoutMs` is left as default, `generalMethodTimeoutMs` is set to 2000ms.
 * await coll.insertMany([...], { timeout: 2000 });
 *
 * // `requestTimeoutMs` is left as default, `generalMethodTimeoutMs` is set to 2000ms.
 * await coll.insertMany([...], { timeout: { generalMethodTimeoutMs: 2000 } });
 *
 * // Both `requestTimeoutMs` and `generalMethodTimeoutMs` are set to 2000ms.
 * await coll.insertMany([...], {
 *   timeout: { requestTimeoutMs: 2000, generalMethodTimeoutMs: 2000 },
 * });
 * ```
 *
 * See {@link TimeoutDescriptor} for much more information.
 *
 * @see TimeoutDescriptor
 *
 * @public
 */
export declare interface WithTimeout<Timeouts extends keyof TimeoutDescriptor> {
    /**
     * The method timeout override.
     *
     * See {@link TimeoutDescriptor} for much more information.
     */
    timeout?: number | Pick<Partial<TimeoutDescriptor>, 'requestTimeoutMs' | Timeouts>;
}

export { }
