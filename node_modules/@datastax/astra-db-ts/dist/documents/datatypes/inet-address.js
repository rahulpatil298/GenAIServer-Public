"use strict";
// Copyright Datastax, Inc
// SPDX-License-Identifier: Apache-2.0
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _InetAddress_raw, _InetAddress_version;
Object.defineProperty(exports, "__esModule", { value: true });
exports.InetAddress = exports.inet = void 0;
const constants_1 = require("../../lib/constants");
const constants_2 = require("../../documents/tables/ser-des/constants");
const inet = (address, version) => new InetAddress(address, version);
exports.inet = inet;
class InetAddress {
        [(_InetAddress_raw = new WeakMap(), _InetAddress_version = new WeakMap(), constants_2.$SerializeForTable)](ctx) {
        return ctx.done(__classPrivateFieldGet(this, _InetAddress_raw, "f"));
    }
    ;
        static [constants_2.$DeserializeForTable](value, ctx) {
        return ctx.done(new InetAddress(value, null, false));
    }
        constructor(address, version, validate = true) {
        _InetAddress_raw.set(this, void 0);
        _InetAddress_version.set(this, void 0);
        if (validate) {
            switch (version) {
                case 4:
                    if (!isIPv4(address)) {
                        throw new Error(`'${address}' is not a valid IPv4 address`);
                    }
                    break;
                case 6:
                    if (!isIPv6(address)) {
                        throw new Error(`'${address}' is not a valid IPv6 address`);
                    }
                    break;
                default:
                    if (!(version = isIPv4(address) ? 4 : isIPv6(address) ? 6 : null)) {
                        throw new Error(`'${address}' is not a valid IPv4 or IPv6 address`);
                    }
            }
        }
        __classPrivateFieldSet(this, _InetAddress_raw, address.toLowerCase(), "f");
        __classPrivateFieldSet(this, _InetAddress_version, version, "f");
        Object.defineProperty(this, constants_1.$CustomInspect, {
            value: () => `InetAddress<${this.version}>("${__classPrivateFieldGet(this, _InetAddress_raw, "f")}")`,
        });
    }
        get version() {
        if (!__classPrivateFieldGet(this, _InetAddress_version, "f")) {
            __classPrivateFieldSet(this, _InetAddress_version, isIPv4(__classPrivateFieldGet(this, _InetAddress_raw, "f")) ? 4 : 6, "f");
        }
        return __classPrivateFieldGet(this, _InetAddress_version, "f");
    }
        toString() {
        return __classPrivateFieldGet(this, _InetAddress_raw, "f");
    }
}
exports.InetAddress = InetAddress;
const IPv4Lengths = { max: 15, min: 7 };
const IPv6Lengths = { max: 45, min: 2 };
// =====================================================================================================================
// From https://github.com/sindresorhus/ip-regex/blob/main/index.js
// Was getting errors trying to import it while as a dependency, so just decided not to deal with it for the time being
const v4 = '(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}';
const v6segment = '[a-fA-F\\d]{1,4}';
const v6 = `
(?:
(?:${v6segment}:){7}(?:${v6segment}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6segment}:){6}(?:${v4}|:${v6segment}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6segment}:){5}(?::${v4}|(?::${v6segment}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6segment}:){4}(?:(?::${v6segment}){0,1}:${v4}|(?::${v6segment}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6segment}:){3}(?:(?::${v6segment}){0,2}:${v4}|(?::${v6segment}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6segment}:){2}(?:(?::${v6segment}){0,3}:${v4}|(?::${v6segment}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6segment}:){1}(?:(?::${v6segment}){0,4}:${v4}|(?::${v6segment}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${v6segment}){0,5}:${v4}|(?::${v6segment}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, '').replace(/\n/g, '').trim();
const IPv4Regex = new RegExp(`^${v4}$`);
const IPv6Regex = new RegExp(`^${v6}$`);
// =====================================================================================================================
function isIPv6(raw) {
    if (raw.length < IPv6Lengths.min || IPv6Lengths.max < raw.length) {
        return false;
    }
    return IPv6Regex.test(raw);
}
function isIPv4(raw) {
    if (raw.length < IPv4Lengths.min || IPv4Lengths.max < raw.length) {
        return false;
    }
    return IPv4Regex.test(raw);
}
