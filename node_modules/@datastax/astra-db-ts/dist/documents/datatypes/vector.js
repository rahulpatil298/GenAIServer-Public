"use strict";
// Copyright Datastax, Inc
// SPDX-License-Identifier: Apache-2.0
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _DataAPIVector_vector;
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataAPIVector = exports.vector = void 0;
const constants_1 = require("../../lib/constants");
const constants_2 = require("../../documents/collections/ser-des/constants");
const constants_3 = require("../../documents/tables/ser-des/constants");
const vector = (v) => new DataAPIVector(v);
exports.vector = vector;
class DataAPIVector {
        [(_DataAPIVector_vector = new WeakMap(), constants_3.$SerializeForTable)](ctx) {
        return ctx.done(serialize(__classPrivateFieldGet(this, _DataAPIVector_vector, "f")));
    }
    ;
        [constants_2.$SerializeForCollection](ctx) {
        return ctx.done(serialize(__classPrivateFieldGet(this, _DataAPIVector_vector, "f")));
    }
    ;
        static [constants_3.$DeserializeForTable](value, ctx) {
        return ctx.done(new DataAPIVector(value, false));
    }
        static [constants_2.$DeserializeForCollection](_, value, ctx) {
        return ctx.done(new DataAPIVector(value, false));
    }
        constructor(vector, validate = true) {
        _DataAPIVector_vector.set(this, void 0);
        if (validate && !DataAPIVector.isVectorLike(vector)) {
            throw new Error(`Invalid vector type; expected number[], base64 string, Float32Array, or DataAPIVector; got '${vector}'`);
        }
        __classPrivateFieldSet(this, _DataAPIVector_vector, (vector instanceof DataAPIVector)
            ? vector.raw()
            : vector, "f");
        // this[$SerializeForTable] = () => serialize(this.#vector);
        // this[$SerializeForCollection] = this[$SerializeForTable];
        Object.defineProperty(this, constants_1.$CustomInspect, {
            value: this.toString,
        });
    }
        get length() {
        if ('$binary' in __classPrivateFieldGet(this, _DataAPIVector_vector, "f")) {
            return ~~((__classPrivateFieldGet(this, _DataAPIVector_vector, "f").$binary.replace(/=+$/, "").length * 3) / 4 / 4);
        }
        return __classPrivateFieldGet(this, _DataAPIVector_vector, "f").length;
    }
        raw() {
        return __classPrivateFieldGet(this, _DataAPIVector_vector, "f");
    }
        asArray() {
        if (__classPrivateFieldGet(this, _DataAPIVector_vector, "f") instanceof Float32Array) {
            return Array.from(__classPrivateFieldGet(this, _DataAPIVector_vector, "f"));
        }
        if ('$binary' in __classPrivateFieldGet(this, _DataAPIVector_vector, "f")) {
            const deserialized = deserializeToNumberArray(__classPrivateFieldGet(this, _DataAPIVector_vector, "f").$binary);
            if (!deserialized) {
                throw new Error('Could not to deserialize vector from base64 => number[]; unknown environment. Please manually deserialize the binary from `vector.getAsBase64()`');
            }
            return deserialized;
        }
        return __classPrivateFieldGet(this, _DataAPIVector_vector, "f");
    }
        asFloat32Array() {
        if (__classPrivateFieldGet(this, _DataAPIVector_vector, "f") instanceof Float32Array) {
            return __classPrivateFieldGet(this, _DataAPIVector_vector, "f");
        }
        if ('$binary' in __classPrivateFieldGet(this, _DataAPIVector_vector, "f")) {
            const deserialized = deserializeToF32Array(__classPrivateFieldGet(this, _DataAPIVector_vector, "f").$binary);
            if (!deserialized) {
                throw new Error('Could not to deserialize vector from base64 => Float32Array; unknown environment. Please manually deserialize the binary from `vector.getAsBase64()`');
            }
            return deserialized;
        }
        return new Float32Array(__classPrivateFieldGet(this, _DataAPIVector_vector, "f"));
    }
        asBase64() {
        const serialized = serialize(__classPrivateFieldGet(this, _DataAPIVector_vector, "f"));
        if (!('$binary' in serialized)) {
            if (Array.isArray(__classPrivateFieldGet(this, _DataAPIVector_vector, "f"))) {
                throw new Error('Could not serialize vector from number[] => base64; unknown environment. Please manually serialize the binary from `vector.getRaw()`/`vector.getAsArray()`');
            }
            else {
                throw new Error('Could not serialize vector from Float32Array => base64; unknown environment. Please manually serialize the binary from `vector.getRaw()`/`vector.getAsFloat32Array()`');
            }
        }
        return serialized.$binary;
    }
        toString() {
        const type = ('$binary' in __classPrivateFieldGet(this, _DataAPIVector_vector, "f") && 'base64') || (__classPrivateFieldGet(this, _DataAPIVector_vector, "f") instanceof Float32Array && 'Float32Array') || 'number[]';
        const partial = ('$binary' in __classPrivateFieldGet(this, _DataAPIVector_vector, "f"))
            ? `'${__classPrivateFieldGet(this, _DataAPIVector_vector, "f").$binary.slice(0, 12)}${__classPrivateFieldGet(this, _DataAPIVector_vector, "f").$binary.length > 12 ? '...' : ''}'`
            : `[${__classPrivateFieldGet(this, _DataAPIVector_vector, "f").slice(0, 2).join(', ')}${__classPrivateFieldGet(this, _DataAPIVector_vector, "f").length > 2 ? ', ...' : ''}]`;
        return `DataAPIVector<${this.length}>(typeof raw=${type}, preview=${partial})`;
    }
        static isVectorLike(value) {
        return !!value && typeof value === 'object' && (Array.isArray(value) || value instanceof Float32Array || ('$binary' in value && typeof value.$binary === 'string') || value instanceof DataAPIVector);
    }
}
exports.DataAPIVector = DataAPIVector;
const serialize = (vector) => {
    if ('$binary' in vector) {
        return vector;
    }
    if (typeof Buffer !== 'undefined') {
        const buffer = Buffer.allocUnsafe(vector.length * 4);
        for (let i = 0; i < vector.length; i++) {
            buffer.writeFloatBE(vector[i], i * 4);
        }
        return { $binary: buffer.toString('base64') };
    }
    if (typeof window !== 'undefined' && window.btoa) {
        const buffer = new Uint8Array(vector.length * 4);
        const view = new DataView(buffer.buffer);
        for (let i = 0; i < vector.length; i++) {
            view.setFloat32(i * 4, vector[i], false);
        }
        let binary = '';
        for (let i = 0; i < buffer.length; i++) {
            binary += String.fromCharCode(buffer[i]);
        }
        return { $binary: window.btoa(binary) };
    }
    if (vector instanceof Float32Array) {
        return Array.from(vector);
    }
    return vector;
};
const deserializeToNumberArray = (serialized) => {
    if (typeof Buffer !== 'undefined') {
        const buffer = Buffer.from(serialized, 'base64');
        const vector = Array.from({ length: buffer.length / 4 });
        for (let i = 0; i < vector.length; i++) {
            vector[i] = buffer.readFloatBE(i * 4);
        }
        return vector;
    }
    const deserialized = deserializeToF32Array(serialized);
    if (deserialized) {
        return Array.from(deserialized);
    }
    return undefined;
};
const deserializeToF32Array = (serialized) => {
    if (typeof Buffer !== 'undefined') {
        const buffer = Buffer.from(serialized, 'base64');
        const vector = new Float32Array(buffer.length / 4);
        for (let i = 0; i < vector.length; i++) {
            vector[i] = buffer.readFloatBE(i * 4);
        }
        return vector;
    }
    if (typeof window !== 'undefined') {
        const binary = window.atob(serialized);
        const buffer = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) {
            buffer[i] = binary.charCodeAt(i);
        }
        return new Float32Array(buffer.buffer);
    }
    return undefined;
};
