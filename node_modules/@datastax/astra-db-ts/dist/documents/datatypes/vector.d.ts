import { CollCodec, type CollDesCtx, type CollSerCtx, TableCodec, TableDesCtx, TableSerCtx } from '../../documents';
import { $DeserializeForCollection, $SerializeForCollection } from '../../documents/collections/ser-des/constants';
import { $DeserializeForTable, $SerializeForTable } from '../../documents/tables/ser-des/constants';
/**
 * Represents any type that can be converted into a {@link DataAPIVector}
 *
 * @public
 */
export type DataAPIVectorLike = number[] | {
    $binary: string;
} | Float32Array | DataAPIVector;
/**
 * A shorthand function for `new DataAPIVector(vector)`
 *
 * @public
 */
export declare const vector: (v: DataAPIVectorLike) => DataAPIVector;
/**
 * Represents a `vector` column for Data API tables.
 *
 * See {@link DataAPIVectorLike} for the types that can be converted into a `DataAPIVector`.
 *
 * You may use the {@link vector} function as a shorthand for creating a new `DataAPIVector`.
 *
 * See the official DataStax documentation for more information.
 *
 * @public
 */
export declare class DataAPIVector implements CollCodec<typeof DataAPIVector>, TableCodec<typeof DataAPIVector> {
    #private;
    /**
     * Implementation of `$SerializeForTable` for {@link TableCodec}
     */
    [$SerializeForTable](ctx: TableSerCtx): readonly [0, (number[] | {
        $binary: string;
    } | undefined)?];
    /**
     * Implementation of `$SerializeForCollection` for {@link TableCodec}
     */
    [$SerializeForCollection](ctx: CollSerCtx): readonly [0, (number[] | {
        $binary: string;
    } | undefined)?];
    /**
     * Implementation of `$DeserializeForTable` for {@link TableCodec}
     */
    static [$DeserializeForTable](value: any, ctx: TableDesCtx): readonly [0, (DataAPIVector | undefined)?];
    /**
     * Implementation of `$DeserializeForCollection` for {@link TableCodec}
     */
    static [$DeserializeForCollection](_: string, value: any, ctx: CollDesCtx): readonly [0, (DataAPIVector | undefined)?];
    /**
     * Creates a new `DataAPIVector` instance from a vector-like value.
     *
     * You can set `validate` to `false` to bypass any validation if you're confident the value is a valid vector.
     *
     * @param vector - The vector-like value to convert to a `DataAPIVector`
     * @param validate - Whether to validate the vector-like value (default: `true`)
     *
     * @throws TypeError If `vector` is not a valid vector-like value
     */
    constructor(vector: DataAPIVectorLike, validate?: boolean);
    /**
     * Returns the length of the vector (# of floats), agnostic of the underlying type.
     *
     * @returns The length of the vector
     */
    get length(): number;
    /**
     * Gets the raw underlying implementation of the vector.
     *
     * @returns The raw vector
     */
    raw(): Exclude<DataAPIVectorLike, DataAPIVector>;
    /**
     * Returns the vector as a `number[]`, converting between types if necessary.
     *
     * @returns The vector as a `number[]`
     */
    asArray(): number[];
    /**
     * Returns the vector as a `Float32Array`, converting between types if necessary.
     *
     * @returns The vector as a `Float32Array`
     */
    asFloat32Array(): Float32Array;
    /**
     * Returns the vector as a base64 string, converting between types if necessary.
     *
     * @returns The vector as a base64 string
     */
    asBase64(): string;
    /**
     * Returns a pretty string representation of the `DataAPIVector`.
     */
    toString(): string;
    /**
     * Determines whether the given value is a vector-like value (i.e. it's {@link DataAPIVectorLike}.
     *
     * @param value - The value to check
     *
     * @returns `true` if the value is a vector-like value; `false` otherwise
     */
    static isVectorLike(value: unknown): value is DataAPIVectorLike;
}
