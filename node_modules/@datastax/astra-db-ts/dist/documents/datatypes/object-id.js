"use strict";
// Copyright Datastax, Inc
// SPDX-License-Identifier: Apache-2.0
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _ObjectId_raw;
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObjectId = exports.oid = void 0;
const utils_1 = require("../../lib/utils");
const constants_1 = require("../../lib/constants");
const constants_2 = require("../../documents/collections/ser-des/constants");
const objectIdRegex = new RegExp('^[0-9a-fA-F]{24}$');
const oid = (id) => new ObjectId(id);
exports.oid = oid;
class ObjectId {
        [(_ObjectId_raw = new WeakMap(), constants_2.$SerializeForCollection)](ctx) {
        return ctx.done({ $objectId: __classPrivateFieldGet(this, _ObjectId_raw, "f") });
    }
    ;
        static [constants_2.$DeserializeForCollection](_, value, ctx) {
        return ctx.done(new ObjectId(value.$objectId, false));
    }
        constructor(id, validate = true) {
        _ObjectId_raw.set(this, void 0);
        if (validate) {
            if (typeof id === 'string') {
                if (id.length !== 24 || !objectIdRegex.test(id)) {
                    throw new Error('ObjectId must be a 24-character hex string');
                }
            }
            else if (typeof id !== 'number' && !(0, utils_1.isNullish)(id)) {
                throw new Error('ObjectId must be a string, number, or nullish');
            }
        }
        __classPrivateFieldSet(this, _ObjectId_raw, (typeof id === 'string') ? id.toLowerCase() : genObjectId(id), "f");
        Object.defineProperty(this, constants_1.$CustomInspect, {
            value: () => `ObjectId("${__classPrivateFieldGet(this, _ObjectId_raw, "f")}")`,
        });
    }
        equals(other) {
        if (typeof other === 'string') {
            return __classPrivateFieldGet(this, _ObjectId_raw, "f").localeCompare(other, undefined, { sensitivity: 'accent' }) === 0;
        }
        if (other instanceof ObjectId) {
            return __classPrivateFieldGet(this, _ObjectId_raw, "f").localeCompare(__classPrivateFieldGet(other, _ObjectId_raw, "f"), undefined, { sensitivity: 'accent' }) === 0;
        }
        return false;
    }
        getTimestamp() {
        const time = parseInt(__classPrivateFieldGet(this, _ObjectId_raw, "f").slice(0, 8), 16);
        return new Date(~~time * 1000);
    }
        toString() {
        return __classPrivateFieldGet(this, _ObjectId_raw, "f");
    }
}
exports.ObjectId = ObjectId;
const RAND_ID = ~~(Math.random() * 0xFFFFFF);
const PID = ((typeof process === 'undefined' || typeof process.pid !== 'number') ? ~~(Math.random() * 100000) : process.pid) % 0xFFFF;
const HexTable = Array.from({ length: 256 }, (_, i) => {
    return (i <= 15 ? '0' : '') + i.toString(16);
});
let index = ~~(Math.random() * 0xFFFFFF);
function genObjectId(time) {
    time ?? (time = ~~(Date.now() / 1000));
    time = time % 0xFFFFFFFF;
    index = (index + 1) % 0xFFFFFF;
    let hexString = '';
    hexString += HexTable[((time >> 24) & 0xFF)];
    hexString += HexTable[((time >> 16) & 0xFF)];
    hexString += HexTable[((time >> 8) & 0xFF)];
    hexString += HexTable[(time & 0xFF)];
    hexString += HexTable[((RAND_ID >> 16) & 0xFF)];
    hexString += HexTable[((RAND_ID >> 8) & 0xFF)];
    hexString += HexTable[(RAND_ID & 0xFF)];
    hexString += HexTable[((PID >> 8) & 0xFF)];
    hexString += HexTable[(PID & 0xFF)];
    hexString += HexTable[((index >> 16) & 0xFF)];
    hexString += HexTable[((index >> 8) & 0xFF)];
    hexString += HexTable[(index & 0xFF)];
    return hexString;
}
