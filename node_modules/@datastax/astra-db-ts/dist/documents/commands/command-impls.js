"use strict";
// Copyright Datastax, Inc
// SPDX-License-Identifier: Apache-2.0
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommandImpls = void 0;
const documents_1 = require("../../documents");
const insertion_1 = require("../../documents/commands/helpers/insertion");
const updates_1 = require("../../documents/commands/helpers/updates");
const errors_1 = require("../../documents/errors");
const utils_1 = require("../../documents/utils");
const distinct_1 = require("../../documents/commands/helpers/distinct");
const safe_stable_stringify_1 = __importDefault(require("safe-stable-stringify"));
class CommandImpls {
    constructor(tOrC, httpClient, serdes) {
        Object.defineProperty(this, "_httpClient", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_serdes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_tOrC", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._httpClient = httpClient;
        this._serdes = serdes;
        this._tOrC = tOrC;
    }
    async insertOne(_document, options) {
        const document = this._serdes.serializeRecord(_document);
        const command = mkBasicCmd('insertOne', {
            document: document[0],
        });
        const raw = await this._httpClient.executeCommand(command, {
            timeoutManager: this._httpClient.tm.single('generalMethodTimeoutMs', options),
            bigNumsPresent: document[1],
        });
        return {
            insertedId: this._serdes.deserializeRecord(raw.status.insertedIds[0], raw, true),
        };
    }
    async insertMany(docs, options, err) {
        const chunkSize = options?.chunkSize ?? 50;
        const timeoutManager = this._httpClient.tm.multipart('generalMethodTimeoutMs', options);
        const insertedIds = (options?.ordered)
            ? await (0, insertion_1.insertManyOrdered)(this._httpClient, this._serdes, docs, chunkSize, timeoutManager, err)
            : await (0, insertion_1.insertManyUnordered)(this._httpClient, this._serdes, docs, options?.concurrency ?? 8, chunkSize, timeoutManager, err);
        return {
            insertedCount: insertedIds.length,
            insertedIds: insertedIds,
        };
    }
    async updateOne(_filter, _update, options) {
        const filter = this._serdes.serializeRecord(_filter);
        const update = this._serdes.serializeRecord(_update);
        const command = mkCmdWithSortProj('updateOne', options, {
            filter: filter[0],
            update: update[0],
            options: {
                upsert: options?.upsert,
            },
        });
        const resp = await this._httpClient.executeCommand(command, {
            timeoutManager: this._httpClient.tm.single('generalMethodTimeoutMs', options),
            bigNumsPresent: filter[1] || update[1],
        });
        return (0, updates_1.coalesceUpsertIntoUpdateResult)((0, updates_1.mkUpdateResult)(resp), resp);
    }
    async updateMany(_filter, _update, options) {
        const filter = this._serdes.serializeRecord(_filter);
        const update = this._serdes.serializeRecord(_update);
        const command = mkBasicCmd('updateMany', {
            filter: filter[0],
            update: update[0],
            options: {
                pageState: undefined,
                upsert: options?.upsert,
            },
        });
        const timeoutManager = this._httpClient.tm.multipart('generalMethodTimeoutMs', options);
        const commonResult = (0, updates_1.mkUpdateResult)();
        let resp;
        try {
            while (!resp || resp.status?.nextPageState) {
                resp = await this._httpClient.executeCommand(command, {
                    bigNumsPresent: filter[1] || update[1],
                    timeoutManager,
                });
                command.updateMany.options.pageState = resp.status?.nextPageState;
                commonResult.modifiedCount += resp.status?.modifiedCount ?? 0;
                commonResult.matchedCount += resp.status?.matchedCount ?? 0;
            }
        }
        catch (e) {
            if (!(e instanceof documents_1.DataAPIResponseError)) {
                throw e;
            }
            const { rawResponse: raw } = e.detailedErrorDescriptors[0];
            commonResult.modifiedCount += raw.status?.modifiedCount ?? 0;
            commonResult.matchedCount += raw.status?.matchedCount ?? 0;
            throw (0, errors_1.mkRespErrorFromResponse)(documents_1.CollectionUpdateManyError, command, raw, {
                partialResult: { ...commonResult, upsertedCount: raw.status?.upsertedCount ?? 0 },
            });
        }
        return (0, updates_1.coalesceUpsertIntoUpdateResult)(commonResult, resp);
    }
    async replaceOne(_filter, _replacement, options) {
        const filter = this._serdes.serializeRecord(_filter);
        const replacement = this._serdes.serializeRecord(_replacement);
        const command = mkCmdWithSortProj('findOneAndReplace', options, {
            filter: filter[0],
            replacement: replacement[0],
            options: {
                returnDocument: 'before',
                upsert: options?.upsert,
            },
            projection: { '*': 0 },
        });
        const resp = await this._httpClient.executeCommand(command, {
            timeoutManager: this._httpClient.tm.single('generalMethodTimeoutMs', options),
            bigNumsPresent: filter[1] || replacement[1],
        });
        return (0, updates_1.coalesceUpsertIntoUpdateResult)((0, updates_1.mkUpdateResult)(resp), resp);
    }
    async deleteOne(_filter, options) {
        const filter = this._serdes.serializeRecord(_filter);
        const command = mkCmdWithSortProj('deleteOne', options, {
            filter: filter[0],
        });
        const deleteOneResp = await this._httpClient.executeCommand(command, {
            timeoutManager: this._httpClient.tm.single('generalMethodTimeoutMs', options),
            bigNumsPresent: filter[1],
        });
        return {
            deletedCount: deleteOneResp.status?.deletedCount,
        };
    }
    async deleteMany(_filter, options) {
        const filter = this._serdes.serializeRecord(_filter);
        const command = mkBasicCmd('deleteMany', {
            filter: filter[0],
        });
        const timeoutManager = this._httpClient.tm.multipart('generalMethodTimeoutMs', options);
        let resp, numDeleted = 0;
        try {
            while (!resp || resp.status?.moreData) {
                resp = await this._httpClient.executeCommand(command, { timeoutManager, bigNumsPresent: filter[1] });
                numDeleted += resp.status?.deletedCount ?? 0;
            }
        }
        catch (e) {
            if (!(e instanceof documents_1.DataAPIResponseError)) {
                throw e;
            }
            const desc = e.detailedErrorDescriptors[0];
            throw (0, errors_1.mkRespErrorFromResponse)(documents_1.CollectionDeleteManyError, command, desc.rawResponse, {
                partialResult: {
                    deletedCount: numDeleted + (desc.rawResponse.status?.deletedCount ?? 0),
                },
            });
        }
        return {
            deletedCount: numDeleted,
        };
    }
    find(filter, options, cursor) {
        if (options?.sort) {
            options.sort = (0, utils_1.normalizedSort)(options.sort);
        }
        return new cursor(this._tOrC, this._serdes, this._serdes.serializeRecord(structuredClone(filter)), structuredClone(options));
    }
    async findOne(_filter, options) {
        const filter = this._serdes.serializeRecord(_filter);
        const command = mkCmdWithSortProj('findOne', options, {
            filter: filter[0],
            options: {
                includeSimilarity: options?.includeSimilarity,
            },
        });
        const resp = await this._httpClient.executeCommand(command, {
            timeoutManager: this._httpClient.tm.single('generalMethodTimeoutMs', options),
            bigNumsPresent: filter[1],
        });
        return this._serdes.deserializeRecord(resp.data?.document, resp);
    }
    async findOneAndReplace(_filter, _replacement, options) {
        const filter = this._serdes.serializeRecord(_filter);
        const replacement = this._serdes.serializeRecord(_replacement);
        const command = mkCmdWithSortProj('findOneAndReplace', options, {
            filter: filter[0],
            replacement: replacement[0],
            options: {
                returnDocument: options?.returnDocument,
                upsert: options?.upsert,
            },
        });
        const resp = await this._httpClient.executeCommand(command, {
            timeoutManager: this._httpClient.tm.single('generalMethodTimeoutMs', options),
            bigNumsPresent: filter[1] || replacement[1],
        });
        return resp.data?.document || null;
    }
    async findOneAndDelete(_filter, options) {
        const filter = this._serdes.serializeRecord(_filter);
        const command = mkCmdWithSortProj('findOneAndDelete', options, {
            filter: filter[0],
        });
        const resp = await this._httpClient.executeCommand(command, {
            timeoutManager: this._httpClient.tm.single('generalMethodTimeoutMs', options),
            bigNumsPresent: filter[1],
        });
        return resp.data?.document || null;
    }
    async findOneAndUpdate(_filter, _update, options) {
        const filter = this._serdes.serializeRecord(_filter);
        const update = this._serdes.serializeRecord(_update);
        const command = mkCmdWithSortProj('findOneAndUpdate', options, {
            filter: filter[0],
            update: update[0],
            options: {
                returnDocument: options?.returnDocument,
                upsert: options?.upsert,
            },
        });
        const resp = await this._httpClient.executeCommand(command, {
            timeoutManager: this._httpClient.tm.single('generalMethodTimeoutMs', options),
            bigNumsPresent: filter[1] || update[1],
        });
        return resp.data?.document || null;
    }
    async distinct(key, filter, options, mkCursor) {
        const projection = (0, distinct_1.pullSafeProjection4Distinct)(key);
        const cursor = this.find(filter, { projection: { _id: 0, [projection]: 1 }, timeout: options?.timeout }, mkCursor);
        const seen = new Set();
        const ret = [];
        const extract = (0, distinct_1.mkDistinctPathExtractor)(key);
        for await (const doc of cursor) {
            const values = extract(doc);
            for (let i = 0, n = values.length; i < n; i++) {
                const value = values[i];
                const key = (typeof value === 'object')
                    ? (0, safe_stable_stringify_1.default)(value)
                    : value;
                if (!seen.has(key)) {
                    ret.push(value);
                    seen.add(key);
                }
            }
        }
        return ret;
    }
    async countDocuments(_filter, upperBound, options, error) {
        if (!upperBound) {
            throw new Error('upperBound is required');
        }
        if (upperBound < 0) {
            throw new Error('upperBound must be >= 0');
        }
        const [filter, bigNumsPresent] = this._serdes.serializeRecord(_filter);
        const command = mkBasicCmd('countDocuments', {
            filter: filter,
        });
        const resp = await this._httpClient.executeCommand(command, {
            timeoutManager: this._httpClient.tm.single('generalMethodTimeoutMs', options),
            bigNumsPresent,
        });
        if (resp.status?.moreData) {
            throw new error(resp.status.count, true);
        }
        if (resp.status?.count > upperBound) {
            throw new error(upperBound, false);
        }
        return resp.status?.count;
    }
    async estimatedDocumentCount(options) {
        const command = mkBasicCmd('estimatedDocumentCount', {});
        const resp = await this._httpClient.executeCommand(command, {
            timeoutManager: this._httpClient.tm.single('generalMethodTimeoutMs', options),
        });
        return resp.status?.count;
    }
}
exports.CommandImpls = CommandImpls;
const mkBasicCmd = (name, body) => ({ [name]: body });
const mkCmdWithSortProj = (name, options, body) => {
    const command = mkBasicCmd(name, body);
    if (options) {
        if (options.sort) {
            body.sort = (0, utils_1.normalizedSort)(options.sort);
        }
        if (options.projection && Object.keys(options.projection).length > 0) {
            body.projection = options.projection;
        }
    }
    return command;
};
