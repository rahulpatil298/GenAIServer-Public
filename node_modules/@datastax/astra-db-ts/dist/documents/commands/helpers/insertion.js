"use strict";
// Copyright Datastax, Inc
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.insertManyUnordered = exports.insertManyOrdered = void 0;
const errors_1 = require("../../../documents/errors");
const insertManyOrdered = async (httpClient, serdes, documents, chunkSize, timeoutManager, err) => {
    const insertedIds = [];
    for (let i = 0, n = documents.length; i < n; i += chunkSize) {
        const slice = documents.slice(i, i + chunkSize);
        const [_docResp, inserted, errDesc] = await insertMany(httpClient, serdes, slice, true, timeoutManager);
        insertedIds.push(...inserted);
        if (errDesc) {
            throw (0, errors_1.mkRespErrorFromResponse)(err, errDesc.command, errDesc.rawResponse, {
                partialResult: {
                    insertedIds: insertedIds,
                    insertedCount: insertedIds.length,
                },
                // documentResponses: docResp,
                // failedCount: docResp.length - insertedIds.length,
            });
        }
    }
    return insertedIds;
};
exports.insertManyOrdered = insertManyOrdered;
const insertManyUnordered = async (httpClient, serdes, documents, concurrency, chunkSize, timeoutManager, err) => {
    const insertedIds = [];
    let masterIndex = 0;
    const failCommands = [];
    const failRaw = [];
    const docResps = [];
    const promises = Array.from({ length: concurrency }, async () => {
        while (masterIndex < documents.length) {
            const localI = masterIndex;
            const endIdx = Math.min(localI + chunkSize, documents.length);
            masterIndex += chunkSize;
            if (localI >= endIdx) {
                break;
            }
            const slice = documents.slice(localI, endIdx);
            const [docResp, inserted, errDesc] = await insertMany(httpClient, serdes, slice, false, timeoutManager);
            insertedIds.push(...inserted);
            docResps.push(...docResp);
            if (errDesc) {
                failCommands.push(errDesc.command);
                failRaw.push(errDesc.rawResponse);
            }
        }
    });
    await Promise.all(promises);
    if (failCommands.length > 0) {
        throw (0, errors_1.mkRespErrorFromResponses)(err, failCommands, failRaw, {
            partialResult: {
                insertedIds: insertedIds,
                insertedCount: insertedIds.length,
            },
            // documentResponses: docResps,
            // failedCount: docResps.length - insertedIds.length,
        });
    }
    return insertedIds;
};
exports.insertManyUnordered = insertManyUnordered;
const insertMany = async (httpClient, serdes, documents, ordered, timeoutManager) => {
    let raw, err;
    try {
        const serialized = [];
        let bigNumsPresent = false;
        for (let i = 0, n = documents.length; i < n; i++) {
            const resp = serdes.serializeRecord(documents[i]);
            serialized.push(resp[0]);
            bigNumsPresent || (bigNumsPresent = resp[1]);
        }
        raw = await httpClient.executeCommand({
            insertMany: {
                documents: serialized,
                options: {
                    returnDocumentResponses: true,
                    ordered,
                },
            },
        }, { timeoutManager, bigNumsPresent });
    }
    catch (e) {
        if (!(e instanceof errors_1.DataAPIResponseError)) {
            throw e;
        }
        raw = e.detailedErrorDescriptors[0].rawResponse;
        err = e;
    }
    const documentResponses = raw.status?.documentResponses ?? [];
    const errors = raw.errors;
    const insertedIds = [];
    for (let i = 0, n = documentResponses.length; i < n; i++) {
        const docResp = documentResponses[i];
        if (docResp.status === "OK") {
            insertedIds.push(serdes.deserializeRecord(docResp._id, raw, true));
        }
        else if (docResp.errorIdx) {
            docResp.error = errors[docResp.errorIdx];
            delete docResp.errorIdx;
        }
    }
    return [documentResponses, insertedIds, err?.detailedErrorDescriptors[0]];
};
