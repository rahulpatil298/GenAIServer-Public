"use strict";
// Copyright Datastax, Inc
// SPDX-License-Identifier: Apache-2.0
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _FindCursor_instances, _FindCursor_parent, _FindCursor_serdes, _FindCursor_options, _FindCursor_filter, _FindCursor_mapping, _FindCursor_buffer, _FindCursor_nextPageState, _FindCursor_state, _FindCursor_sortVector, _FindCursor_consumed, _FindCursor_clone, _FindCursor_next, _FindCursor_getMore;
Object.defineProperty(exports, "__esModule", { value: true });
exports.FindCursor = exports.CursorError = void 0;
const utils_1 = require("../documents/utils");
const constants_1 = require("../lib/constants");
const errors_1 = require("../documents/errors");
const datatypes_1 = require("../documents/datatypes");
class CursorError extends errors_1.DataAPIError {
        constructor(message, cursor) {
        super(message);
                Object.defineProperty(this, "cursor", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
                Object.defineProperty(this, "state", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.name = 'CursorError';
        this.cursor = cursor;
        this.state = cursor.state;
    }
}
exports.CursorError = CursorError;
class FindCursor {
        constructor(parent, serdes, filter, options, mapping) {
        _FindCursor_instances.add(this);
        _FindCursor_parent.set(this, void 0);
        _FindCursor_serdes.set(this, void 0);
        _FindCursor_options.set(this, void 0);
        _FindCursor_filter.set(this, void 0);
        _FindCursor_mapping.set(this, void 0);
        _FindCursor_buffer.set(this, []);
        _FindCursor_nextPageState.set(this, void 0);
        _FindCursor_state.set(this, 'idle');
        _FindCursor_sortVector.set(this, void 0);
        _FindCursor_consumed.set(this, 0);
        __classPrivateFieldSet(this, _FindCursor_parent, parent, "f");
        __classPrivateFieldSet(this, _FindCursor_serdes, serdes, "f");
        __classPrivateFieldSet(this, _FindCursor_filter, filter, "f");
        __classPrivateFieldSet(this, _FindCursor_options, options ?? {}, "f");
        __classPrivateFieldSet(this, _FindCursor_mapping, mapping, "f");
        Object.defineProperty(this, constants_1.$CustomInspect, {
            value: () => `FindCursor(source="${__classPrivateFieldGet(this, _FindCursor_parent, "f").keyspace}.${__classPrivateFieldGet(this, _FindCursor_parent, "f").name}",state="${__classPrivateFieldGet(this, _FindCursor_state, "f")}",consumed=${__classPrivateFieldGet(this, _FindCursor_consumed, "f")},buffered=${__classPrivateFieldGet(this, _FindCursor_buffer, "f").length})`,
        });
    }
        get dataSource() {
        return __classPrivateFieldGet(this, _FindCursor_parent, "f");
    }
        get state() {
        return __classPrivateFieldGet(this, _FindCursor_state, "f");
    }
        buffered() {
        return __classPrivateFieldGet(this, _FindCursor_buffer, "f").length;
    }
        consumed() {
        return __classPrivateFieldGet(this, _FindCursor_consumed, "f");
    }
        consumeBuffer(max) {
        return __classPrivateFieldGet(this, _FindCursor_buffer, "f").splice(0, max ?? __classPrivateFieldGet(this, _FindCursor_buffer, "f").length);
    }
        filter(filter) {
        if (__classPrivateFieldGet(this, _FindCursor_state, "f") !== 'idle') {
            throw new CursorError('Cannot set a new filter on a running/closed cursor', this);
        }
        return __classPrivateFieldGet(this, _FindCursor_instances, "m", _FindCursor_clone).call(this, __classPrivateFieldGet(this, _FindCursor_serdes, "f").serializeRecord(structuredClone(filter)), __classPrivateFieldGet(this, _FindCursor_options, "f"), __classPrivateFieldGet(this, _FindCursor_mapping, "f"));
    }
        sort(sort) {
        if (__classPrivateFieldGet(this, _FindCursor_state, "f") !== 'idle') {
            throw new CursorError('Cannot set a new sort on a running/closed cursor', this);
        }
        const options = { ...__classPrivateFieldGet(this, _FindCursor_options, "f"), sort: (0, utils_1.normalizedSort)(sort) };
        return __classPrivateFieldGet(this, _FindCursor_instances, "m", _FindCursor_clone).call(this, __classPrivateFieldGet(this, _FindCursor_filter, "f"), options, __classPrivateFieldGet(this, _FindCursor_mapping, "f"));
    }
        limit(limit) {
        if (__classPrivateFieldGet(this, _FindCursor_state, "f") !== 'idle') {
            throw new CursorError('Cannot set a new limit on a running/closed cursor', this);
        }
        const options = { ...__classPrivateFieldGet(this, _FindCursor_options, "f"), limit: limit || Infinity };
        return __classPrivateFieldGet(this, _FindCursor_instances, "m", _FindCursor_clone).call(this, __classPrivateFieldGet(this, _FindCursor_filter, "f"), options, __classPrivateFieldGet(this, _FindCursor_mapping, "f"));
    }
        skip(skip) {
        if (__classPrivateFieldGet(this, _FindCursor_state, "f") !== 'idle') {
            throw new CursorError('Cannot set a new skip on a running/closed cursor', this);
        }
        const options = { ...__classPrivateFieldGet(this, _FindCursor_options, "f"), skip };
        return __classPrivateFieldGet(this, _FindCursor_instances, "m", _FindCursor_clone).call(this, __classPrivateFieldGet(this, _FindCursor_filter, "f"), options, __classPrivateFieldGet(this, _FindCursor_mapping, "f"));
    }
        project(projection) {
        if (__classPrivateFieldGet(this, _FindCursor_mapping, "f")) {
            throw new CursorError('Cannot set a projection after already using cursor.map(...)', this);
        }
        if (__classPrivateFieldGet(this, _FindCursor_state, "f") !== 'idle') {
            throw new CursorError('Cannot set a new projection on a running/closed cursor', this);
        }
        const options = { ...__classPrivateFieldGet(this, _FindCursor_options, "f"), projection: structuredClone(projection) };
        return __classPrivateFieldGet(this, _FindCursor_instances, "m", _FindCursor_clone).call(this, __classPrivateFieldGet(this, _FindCursor_filter, "f"), options, __classPrivateFieldGet(this, _FindCursor_mapping, "f"));
    }
        includeSimilarity(includeSimilarity) {
        if (__classPrivateFieldGet(this, _FindCursor_mapping, "f")) {
            throw new CursorError('Cannot set include similarity after already using cursor.map(...)', this);
        }
        if (__classPrivateFieldGet(this, _FindCursor_state, "f") !== 'idle') {
            throw new CursorError('Cannot set a new similarity on a running/closed cursor', this);
        }
        const options = { ...__classPrivateFieldGet(this, _FindCursor_options, "f"), includeSimilarity: includeSimilarity ?? true };
        return __classPrivateFieldGet(this, _FindCursor_instances, "m", _FindCursor_clone).call(this, __classPrivateFieldGet(this, _FindCursor_filter, "f"), options, __classPrivateFieldGet(this, _FindCursor_mapping, "f"));
    }
        includeSortVector(includeSortVector = true) {
        if (__classPrivateFieldGet(this, _FindCursor_state, "f") !== 'idle') {
            throw new CursorError('Cannot set a new sort vector on a running/closed cursor', this);
        }
        const options = { ...__classPrivateFieldGet(this, _FindCursor_options, "f"), includeSortVector };
        return __classPrivateFieldGet(this, _FindCursor_instances, "m", _FindCursor_clone).call(this, __classPrivateFieldGet(this, _FindCursor_filter, "f"), options, __classPrivateFieldGet(this, _FindCursor_mapping, "f"));
    }
        map(mapping) {
        if (__classPrivateFieldGet(this, _FindCursor_state, "f") !== 'idle') {
            throw new CursorError('Cannot set a new mapping on a running/closed cursor', this);
        }
        if (__classPrivateFieldGet(this, _FindCursor_mapping, "f")) {
            return __classPrivateFieldGet(this, _FindCursor_instances, "m", _FindCursor_clone).call(this, __classPrivateFieldGet(this, _FindCursor_filter, "f"), __classPrivateFieldGet(this, _FindCursor_options, "f"), (doc) => mapping(__classPrivateFieldGet(this, _FindCursor_mapping, "f")(doc)));
        }
        else {
            return __classPrivateFieldGet(this, _FindCursor_instances, "m", _FindCursor_clone).call(this, __classPrivateFieldGet(this, _FindCursor_filter, "f"), __classPrivateFieldGet(this, _FindCursor_options, "f"), mapping);
        }
    }
        clone() {
        return new this.constructor(__classPrivateFieldGet(this, _FindCursor_parent, "f"), __classPrivateFieldGet(this, _FindCursor_serdes, "f"), __classPrivateFieldGet(this, _FindCursor_filter, "f"), __classPrivateFieldGet(this, _FindCursor_options, "f"));
    }
        rewind() {
        __classPrivateFieldGet(this, _FindCursor_buffer, "f").length = 0;
        __classPrivateFieldSet(this, _FindCursor_nextPageState, undefined, "f");
        __classPrivateFieldSet(this, _FindCursor_state, 'idle', "f");
    }
        async next() {
        return __classPrivateFieldGet(this, _FindCursor_instances, "m", _FindCursor_next).call(this, false);
    }
        async hasNext() {
        const reset2idle = __classPrivateFieldGet(this, _FindCursor_state, "f") === 'idle';
        const res = await __classPrivateFieldGet(this, _FindCursor_instances, "m", _FindCursor_next).call(this, true) !== null;
        if (reset2idle) {
            __classPrivateFieldSet(this, _FindCursor_state, 'idle', "f");
        }
        return res;
    }
        async getSortVector() {
        if (!__classPrivateFieldGet(this, _FindCursor_options, "f").includeSortVector) {
            return __classPrivateFieldGet(this, _FindCursor_sortVector, "f") ?? null;
        }
        const reset2idle = __classPrivateFieldGet(this, _FindCursor_state, "f") === 'idle';
        if (__classPrivateFieldGet(this, _FindCursor_sortVector, "f") === undefined) {
            await this.hasNext();
        }
        if (reset2idle) {
            __classPrivateFieldSet(this, _FindCursor_state, 'idle', "f");
        }
        return __classPrivateFieldGet(this, _FindCursor_sortVector, "f") ?? null;
    }
        async *[(_FindCursor_parent = new WeakMap(), _FindCursor_serdes = new WeakMap(), _FindCursor_options = new WeakMap(), _FindCursor_filter = new WeakMap(), _FindCursor_mapping = new WeakMap(), _FindCursor_buffer = new WeakMap(), _FindCursor_nextPageState = new WeakMap(), _FindCursor_state = new WeakMap(), _FindCursor_sortVector = new WeakMap(), _FindCursor_consumed = new WeakMap(), _FindCursor_instances = new WeakSet(), Symbol.asyncIterator)]() {
        if (this.state === 'closed') {
            throw new CursorError('Cannot iterate over a closed cursor', this);
        }
        try {
            let doc;
            while ((doc = await __classPrivateFieldGet(this, _FindCursor_instances, "m", _FindCursor_next).call(this, false))) {
                yield doc;
            }
        }
        finally {
            this.close();
        }
    }
        async forEach(consumer) {
        if (this.state === 'closed') {
            throw new CursorError('Cannot iterate over a closed cursor', this);
        }
        for await (const doc of this) {
            if (consumer(doc) === false) {
                break;
            }
        }
    }
        async toArray() {
        if (this.state === 'closed') {
            throw new CursorError('Cannot convert a closed cursor to an array', this);
        }
        const docs = [];
        const tm = __classPrivateFieldGet(this, _FindCursor_parent, "f")._httpClient.tm.multipart('generalMethodTimeoutMs', __classPrivateFieldGet(this, _FindCursor_options, "f"));
        try {
            let doc;
            while ((doc = await __classPrivateFieldGet(this, _FindCursor_instances, "m", _FindCursor_next).call(this, false, tm))) {
                docs.push(doc);
            }
        }
        finally {
            this.close();
        }
        return docs;
    }
        close() {
        __classPrivateFieldSet(this, _FindCursor_state, 'closed', "f");
        __classPrivateFieldGet(this, _FindCursor_buffer, "f").length = 0;
    }
}
exports.FindCursor = FindCursor;
_FindCursor_clone = function _FindCursor_clone(filter, options, mapping) {
    return new this.constructor(__classPrivateFieldGet(this, _FindCursor_parent, "f"), __classPrivateFieldGet(this, _FindCursor_serdes, "f"), filter, options, mapping);
}, _FindCursor_next = async function _FindCursor_next(peek, tm) {
    var _a;
    if (__classPrivateFieldGet(this, _FindCursor_state, "f") === 'closed') {
        return null;
    }
    __classPrivateFieldSet(this, _FindCursor_state, 'started', "f");
    try {
        while (__classPrivateFieldGet(this, _FindCursor_buffer, "f").length === 0) {
            if (__classPrivateFieldGet(this, _FindCursor_nextPageState, "f") === null) {
                this.close();
                return null;
            }
            await __classPrivateFieldGet(this, _FindCursor_instances, "m", _FindCursor_getMore).call(this, tm);
        }
        if (peek) {
            return __classPrivateFieldGet(this, _FindCursor_buffer, "f").at(-1);
        }
        const doc = __classPrivateFieldGet(this, _FindCursor_buffer, "f").shift();
        if (doc)
            __classPrivateFieldSet(this, _FindCursor_consumed, (_a = __classPrivateFieldGet(this, _FindCursor_consumed, "f"), _a++, _a), "f");
        return (doc && __classPrivateFieldGet(this, _FindCursor_mapping, "f"))
            ? __classPrivateFieldGet(this, _FindCursor_mapping, "f").call(this, doc)
            : doc;
    }
    catch (e) {
        this.close();
        throw e;
    }
}, _FindCursor_getMore = async function _FindCursor_getMore(tm) {
    const command = {
        find: {
            filter: __classPrivateFieldGet(this, _FindCursor_filter, "f")[0],
            projection: __classPrivateFieldGet(this, _FindCursor_options, "f").projection,
            sort: __classPrivateFieldGet(this, _FindCursor_options, "f").sort,
            options: {
                includeSimilarity: __classPrivateFieldGet(this, _FindCursor_options, "f").includeSimilarity,
                includeSortVector: __classPrivateFieldGet(this, _FindCursor_options, "f").includeSortVector,
                limit: __classPrivateFieldGet(this, _FindCursor_options, "f").limit,
                skip: __classPrivateFieldGet(this, _FindCursor_options, "f").skip,
                pageState: __classPrivateFieldGet(this, _FindCursor_nextPageState, "f") ?? undefined,
            },
        },
    };
    const raw = await __classPrivateFieldGet(this, _FindCursor_parent, "f")._httpClient.executeCommand(command, {
        timeoutManager: tm ?? __classPrivateFieldGet(this, _FindCursor_parent, "f")._httpClient.tm.single('generalMethodTimeoutMs', __classPrivateFieldGet(this, _FindCursor_options, "f")),
        bigNumsPresent: __classPrivateFieldGet(this, _FindCursor_filter, "f")[1],
    });
    __classPrivateFieldSet(this, _FindCursor_nextPageState, raw.data?.nextPageState || null, "f");
    __classPrivateFieldSet(this, _FindCursor_buffer, raw.data?.documents ?? [], "f");
    for (let i = 0, n = __classPrivateFieldGet(this, _FindCursor_buffer, "f").length; i < n; i++) {
        __classPrivateFieldGet(this, _FindCursor_buffer, "f")[i] = __classPrivateFieldGet(this, _FindCursor_serdes, "f").deserializeRecord(__classPrivateFieldGet(this, _FindCursor_buffer, "f")[i], raw);
    }
    const sortVector = raw.status?.sortVector;
    __classPrivateFieldSet(this, _FindCursor_sortVector, __classPrivateFieldGet(this, _FindCursor_sortVector, "f") ?? sortVector ? (0, datatypes_1.vector)(sortVector) : sortVector, "f");
    __classPrivateFieldGet(this, _FindCursor_options, "f").includeSortVector = false;
};
