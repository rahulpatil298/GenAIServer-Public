"use strict";
// Copyright Datastax, Inc
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.mkRespErrorFromResponses = exports.mkRespErrorFromResponse = exports.CollectionUpdateManyError = exports.CollectionDeleteManyError = exports.TableInsertManyError = exports.CollectionInsertManyError = exports.CumulativeOperationError = exports.DataAPIResponseError = exports.TooManyRowsToCountError = exports.TooManyDocumentsToCountError = exports.DataAPITimeoutError = exports.DataAPIHttpError = exports.DataAPIError = void 0;
const timeouts_1 = require("../lib/api/timeouts");
class DataAPIError extends Error {
}
exports.DataAPIError = DataAPIError;
class DataAPIHttpError extends DataAPIError {
        constructor(resp) {
        super(`HTTP error (${resp.status}): ${resp.body ? resp.body : resp.statusText}`);
                Object.defineProperty(this, "status", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
                Object.defineProperty(this, "body", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
                Object.defineProperty(this, "raw", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.status = resp.status;
        this.body = resp.body;
        this.raw = resp;
        this.name = 'DataAPIHttpError';
    }
}
exports.DataAPIHttpError = DataAPIHttpError;
class DataAPITimeoutError extends DataAPIError {
        constructor(info, types) {
        super(timeouts_1.Timeouts.fmtTimeoutMsg(info.timeoutManager, types));
                Object.defineProperty(this, "timeout", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "timedOutTypes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.timeout = info.timeoutManager.initial();
        this.timedOutTypes = types;
        this.name = 'DataAPITimeoutError';
    }
    static mk(info, types) {
        return new DataAPITimeoutError(info, types);
    }
}
exports.DataAPITimeoutError = DataAPITimeoutError;
class TooManyDocumentsToCountError extends DataAPIError {
        constructor(limit, hitServerLimit) {
        const message = (hitServerLimit)
            ? `Too many documents to count (server limit of ${limit} reached)`
            : `Too many documents to count (provided limit is ${limit})`;
        super(message);
                Object.defineProperty(this, "limit", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
                Object.defineProperty(this, "hitServerLimit", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.limit = limit;
        this.hitServerLimit = hitServerLimit;
        this.name = 'TooManyDocumentsToCountError';
    }
}
exports.TooManyDocumentsToCountError = TooManyDocumentsToCountError;
class TooManyRowsToCountError extends DataAPIError {
        constructor(limit, hitServerLimit) {
        const message = (hitServerLimit)
            ? `Too many rows to count (server limit of ${limit} reached)`
            : `Too many rows to count (provided limit is ${limit})`;
        super(message);
                Object.defineProperty(this, "limit", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
                Object.defineProperty(this, "hitServerLimit", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.limit = limit;
        this.hitServerLimit = hitServerLimit;
        this.name = 'TooManyRowsToCountError';
    }
}
exports.TooManyRowsToCountError = TooManyRowsToCountError;
class DataAPIResponseError extends DataAPIError {
        constructor(detailedErrDescriptors) {
        const errorDescriptors = detailedErrDescriptors.flatMap(d => d.errorDescriptors);
        const message = (errorDescriptors[0]?.message)
            ? `${errorDescriptors[0].message}${errorDescriptors.length > 1 ? ` (+ ${errorDescriptors.length - 1} more errors)` : ''}`
            : `Something went wrong (${errorDescriptors.length} errors)`;
        super(message);
                Object.defineProperty(this, "message", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
                Object.defineProperty(this, "errorDescriptors", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
                Object.defineProperty(this, "detailedErrorDescriptors", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.message = message;
        this.errorDescriptors = errorDescriptors;
        this.detailedErrorDescriptors = detailedErrDescriptors;
        this.name = 'DataAPIResponseError';
    }
}
exports.DataAPIResponseError = DataAPIResponseError;
class CumulativeOperationError extends DataAPIResponseError {
    constructor() {
        super(...arguments);
                Object.defineProperty(this, "partialResult", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
}
exports.CumulativeOperationError = CumulativeOperationError;
class CollectionInsertManyError extends CumulativeOperationError {
    constructor() {
        super(...arguments);
                Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'CollectionInsertManyError'
        });
        //
        //         // declare public readonly documentResponses: InsertManyDocumentResponse<SomeDoc>[];
        //
        //         // declare public readonly failedCount: number;
    }
}
exports.CollectionInsertManyError = CollectionInsertManyError;
class TableInsertManyError extends CumulativeOperationError {
    constructor() {
        super(...arguments);
                Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'TableInsertManyError'
        });
    }
}
exports.TableInsertManyError = TableInsertManyError;
class CollectionDeleteManyError extends CumulativeOperationError {
    constructor() {
        super(...arguments);
                Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'CollectionDeleteManyError'
        });
    }
}
exports.CollectionDeleteManyError = CollectionDeleteManyError;
class CollectionUpdateManyError extends CumulativeOperationError {
    constructor() {
        super(...arguments);
                Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'CollectionUpdateManyError'
        });
    }
}
exports.CollectionUpdateManyError = CollectionUpdateManyError;
const mkRespErrorFromResponse = (err, command, raw, attributes) => {
    return (0, exports.mkRespErrorFromResponses)(err, [command], [raw], attributes);
};
exports.mkRespErrorFromResponse = mkRespErrorFromResponse;
const mkRespErrorFromResponses = (err, commands, raw, attributes) => {
    const detailedErrDescriptors = [];
    for (let i = 0, n = commands.length; i < n; i++) {
        const command = commands[i], response = raw[i];
        if (response.errors) {
            const descriptors = response.errors.map((error) => {
                const attributes = { ...error };
                delete attributes.message;
                delete attributes.errorCode;
                return { errorCode: error.errorCode, message: error.message, attributes };
            });
            const detailedErrDescriptor = { errorDescriptors: descriptors, command, rawResponse: response };
            detailedErrDescriptors.push(detailedErrDescriptor);
        }
    }
    const instance = new err(detailedErrDescriptors);
    Object.assign(instance, attributes ?? {});
    return instance;
};
exports.mkRespErrorFromResponses = mkRespErrorFromResponses;
