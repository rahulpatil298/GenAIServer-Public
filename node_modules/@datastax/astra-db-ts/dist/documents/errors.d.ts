import { FetcherResponseInfo, RawDataAPIResponse, TimeoutDescriptor } from '../lib';
import type { CollectionDeleteManyResult, CollectionInsertManyResult, CollectionUpdateManyResult, SomeDoc } from '../documents/collections';
import type { TableInsertManyResult } from '../documents/tables';
import { HTTPRequestInfo } from '../lib/api/clients';
import { TimedOutCategories } from '../lib/api/timeouts';
/**
 * An object representing a single "soft" (2XX) error returned from the Data API, typically with an error code and a
 * human-readable message. An API request may return with an HTTP 200 success error code, but contain a nonzero
 * amount of these, such as for duplicate inserts, or invalid IDs.
 *
 * This is *not* used for "hard" (4XX, 5XX) errors, which are rarer and would be thrown directly by the underlying
 * code.
 *
 * @example
 * ```typescript
 * {
 *   errorCode: 'DOCUMENT_ALREADY_EXISTS',
 *   message: "Failed to insert document with _id 'id3': Document already exists with the given _id",
 *   attributes: {},
 * }
 * ```
 *
 * @field errorCode - A string code representing the exact error
 * @field message - A human-readable message describing the error
 * @field attributes - A map of additional attributes returned by the API. Often empty
 *
 * @public
 */
export interface DataAPIErrorDescriptor {
    /**
     * A string code representing the exact error
     */
    readonly errorCode?: string;
    /**
     * A human-readable message describing the error
     */
    readonly message?: string;
    /**
     * A map of additional attributes that may be useful for debugging or logging returned by the API. Not guaranteed to
     * be non-empty. Probably more often empty than not.
     */
    readonly attributes?: Record<string, any>;
}
/**
 * An object representing a *complete* error response from the Data API, including the original command that was sent,
 * and the raw API response from the server.
 *
 * This is *not* used for "hard" (4XX, 5XX) errors, which are rarer and would be thrown directly by the underlying
 * code.
 *
 * @field errorDescriptors - A list of error descriptors representing the individual errors returned by the API
 * @field command - The raw command send to the API
 * @field rawResponse - The raw response from the API
 *
 * @public
 */
export interface DataAPIDetailedErrorDescriptor {
    /**
     * A list of error descriptors representing the individual errors returned by the API.
     *
     * This will likely be a singleton list in many cases, such as for `insertOne` or `deleteOne` commands, but may be
     * longer for bulk operations like `insertMany` which may have multiple insertion errors.
     */
    readonly errorDescriptors: DataAPIErrorDescriptor[];
    /**
     * The original command that was sent to the API, as a plain object. This is the *raw* command, not necessarily in
     * the exact format the client may use, in some rare cases.
     *
     * @example
     * ```typescript
     * {
     *   insertOne: {
     *     document: { _id: 'docml10', name: 'Document 10' },
     *   }
     * }
     * ```
     */
    readonly command: Record<string, any>;
    /**
     * The raw response from the API
     *
     * @example
     * ```typescript
     * {
     *   status: {
     *     insertedIds: [ 'id1', 'id2', 'id3']
     *   },
     *   data: undefined,
     *   errors: [
     *     {
     *       message: "Failed to insert document with _id 'id3': Document already exists with the given _id",
     *       errorCode: 'DOCUMENT_ALREADY_EXISTS'
     *     }
     *   ]
     * }
     * ```
     */
    readonly rawResponse: RawDataAPIResponse;
}
/**
 * An abstract class representing *some* exception that occurred related to the Data API. This is the base class for all
 * Data API errors, and will never be thrown directly.
 *
 * Useful for `instanceof` checks.
 *
 * This is *only* for Data API related errors, such as a non-existent collections, or a duplicate key error. It
 * is *not*, however, for errors such as an HTTP network error, or a malformed request. The exception being timeouts,
 * which are represented by the {@link DataAPITimeoutError} class.
 *
 * @public
 */
export declare abstract class DataAPIError extends Error {
}
/**
 * An error thrown on non-2XX status codes from the Data API, such as 4XX or 5XX errors.
 *
 * @public
 */
export declare class DataAPIHttpError extends DataAPIError {
    /**
     * The error descriptors returned by the API to describe what went wrong.
     */
    readonly status: number;
    /**
     * The raw string body of the HTTP response, if it exists
     */
    readonly body?: string;
    /**
     * The "raw", errored response from the API.
     */
    readonly raw: FetcherResponseInfo;
    /**
     * Should not be instantiated by the user.
     *
     * @internal
     */
    constructor(resp: FetcherResponseInfo);
}
/**
 * An error thrown when a Data API operation timed out.
 *
 * Depending on the method, this may be a request timeout occurring during a specific HTTP request, or can happen over
 * the course of a method involving several requests in a row, such as a paginated `insertMany`.
 *
 * @public
 */
export declare class DataAPITimeoutError extends DataAPIError {
    /**
     * The timeout that was set for the operation, in milliseconds.
     */
    readonly timeout: Partial<TimeoutDescriptor>;
    readonly timedOutTypes: TimedOutCategories;
    /**
     * Should not be instantiated by the user.
     *
     * @internal
     */
    constructor(info: HTTPRequestInfo, types: TimedOutCategories);
    static mk(info: HTTPRequestInfo, types: TimedOutCategories): DataAPITimeoutError;
}
/**
 * Caused by a `countDocuments` operation that failed because the resulting number of documents exceeded *either*
 * the upper bound set by the caller, or the hard limit imposed by the Data API.
 *
 * @example
 * ```typescript
 * await collections.insertMany('<100_length_array>');
 *
 * try {
 *   await collections.countDocuments({}, 50);
 * } catch (e) {
 *   if (e instanceof TooManyDocumentsToCountError) {
 *     console.log(e.limit); // 50
 *     console.log(e.hitServerLimit); // false
 *   }
 * }
 * ```
 *
 * @field limit - The limit that was set by the caller
 * @field hitServerLimit - Whether the server-imposed limit was hit
 *
 * @public
 */
export declare class TooManyDocumentsToCountError extends DataAPIError {
    /**
     * The limit that was specified by the caller, or the server-imposed limit if the caller's limit was too high.
     */
    readonly limit: number;
    /**
     * Specifies if the server-imposed limit was hit. If this is `true`, the `limit` field will contain the server's
     * limit; otherwise it will contain the caller's limit.
     */
    readonly hitServerLimit: boolean;
    /**
     * Should not be instantiated by the user.
     *
     * @internal
     */
    constructor(limit: number, hitServerLimit: boolean);
}
/**
 * Caused by a `countRows` operation that failed because the resulting number of documents exceeded *either*
 * the upper bound set by the caller, or the hard limit imposed by the Data API.
 *
 * @example
 * ```typescript
 * await table.insertMany('<100_length_array>');
 *
 * try {
 *   await table.countRows({}, 50);
 * } catch (e) {
 *   if (e instanceof TooManyRowsToCountError) {
 *     console.log(e.limit); // 50
 *     console.log(e.hitServerLimit); // false
 *   }
 * }
 * ```
 *
 * @field limit - The limit that was set by the caller
 * @field hitServerLimit - Whether the server-imposed limit was hit
 *
 * @public
 */
export declare class TooManyRowsToCountError extends DataAPIError {
    /**
     * The limit that was specified by the caller, or the server-imposed limit if the caller's limit was too high.
     */
    readonly limit: number;
    /**
     * Specifies if the server-imposed limit was hit. If this is `true`, the `limit` field will contain the server's
     * limit; otherwise it will contain the caller's limit.
     */
    readonly hitServerLimit: boolean;
    /**
     * Should not be instantiated by the user.
     *
     * @internal
     */
    constructor(limit: number, hitServerLimit: boolean);
}
/**
 * An error representing the *complete* errors for an operation. This is a cohesive error that represents all the
 * errors that occurred during a single operation, and should not be thought of as *always* 1:1 with the number of
 * API requests—rather it's 1:1 with the number of *logical* operations performed by the user (i.e. the methods
 * on the {@link Collection} class).
 *
 * This is *not* used for "hard" (4XX, 5XX) errors, which are rarer and would be thrown directly by the underlying
 * code.
 *
 * @field message - A human-readable message describing the *first* error
 * @field errorDescriptors - A list of error descriptors representing the individual errors returned by the API
 * @field detailedErrorDescriptors - A list of errors 1:1 with the number of errorful API requests made to the server.
 *
 * @public
 */
export declare class DataAPIResponseError extends DataAPIError {
    /**
     * A human-readable message describing the *first* error.
     *
     * This is *always* equal to `errorDescriptors[0]?.message` if it exists, otherwise it's given a generic
     * default message.
     */
    readonly message: string;
    /**
     * A list of error descriptors representing the individual errors returned by the API.
     *
     * This is *always* equal to `detailedErrorDescriptors.flatMap(d => d.errorDescriptors)`, for the user's
     * convenience.
     */
    readonly errorDescriptors: DataAPIErrorDescriptor[];
    /**
     * A list of errors 1:1 with the number of errorful API requests made to the server. Each element contains the
     * original command, the raw response, and the error descriptors for that request.
     *
     * For operations that only make one request, this will be a singleton list (i.e. `insertOne`).
     */
    readonly detailedErrorDescriptors: DataAPIDetailedErrorDescriptor[];
    /**
     * Should not be instantiated by the user.
     *
     * @internal
     */
    constructor(detailedErrDescriptors: DataAPIDetailedErrorDescriptor[]);
}
/**
 * An abstract class representing an exception that occurred due to a *cumulative* operation on the Data API. This is
 * the base class for all Data API errors that represent a paginated operation, such as `insertMany`, `deleteMany`, and
 * `updateMany`, and will never be thrown directly.
 *
 * Useful for `instanceof` checks.
 *
 * This is *only* for Data API related errors, such as a non-existent collections, or a duplicate key error. It
 * is *not*, however, for errors such as an HTTP network error, or a malformed request. The exception being timeouts,
 * which are represented by the {@link DataAPITimeoutError} class.
 *
 * @field message - A human-readable message describing the *first* error
 * @field errorDescriptors - A list of error descriptors representing the individual errors returned by the API
 * @field detailedErrorDescriptors - A list of errors 1:1 with the number of errorful API requests made to the server.
 * @field partialResult - The partial result of the operation that was performed
 *
 * @public
 */
export declare abstract class CumulativeOperationError extends DataAPIResponseError {
    /**
     * The partial result of the operation that was performed. This is *always* defined, and is
     * the result of the operation up to the point of the first error. For example, if you're inserting 100 documents
     * ordered and the 50th document fails, the `partialResult` will contain the first 49 documents that were
     * successfully inserted.
     */
    readonly partialResult: unknown;
}
/**
 * ##### Overview
 *
 * Represents an error that occurred during an `insertMany` operation (which may be paginated).
 *
 * Contains the inserted IDs of the documents that were successfully inserted, as well as the cumulative errors
 * that occurred during the operation.
 *
 * If the operation was ordered, the `insertedIds` will be in the same order as the documents that were attempted to
 * be inserted.
 *
 * @example
 * ```ts
 * try {
 *   await collection.insertMany([
 *     { _id: 'id1', desc: 'An innocent little document' },
 *     { _id: 'id2', name: 'Another little document minding its own business' },
 *     { _id: 'id2', name: 'A mean document commiting _identity theft' },
 *     { _id: 'id3', name: 'A document that will never see the light of day-tabase' },
 *   ], { ordered: true });
 * } catch (e) {
 *   if (e instanceof CollectionInsertManyError) {
 *     console.log(e.message); // "Document already exists with the given _id"
 *     console.log(e.partialResult.insertedIds); // ['id1', 'id2']
 *   }
 * }
 * ```
 *
 * ##### Collections vs Tables
 *
 * There is a sister {@link TableInsertManyError} class that is used for `insertMany` operations on tables. It's
 * identical in structure, but just uses the appropriate {@link TableInsertManyResult} type.
 *
 * @field message - A human-readable message describing the *first* error
 * @field errorDescriptors - A list of error descriptors representing the individual errors returned by the API
 * @field detailedErrorDescriptors - A list of errors 1:1 with the number of errorful API requests made to the server.
 * @field partialResult - The partial result of the `InsertMany` operation that was performed
 *
 * @public
 */
export declare class CollectionInsertManyError extends CumulativeOperationError {
    /**
     * The name of the error. This is always 'InsertManyError'.
     */
    name: string;
    /**
     * The partial result of the `InsertMany` operation that was performed. This is *always* defined, and is the result
     * of all successful insertions.
     */
    readonly partialResult: CollectionInsertManyResult<SomeDoc>;
}
/**
 * Represents an error that occurred during an `insertMany` operation (which is, generally, paginated).
 *
 * Contains the inserted IDs of the documents that were successfully inserted, as well as the cumulative errors
 * that occurred during the operation.
 *
 * If the operation was ordered, the `insertedIds` will be in the same order as the documents that were attempted to
 * be inserted.
 *
 * @field message - A human-readable message describing the *first* error
 * @field errorDescriptors - A list of error descriptors representing the individual errors returned by the API
 * @field detailedErrorDescriptors - A list of errors 1:1 with the number of errorful API requests made to the server.
 * @field partialResult - The partial result of the `InsertMany` operation that was performed
 *
 * @public
 */
export declare class TableInsertManyError extends CumulativeOperationError {
    /**
     * The name of the error. This is always 'InsertManyError'.
     */
    name: string;
    /**
     * The partial result of the `InsertMany` operation that was performed. This is *always* defined, and is the result
     * of all successful insertions.
     */
    readonly partialResult: TableInsertManyResult<SomeDoc>;
}
/**
 * Represents an error that occurred during a `deleteMany` operation (which is, generally, paginated).
 *
 * Contains the number of documents that were successfully deleted, as well as the cumulative errors that occurred
 * during the operation.
 *
 * @field message - A human-readable message describing the *first* error
 * @field errorDescriptors - A list of error descriptors representing the individual errors returned by the API
 * @field detailedErrorDescriptors - A list of errors 1:1 with the number of errorful API requests made to the server.
 * @field partialResult - The partial result of the `DeleteMany` operation that was performed
 *
 * @public
 */
export declare class CollectionDeleteManyError extends CumulativeOperationError {
    /**
     * The name of the error. This is always 'DeleteManyError'.
     */
    name: string;
    /**
     * The partial result of the `DeleteMany` operation that was performed. This is *always* defined, and is the result
     * of the operation up to the point of the first error.
     */
    readonly partialResult: CollectionDeleteManyResult;
}
/**
 * Represents an error that occurred during an `updateMany` operation (which is, generally, paginated).
 *
 * Contains the number of documents that were successfully matched and/or modified, as well as the cumulative errors
 * that occurred during the operation.
 *
 * @field message - A human-readable message describing the *first* error
 * @field errorDescriptors - A list of error descriptors representing the individual errors returned by the API
 * @field detailedErrorDescriptors - A list of errors 1:1 with the number of errorful API requests made to the server.
 * @field partialResult - The partial result of the `UpdateMany` operation that was performed
 *
 * @public
 */
export declare class CollectionUpdateManyError extends CumulativeOperationError {
    /**
     * The name of the error. This is always 'UpdateManyError'.
     */
    name: string;
    /**
     * The partial result of the `UpdateMany` operation that was performed. This is *always* defined, and is the result
     * of the operation up to the point of the first error.
     */
    readonly partialResult: CollectionUpdateManyResult<SomeDoc>;
}
/**
 * @internal
 */
export declare const mkRespErrorFromResponse: <E extends DataAPIResponseError>(err: new (descs: DataAPIDetailedErrorDescriptor[]) => E, command: Record<string, any>, raw: RawDataAPIResponse, attributes?: Omit<E, keyof DataAPIResponseError>) => E;
/**
 * @internal
 */
export declare const mkRespErrorFromResponses: <E extends DataAPIResponseError>(err: new (descs: DataAPIDetailedErrorDescriptor[]) => E, commands: Record<string, any>[], raw: RawDataAPIResponse[], attributes?: Omit<E, keyof DataAPIResponseError>) => E;
