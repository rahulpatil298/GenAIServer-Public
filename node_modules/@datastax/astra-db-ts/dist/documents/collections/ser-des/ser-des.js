"use strict";
// Copyright Datastax, Inc
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.CollectionSerDes = void 0;
const ser_des_1 = require("../../../lib/api/ser-des/ser-des");
const ctx_1 = require("../../../lib/api/ser-des/ctx");
const codecs_1 = require("../../../documents/collections/ser-des/codecs");
const constants_1 = require("../../../documents/collections/ser-des/constants");
const utils_1 = require("../../../lib/utils");
class CollectionSerDes extends ser_des_1.SerDes {
    constructor(cfg) {
        super(CollectionSerDes.mergeConfig(DefaultCollectionSerDesCfg, cfg));
    }
    adaptSerCtx(ctx) {
        return ctx;
    }
    adaptDesCtx(ctx) {
        return ctx;
    }
    bigNumsPresent() {
        return this._cfg?.enableBigNumbers === true;
    }
    static mergeConfig(...cfg) {
        return {
            enableBigNumbers: cfg.reduce((acc, c) => c?.enableBigNumbers ?? acc, undefined),
            ...super._mergeConfig(...cfg),
        };
    }
}
exports.CollectionSerDes = CollectionSerDes;
const DefaultCollectionSerDesCfg = {
    serialize(key, value, ctx) {
        const codecs = ctx.codecs;
        let resp;
        for (let i = 0, n = codecs.path.length; i < n; i++) {
            const path = codecs.path[i].path;
            if ((0, utils_1.stringArraysEqual)(path, ctx.path)) {
                if ((resp = codecs.path[i].serialize?.(key, value, ctx) ?? ctx.continue())[0] !== ctx_1.CONTINUE) {
                    return resp;
                }
            }
        }
        if (key in codecs.name) {
            if ((resp = codecs.name[key].serialize?.(key, value, ctx) ?? ctx.continue())[0] !== ctx_1.CONTINUE) {
                return resp;
            }
        }
        if (typeof value === 'object' && value !== null) {
            if (value[constants_1.$SerializeForCollection]) {
                if ((resp = value[constants_1.$SerializeForCollection](ctx))[0] !== ctx_1.CONTINUE) {
                    return resp;
                }
            }
            for (const codec of codecs.classGuard) {
                if (value instanceof codec.serializeClass) {
                    if ((resp = codec.serialize(key, value, ctx))[0] !== ctx_1.CONTINUE) {
                        return resp;
                    }
                }
            }
        }
        for (const codec of codecs.customGuard) {
            if (codec.serializeGuard(value, ctx)) {
                if ((resp = codec.serialize(key, value, ctx))[0] !== ctx_1.CONTINUE) {
                    return resp;
                }
            }
        }
        return ctx.continue();
    },
    deserialize(key, value, ctx) {
        const codecs = ctx.codecs;
        let resp;
        for (let i = 0, n = codecs.path.length; i < n; i++) {
            const path = codecs.path[i].path;
            if ((0, utils_1.stringArraysEqual)(path, ctx.path)) {
                if ((resp = codecs.path[i].deserialize?.(key, value, ctx) ?? ctx.continue())[0] !== ctx_1.CONTINUE) {
                    return resp;
                }
            }
        }
        if (key in codecs.name) {
            if ((resp = codecs.name[key].deserialize(key, value, ctx))[0] !== ctx_1.CONTINUE) {
                return resp;
            }
        }
        if (ctx.keys?.length === 1 && (ctx.keys[0] in codecs.type)) {
            if ((resp = codecs.type[ctx.keys[0]].deserialize?.(key, value, ctx) ?? ctx.continue())[0] !== ctx_1.CONTINUE) {
                return resp;
            }
        }
        return ctx.continue();
    },
    codecs: Object.values(codecs_1.CollCodecs.Defaults),
};
