"use strict";
// Copyright Datastax, Inc
// SPDX-License-Identifier: Apache-2.0
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TableCodecs = void 0;
// Important to import from specific paths here to avoid circular dependencies
const blob_1 = require("../../../documents/datatypes/blob");
const dates_1 = require("../../../documents/datatypes/dates");
const inet_address_1 = require("../../../documents/datatypes/inet-address");
const uuid_1 = require("../../../documents/datatypes/uuid");
const vector_1 = require("../../../documents/datatypes/vector");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const constants_1 = require("../../../documents/tables/ser-des/constants");
class TableCodecs {
        constructor(state) {
                Object.defineProperty(this, "get", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.get = state;
    }
    static forPath(path, clazzOrOpts) {
        if (constants_1.$DeserializeForTable in clazzOrOpts) {
            return new TableCodecs({ codecType: 'path', path, deserialize: clazzOrOpts[constants_1.$DeserializeForTable] });
        }
        return new TableCodecs({ codecType: 'path', path, ...clazzOrOpts });
    }
    static forName(name, clazzOrOpts) {
        if (constants_1.$DeserializeForTable in clazzOrOpts) {
            return new TableCodecs({ codecType: 'name', name, deserialize: clazzOrOpts[constants_1.$DeserializeForTable] });
        }
        return new TableCodecs({ codecType: 'name', name, ...clazzOrOpts });
    }
    static forType(type, clazzOrOpts) {
        if (constants_1.$DeserializeForTable in clazzOrOpts) {
            return new TableCodecs({ codecType: 'type', type, deserialize: clazzOrOpts[constants_1.$DeserializeForTable] });
        }
        return new TableCodecs({ codecType: 'type', type, ...clazzOrOpts });
    }
}
exports.TableCodecs = TableCodecs;
Object.defineProperty(TableCodecs, "Defaults", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: {
        bigint: TableCodecs.forType('bigint', {
            deserializeOnly: true,
            deserialize: (value, ctx) => ctx.done(parseInt(value)),
        }),
        blob: TableCodecs.forType('blob', blob_1.DataAPIBlob),
        date: TableCodecs.forType('date', dates_1.DataAPIDate),
        decimal: TableCodecs.forType('decimal', {
            deserializeOnly: true,
            deserialize: (value, ctx) => ctx.done((value instanceof bignumber_js_1.default) ? value : new bignumber_js_1.default(value)),
        }),
        double: TableCodecs.forType('double', {
            deserializeOnly: true,
            deserialize: (value, ctx) => ctx.done(parseFloat(value)),
        }),
        duration: TableCodecs.forType('duration', dates_1.DataAPIDuration),
        float: TableCodecs.forType('float', {
            deserializeOnly: true,
            deserialize: (value, ctx) => ctx.done(parseFloat(value)),
        }),
        int: TableCodecs.forType('int', {
            deserializeOnly: true,
            deserialize: (value, ctx) => ctx.done(parseInt(value)),
        }),
        inet: TableCodecs.forType('inet', inet_address_1.InetAddress),
        smallint: TableCodecs.forType('smallint', {
            deserializeOnly: true,
            deserialize: (value, ctx) => ctx.done(parseInt(value)),
        }),
        time: TableCodecs.forType('time', dates_1.DataAPITime),
        timestamp: TableCodecs.forType('timestamp', dates_1.DataAPITimestamp),
        timeuuid: TableCodecs.forType('timeuuid', uuid_1.UUID),
        tinyint: TableCodecs.forType('tinyint', {
            deserializeOnly: true,
            deserialize: (value, ctx) => ctx.done(parseInt(value)),
        }),
        uuid: TableCodecs.forType('uuid', uuid_1.UUID),
        vector: TableCodecs.forType('vector', vector_1.DataAPIVector),
        varint: TableCodecs.forType('varint', {
            deserializeOnly: true,
            deserialize: (value, ctx) => ctx.done(BigInt(value)),
        }),
        map: TableCodecs.forType('map', {
            serializeClass: Map,
            serialize: (_, value, ctx) => {
                return ctx.recurse(Object.fromEntries(value));
            },
            deserialize(map, ctx, def) {
                const entries = Array.isArray(map) ? map : Object.entries(map);
                for (let i = 0, n = entries.length; i < n; i++) {
                    const [key, value] = entries[i];
                    const keyParser = ctx.codecs.type[def.keyType];
                    const valueParser = ctx.codecs.type[def.valueType];
                    entries[i] = [
                        keyParser ? keyParser.deserialize(key, ctx, def)[1] : key,
                        valueParser ? valueParser.deserialize(value, ctx, def)[1] : value,
                    ];
                }
                return ctx.done(new Map(entries));
            },
        }),
        list: TableCodecs.forType('list', {
            deserializeOnly: true,
            deserialize(list, ctx, def) {
                for (let i = 0, n = list.length; i < n; i++) {
                    const elemParser = ctx.codecs.type[def.valueType];
                    list[i] = elemParser ? elemParser.deserialize(list[i], ctx, def)[1] : list[i];
                }
                return ctx.done(list);
            },
        }),
        set: TableCodecs.forType('set', {
            serializeClass: Set,
            serialize: (_, value, ctx) => {
                return ctx.recurse([...value]);
            },
            deserialize(list, ctx, def) {
                for (let i = 0, n = list.length; i < n; i++) {
                    const elemParser = ctx.codecs.type[def.valueType];
                    list[i] = elemParser ? elemParser.deserialize(list[i], ctx, def)[1] : list[i];
                }
                return ctx.done(new Set(list));
            },
        }),
    }
});
Object.defineProperty(TableCodecs, "Overrides", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: {}
});
