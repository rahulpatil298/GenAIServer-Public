"use strict";
// Copyright Datastax, Inc
// SPDX-License-Identifier: Apache-2.0
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TableSerDes = void 0;
const ser_des_1 = require("../../../lib/api/ser-des/ser-des");
const codecs_1 = require("../../../documents/tables/ser-des/codecs");
const ctx_1 = require("../../../lib/api/ser-des/ctx");
const constants_1 = require("../../../documents/tables/ser-des/constants");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const utils_1 = require("../../../lib/utils");
class TableSerDes extends ser_des_1.SerDes {
    constructor(cfg) {
        super(TableSerDes.mergeConfig(DefaultTableSerDesCfg, cfg));
    }
    adaptSerCtx(ctx) {
        ctx.bigNumsPresent = false;
        return ctx;
    }
    adaptDesCtx(ctx) {
        const status = ctx.rawDataApiResp.status;
        if (ctx.parsingInsertedId) {
            ctx.tableSchema = status.primaryKeySchema;
        }
        else {
            ctx.tableSchema = status.projectionSchema;
        }
        if (ctx.camelSnakeCache) {
            ctx.tableSchema = Object.fromEntries(Object.entries(ctx.tableSchema).map(([key, value]) => {
                return [(0, utils_1.snakeToCamelCase)(key, ctx.camelSnakeCache), value];
            }));
        }
        if (ctx.parsingInsertedId) {
            ctx.rootObj = Object.fromEntries(Object.entries(status.primaryKeySchema).map(([key], j) => {
                return [key, ctx.rootObj[j]];
            }));
        }
        ctx.recurse = () => { throw new Error('Table deserialization does not recurse normally; please call any necessary codecs manually'); };
        ctx.populateSparseData = this._cfg?.sparseData !== true;
        return ctx;
    }
    bigNumsPresent(ctx) {
        return ctx.bigNumsPresent;
    }
    static mergeConfig(...cfg) {
        return {
            sparseData: cfg.reduce((acc, c) => c?.sparseData ?? acc, undefined),
            ...super._mergeConfig(...cfg),
        };
    }
}
exports.TableSerDes = TableSerDes;
const DefaultTableSerDesCfg = {
    serialize(key, value, ctx) {
        const codecs = ctx.codecs;
        let resp;
        for (let i = 0, n = codecs.path.length; i < n; i++) {
            const path = codecs.path[i].path;
            if ((0, utils_1.stringArraysEqual)(path, ctx.path)) {
                if ((resp = codecs.path[i].serialize?.(key, value, ctx) ?? ctx.continue())[0] !== ctx_1.CONTINUE) {
                    return resp;
                }
            }
        }
        if (ctx.path.length === 1 && key in codecs.name) {
            if ((resp = codecs.name[key].serialize?.(key, value, ctx) ?? ctx.continue())[0] !== ctx_1.CONTINUE) {
                return resp;
            }
        }
        if (typeof value === 'number') {
            if (!isFinite(value)) {
                return ctx.done(value.toString());
            }
        }
        else if (typeof value === 'object' && value !== null) {
            if (value[constants_1.$SerializeForTable]) {
                if ((resp = value[constants_1.$SerializeForTable](ctx))[0] !== ctx_1.CONTINUE) {
                    return resp;
                }
            }
            for (const codec of codecs.classGuard) {
                if (value instanceof codec.serializeClass) {
                    if ((resp = codec.serialize(key, value, ctx))[0] !== ctx_1.CONTINUE) {
                        return resp;
                    }
                }
            }
            if (value instanceof bignumber_js_1.default) {
                ctx.bigNumsPresent = true;
                return ctx.done();
            }
        }
        else if (typeof value === 'bigint') {
            ctx.bigNumsPresent = true;
        }
        for (const codec of codecs.customGuard) {
            if (codec.serializeGuard(value, ctx)) {
                if ((resp = codec.serialize(key, value, ctx))[0] !== ctx_1.CONTINUE) {
                    return resp;
                }
            }
        }
        return ctx.continue();
    },
    deserialize(key, value, ctx) {
        const codecs = ctx.codecs;
        let resp;
        if (key === '' && Object.keys(ctx.rootObj).length === 0 && ctx.populateSparseData) {
            populateSparseData(ctx); // populate sparse data for empty objects
        }
        for (let i = 0, n = codecs.path.length; i < n; i++) {
            const path = codecs.path[i].path;
            if ((0, utils_1.stringArraysEqual)(path, ctx.path)) {
                if ((resp = codecs.path[i].deserialize?.(key, value, ctx) ?? ctx.continue())[0] !== ctx_1.CONTINUE) {
                    return resp;
                }
            }
        }
        if (key === '') {
            return ctx.continue();
        }
        if (ctx.populateSparseData) { // do at this level to avoid looping on newly-populated fields if done at the top level
            populateSparseData(ctx);
            ctx.populateSparseData = false;
        }
        const column = ctx.tableSchema[key];
        if (column) {
            const type = resolveType(column);
            const obj = ctx.rootObj;
            if (key in codecs.name) {
                if ((resp = codecs.name[key].deserialize(obj[key], ctx, column))[0] !== ctx_1.CONTINUE) {
                    return resp;
                }
            }
            if (type in codecs.type) {
                if ((resp = codecs.type[type].deserialize(obj[key], ctx, column))[0] !== ctx_1.CONTINUE) {
                    return resp;
                }
            }
        }
        return ctx.done();
    },
    codecs: Object.values(codecs_1.TableCodecs.Defaults),
};
function populateSparseData(ctx) {
    for (const key in ctx.tableSchema) {
        if (key in ctx.rootObj) {
            continue;
        }
        const type = resolveType(ctx.tableSchema[key]);
        if (type === 'map') {
            ctx.rootObj[key] = new Map();
        }
        else if (type === 'set') {
            ctx.rootObj[key] = new Set();
        }
        else if (type === 'list') {
            ctx.rootObj[key] = [];
        }
        else {
            ctx.rootObj[key] = null;
        }
    }
}
function resolveType(column) {
    return (column.type === 'UNSUPPORTED')
        ? column.apiSupport.cqlDefinition
        : column.type;
}
