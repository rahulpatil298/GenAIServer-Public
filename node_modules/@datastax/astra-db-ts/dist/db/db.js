"use strict";
// Copyright Datastax, Inc
// SPDX-License-Identifier: Apache-2.0
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Db_defaultOpts, _Db_httpClient, _Db_endpoint, _Db_keyspace, _Db_id, _Db_region;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Db = void 0;
const collections_1 = require("../documents/collections");
const api_1 = require("../lib/api");
const astra_db_admin_1 = require("../administration/astra-db-admin");
const utils_1 = require("../documents/utils");
const data_api_db_admin_1 = require("../administration/data-api-db-admin");
const lib_1 = require("../lib");
const data_api_http_client_1 = require("../lib/api/clients/data-api-http-client");
const utils_2 = require("../lib/utils");
const documents_1 = require("../documents");
const constants_1 = require("../lib/api/constants");
const spawn_db_1 = require("../client/parsers/spawn-db");
const logger_1 = require("../lib/logging/logger");
const constants_2 = require("../lib/constants");
const errors_1 = require("../db/errors");
const timeouts_1 = require("../lib/api/timeouts");
const ser_des_1 = require("../documents/collections/ser-des/ser-des");
const ser_des_2 = require("../documents/tables/ser-des/ser-des");
class Db {
        constructor(rootOpts, endpoint, rawDbOpts) {
        _Db_defaultOpts.set(this, void 0);
        _Db_httpClient.set(this, void 0);
        _Db_endpoint.set(this, void 0);
        _Db_keyspace.set(this, void 0);
        _Db_id.set(this, void 0);
        _Db_region.set(this, void 0);
        const dbOpts = (0, spawn_db_1.parseDbSpawnOpts)(rawDbOpts, 'options');
        __classPrivateFieldSet(this, _Db_defaultOpts, {
            ...rootOpts,
            dbOptions: {
                keyspace: dbOpts?.keyspace ?? rootOpts.dbOptions.keyspace,
                dataApiPath: dbOpts?.dataApiPath ?? rootOpts.dbOptions.dataApiPath,
                token: lib_1.TokenProvider.mergeTokens(dbOpts?.token, rootOpts.dbOptions.token),
                logging: logger_1.Logger.advanceConfig(rootOpts.dbOptions.logging, dbOpts?.logging),
                additionalHeaders: { ...rootOpts.dbOptions.additionalHeaders, ...dbOpts?.additionalHeaders },
                timeoutDefaults: timeouts_1.Timeouts.merge(rootOpts.dbOptions.timeoutDefaults, dbOpts?.timeoutDefaults),
                serdes: {
                    collection: ser_des_1.CollectionSerDes.mergeConfig(rootOpts.dbOptions.serdes?.collection, dbOpts?.serdes?.collection, dbOpts?.serdes),
                    table: ser_des_2.TableSerDes.mergeConfig(rootOpts.dbOptions.serdes?.table, dbOpts?.serdes?.table, dbOpts?.serdes),
                },
            },
            adminOptions: {
                ...rootOpts.adminOptions,
                adminToken: lib_1.TokenProvider.mergeTokens(rootOpts.adminOptions.adminToken, rootOpts.dbOptions.token),
            },
        }, "f");
        __classPrivateFieldSet(this, _Db_keyspace, {
            ref: (rootOpts.environment === 'astra')
                ? __classPrivateFieldGet(this, _Db_defaultOpts, "f").dbOptions.keyspace ?? api_1.DEFAULT_KEYSPACE
                : __classPrivateFieldGet(this, _Db_defaultOpts, "f").dbOptions.keyspace ?? undefined,
        }, "f");
        __classPrivateFieldSet(this, _Db_httpClient, new data_api_http_client_1.DataAPIHttpClient({
            baseUrl: endpoint,
            tokenProvider: __classPrivateFieldGet(this, _Db_defaultOpts, "f").dbOptions.token,
            embeddingHeaders: documents_1.EmbeddingHeadersProvider.parseHeaders(null),
            baseApiPath: __classPrivateFieldGet(this, _Db_defaultOpts, "f").dbOptions.dataApiPath || constants_1.DEFAULT_DATA_API_PATHS[rootOpts.environment],
            emitter: rootOpts.emitter,
            logging: __classPrivateFieldGet(this, _Db_defaultOpts, "f").dbOptions.logging,
            fetchCtx: rootOpts.fetchCtx,
            keyspace: __classPrivateFieldGet(this, _Db_keyspace, "f"),
            userAgent: rootOpts.userAgent,
            emissionStrategy: data_api_http_client_1.EmissionStrategy.Normal,
            additionalHeaders: __classPrivateFieldGet(this, _Db_defaultOpts, "f").dbOptions.additionalHeaders,
            timeoutDefaults: __classPrivateFieldGet(this, _Db_defaultOpts, "f").dbOptions.timeoutDefaults,
        }), "f");
        __classPrivateFieldSet(this, _Db_id, (0, utils_1.extractDbIdFromUrl)(endpoint), "f");
        __classPrivateFieldSet(this, _Db_region, (0, utils_1.extractRegionFromUrl)(endpoint), "f");
        __classPrivateFieldSet(this, _Db_endpoint, endpoint, "f");
        Object.defineProperty(this, constants_2.$CustomInspect, {
            value: () => `Db(endpoint="${__classPrivateFieldGet(this, _Db_endpoint, "f")}",keyspace="${this.keyspace}")`,
        });
    }
        get keyspace() {
        if (!__classPrivateFieldGet(this, _Db_keyspace, "f").ref) {
            throw new Error('No keyspace set for DB (can\'t do db.keyspace, or perform any operation requiring it). Use `db.useKeyspace`, or pass the keyspace as an option parameter explicitly.');
        }
        return __classPrivateFieldGet(this, _Db_keyspace, "f").ref;
    }
        get id() {
        if (__classPrivateFieldGet(this, _Db_defaultOpts, "f").environment !== 'astra') {
            throw new errors_1.InvalidEnvironmentError('db.id', __classPrivateFieldGet(this, _Db_defaultOpts, "f").environment, ['astra'], 'non-Astra databases have no appropriate ID');
        }
        if (!__classPrivateFieldGet(this, _Db_id, "f")) {
            throw new Error(`Malformed AstraDB endpoint URL '${__classPrivateFieldGet(this, _Db_endpoint, "f")}'—database ID unable to be parsed`);
        }
        return __classPrivateFieldGet(this, _Db_id, "f");
    }
        get region() {
        if (__classPrivateFieldGet(this, _Db_defaultOpts, "f").environment !== 'astra') {
            throw new errors_1.InvalidEnvironmentError('db.region', __classPrivateFieldGet(this, _Db_defaultOpts, "f").environment, ['astra'], 'non-Astra databases have no appropriate region');
        }
        if (!__classPrivateFieldGet(this, _Db_region, "f")) {
            throw new Error(`Malformed AstraDB endpoint URL '${__classPrivateFieldGet(this, _Db_endpoint, "f")}'—database region unable to be parsed`);
        }
        return __classPrivateFieldGet(this, _Db_region, "f");
    }
        useKeyspace(keyspace) {
        __classPrivateFieldGet(this, _Db_keyspace, "f").ref = keyspace;
    }
    admin(options) {
        const environment = options?.environment ?? 'astra';
        (0, utils_2.validateDataAPIEnv)(environment);
        if (__classPrivateFieldGet(this, _Db_defaultOpts, "f").environment !== environment) {
            throw new errors_1.InvalidEnvironmentError('db.admin()', environment, [__classPrivateFieldGet(this, _Db_defaultOpts, "f").environment], 'environment option is not the same as set in the DataAPIClient');
        }
        if (environment === 'astra') {
            return new astra_db_admin_1.AstraDbAdmin(this, __classPrivateFieldGet(this, _Db_defaultOpts, "f"), options, __classPrivateFieldGet(this, _Db_defaultOpts, "f").dbOptions.token, __classPrivateFieldGet(this, _Db_endpoint, "f"));
        }
        return new data_api_db_admin_1.DataAPIDbAdmin(this, __classPrivateFieldGet(this, _Db_httpClient, "f"), options);
    }
        async info(options) {
        if (__classPrivateFieldGet(this, _Db_defaultOpts, "f").environment !== 'astra') {
            throw new errors_1.InvalidEnvironmentError('db.info()', __classPrivateFieldGet(this, _Db_defaultOpts, "f").environment, ['astra'], 'info() is only available for Astra databases');
        }
        const data = await this.admin().info(options);
        const region = __classPrivateFieldGet(this, _Db_endpoint, "f")
            .split('.')[0]
            .split('https://')[1]
            .split('-')
            .slice(5)
            .join('-');
        return {
            id: data.id,
            name: data.name,
            keyspaces: data.keyspaces,
            status: data.status,
            environment: data.environment,
            cloudProvider: data.cloudProvider,
            region: region,
            apiEndpoint: __classPrivateFieldGet(this, _Db_endpoint, "f"),
            raw: data.raw.info,
        };
    }
        collection(name, options) {
        return new collections_1.Collection(this, __classPrivateFieldGet(this, _Db_httpClient, "f"), name, {
            ...options,
            serdes: ser_des_1.CollectionSerDes.mergeConfig(__classPrivateFieldGet(this, _Db_defaultOpts, "f").dbOptions.serdes?.collection, options?.serdes),
        });
    }
        table(name, options) {
        return new documents_1.Table(this, __classPrivateFieldGet(this, _Db_httpClient, "f"), name, {
            ...options,
            serdes: ser_des_2.TableSerDes.mergeConfig(__classPrivateFieldGet(this, _Db_defaultOpts, "f").dbOptions.serdes?.table, options?.serdes),
        });
    }
        async createCollection(name, options) {
        const command = {
            createCollection: {
                name: name,
                options: {
                    defaultId: options?.defaultId,
                    indexing: options?.indexing,
                    vector: options?.vector,
                },
            },
        };
        await __classPrivateFieldGet(this, _Db_httpClient, "f").executeCommand(command, {
            timeoutManager: __classPrivateFieldGet(this, _Db_httpClient, "f").tm.single('collectionAdminTimeoutMs', {
                timeout: {
                    collectionAdminTimeoutMs: (typeof options?.timeout === 'number') ? options.timeout : options?.timeout?.collectionAdminTimeoutMs,
                    requestTimeoutMs: 0,
                },
            }),
            keyspace: options?.keyspace,
        });
        return this.collection(name, options);
    }
    async createTable(name, options) {
        const command = {
            createTable: {
                name: name,
                definition: options.definition,
                options: {
                    ifNotExists: options.ifNotExists ?? false,
                },
            },
        };
        await __classPrivateFieldGet(this, _Db_httpClient, "f").executeCommand(command, {
            timeoutManager: __classPrivateFieldGet(this, _Db_httpClient, "f").tm.single('tableAdminTimeoutMs', options),
            keyspace: options?.keyspace,
        });
        return this.table(name, options);
    }
        async dropCollection(name, options) {
        await __classPrivateFieldGet(this, _Db_httpClient, "f").executeCommand({ deleteCollection: { name } }, {
            timeoutManager: __classPrivateFieldGet(this, _Db_httpClient, "f").tm.single('collectionAdminTimeoutMs', options),
            keyspace: options?.keyspace,
        });
    }
        async dropTable(name, options) {
        await __classPrivateFieldGet(this, _Db_httpClient, "f").executeCommand({ dropTable: { name, options: { ifExists: options?.ifExists } } }, {
            timeoutManager: __classPrivateFieldGet(this, _Db_httpClient, "f").tm.single('tableAdminTimeoutMs', options),
            keyspace: options?.keyspace,
        });
    }
        async dropTableIndex(name, options) {
        const dropOpts = (options?.ifExists)
            ? { ifExists: true }
            : undefined;
        await __classPrivateFieldGet(this, _Db_httpClient, "f").executeCommand({ dropIndex: { name, options: dropOpts } }, {
            timeoutManager: __classPrivateFieldGet(this, _Db_httpClient, "f").tm.single('tableAdminTimeoutMs', options),
            keyspace: options?.keyspace,
        });
    }
    async listCollections(options) {
        const explain = options?.nameOnly !== true;
        const command = {
            findCollections: {
                options: { explain },
            },
        };
        const resp = await __classPrivateFieldGet(this, _Db_httpClient, "f").executeCommand(command, {
            timeoutManager: __classPrivateFieldGet(this, _Db_httpClient, "f").tm.single('collectionAdminTimeoutMs', options),
            keyspace: options?.keyspace,
        });
        const colls = resp.status.collections;
        if (explain) {
            for (let i = 0, n = colls.length; i < n; i++) {
                colls[i].definition = colls[i].options;
                delete colls[i].options;
            }
        }
        return colls;
    }
    async listTables(options) {
        const command = {
            listTables: {
                options: {
                    explain: options?.nameOnly !== true,
                },
            },
        };
        const resp = await __classPrivateFieldGet(this, _Db_httpClient, "f").executeCommand(command, {
            timeoutManager: __classPrivateFieldGet(this, _Db_httpClient, "f").tm.single('tableAdminTimeoutMs', options),
            keyspace: options?.keyspace,
        });
        return resp.status.tables;
    }
        async command(command, options) {
        if (options?.collection && options.table) {
            throw new Error('Can\'t provide both `table` and `collection` as options to db.command()');
        }
        return await __classPrivateFieldGet(this, _Db_httpClient, "f").executeCommand(command, {
            timeoutManager: __classPrivateFieldGet(this, _Db_httpClient, "f").tm.single('generalMethodTimeoutMs', options),
            collection: options?.collection ?? options?.table,
            keyspace: options?.keyspace,
        });
    }
    get _httpClient() {
        return __classPrivateFieldGet(this, _Db_httpClient, "f");
    }
}
exports.Db = Db;
_Db_defaultOpts = new WeakMap(), _Db_httpClient = new WeakMap(), _Db_endpoint = new WeakMap(), _Db_keyspace = new WeakMap(), _Db_id = new WeakMap(), _Db_region = new WeakMap();
